# ç¬¬7ç« ï¼šå®Œæ•´å°ˆæ¡ˆå¯¦ä½œ - é«˜ç´š

æœ¬ç« å°‡å¸¶æ‚¨é–‹ç™¼ä¸€å€‹ä¼æ¥­ç´šçš„ã€Œå¤šç§Ÿæˆ¶ SaaS è‡ªå‹•åŒ–å¹³å°ã€ï¼Œé€™æ˜¯ä¸€å€‹è¤‡é›œçš„é«˜ç´šå°ˆæ¡ˆï¼Œæ¶µè“‹å¤šç§Ÿæˆ¶æ¶æ§‹ã€å¾®æœå‹™è¨­è¨ˆã€é«˜å¯ç”¨æ€§éƒ¨ç½²ä»¥åŠä¼æ¥­ç´šå®‰å…¨æ€§è¦æ±‚ã€‚

> ğŸ“š **ä½ä»£ç¢¼å‹å–„æç¤º**
> 
> æœ¬ç« åŒ…å«è¨±å¤šä¼æ¥­ç´šæŠ€è¡“æ¦‚å¿µã€‚ç‚ºäº†å¹«åŠ©æ‚¨æ›´å¥½ç†è§£ï¼Œæˆ‘å€‘æœƒåœ¨ç›¸é—œæŠ€è¡“å‡ºç¾æ™‚æä¾›ç°¡æ˜è§£é‡‹ã€‚ä¸ç”¨æ“”å¿ƒï¼Œæˆ‘å€‘æœƒå¾ªåºæ¼¸é€²åœ°å¼•å°æ‚¨æŒæ¡é€™äº›æ¦‚å¿µï¼

## 7.1 å°ˆæ¡ˆæ¦‚è¿°

### ğŸ¯ å°ˆæ¡ˆç›®æ¨™

å»ºç«‹ä¸€å€‹ä¼æ¥­ç´šçš„å¤šç§Ÿæˆ¶ SaaS å¹³å°ï¼Œè®“ä¸åŒçš„ä¼æ¥­å®¢æˆ¶èƒ½å¤ ï¼š
1. å»ºç«‹å’Œç®¡ç†è‡ªå·±çš„è‡ªå‹•åŒ–å·¥ä½œæµç¨‹
2. è¨­å®šè¤‡é›œçš„æ¥­å‹™è¦å‰‡å’Œæ¢ä»¶é‚è¼¯
3. æ•´åˆè‡ªå·±çš„ä¼æ¥­ç³»çµ±ï¼ˆERPã€CRMã€ç­‰ï¼‰
4. ç›£æ§å’Œåˆ†æè‡ªå‹•åŒ–åŸ·è¡Œæ•ˆæœ
5. ç®¡ç†åœ˜éšŠæˆå“¡å’Œæ¬Šé™è¨­å®š
6. è‡ªè¨‚å“ç‰Œå’Œä»‹é¢å¤–è§€

### ğŸ“‹ ä¼æ¥­ç´šéœ€æ±‚

**é«˜ç´šå°ˆæ¡ˆç‰¹è‰²ï¼š**
- å¤šç§Ÿæˆ¶è³‡æ–™éš”é›¢
- å¾®æœå‹™æ¶æ§‹è¨­è¨ˆ
- é«˜å¯ç”¨æ€§å’Œå®¹éŒ¯æ€§
- ä¼æ¥­ç´šå®‰å…¨æ§åˆ¶
- æ°´å¹³æ“´å±•èƒ½åŠ›
- å³æ™‚ç›£æ§å’Œå‘Šè­¦
- API é€Ÿç‡é™åˆ¶å’Œé…é¡ç®¡ç†
- ç™½æ¨™ç±¤å®¢è£½åŒ–

> ğŸ’¡ **è¡“èªè§£é‡‹ç›’å­**
> 
> - **å¤šç§Ÿæˆ¶ (Multi-tenant)**ï¼šä¸€å€‹æ‡‰ç”¨ç¨‹å¼åŒæ™‚æœå‹™å¤šå€‹å®¢æˆ¶ï¼ˆç§Ÿæˆ¶ï¼‰ï¼Œæ¯å€‹ç§Ÿæˆ¶çš„è³‡æ–™å®Œå…¨éš”é›¢
> - **å¾®æœå‹™ (Microservices)**ï¼šå°‡å¤§å‹æ‡‰ç”¨ç¨‹å¼æ‹†åˆ†æˆå¤šå€‹å°çš„ã€ç¨ç«‹çš„æœå‹™ï¼Œå„è‡ªè² è²¬ç‰¹å®šåŠŸèƒ½
> - **é«˜å¯ç”¨æ€§ (High Availability)**ï¼šç³»çµ±èƒ½å¤ æŒçºŒé‹è¡Œï¼Œå³ä½¿éƒ¨åˆ†çµ„ä»¶æ•…éšœä¹Ÿä¸æœƒå½±éŸ¿æ•´é«”æœå‹™
> - **å®¹éŒ¯æ€§ (Fault Tolerance)**ï¼šç³»çµ±åœ¨é‡åˆ°éŒ¯èª¤æ™‚èƒ½å¤ è‡ªå‹•æ¢å¾©ï¼Œä¸æœƒå®Œå…¨åœæ©Ÿ
> - **æ°´å¹³æ“´å±• (Horizontal Scaling)**ï¼šé€éå¢åŠ æ›´å¤šä¼ºæœå™¨ä¾†æå‡ç³»çµ±æ€§èƒ½ï¼ˆvs å‚ç›´æ“´å±•ï¼šå‡ç´šå–®ä¸€ä¼ºæœå™¨ç¡¬é«”ï¼‰
> - **ç™½æ¨™ç±¤ (White Label)**ï¼šå¯ä»¥å®¢è£½åŒ–å“ç‰Œå¤–è§€çš„è§£æ±ºæ–¹æ¡ˆï¼Œè®“æ‚¨çš„å®¢æˆ¶ä»¥ç‚ºæ˜¯æ‚¨é–‹ç™¼çš„ç”¢å“

### ğŸ—ï¸ ç³»çµ±æ¶æ§‹

```
å¤šç§Ÿæˆ¶ SaaS è‡ªå‹•åŒ–å¹³å°
â”œâ”€â”€ å‰ç«¯å±¤ (Frontend Tier)
â”‚   â”œâ”€â”€ ç®¡ç†è€…å„€è¡¨æ¿
â”‚   â”œâ”€â”€ ç§Ÿæˆ¶ç®¡ç†ä»‹é¢
â”‚   â”œâ”€â”€ çµ‚ç«¯ä½¿ç”¨è€…ä»‹é¢
â”‚   â””â”€â”€ å“ç‰Œå®¢è£½åŒ–å±¤
â”œâ”€â”€ API é–˜é“å±¤ (API Gateway)
â”‚   â”œâ”€â”€ èªè­‰èˆ‡æˆæ¬Š
â”‚   â”œâ”€â”€ é€Ÿç‡é™åˆ¶
â”‚   â”œâ”€â”€ è«‹æ±‚è·¯ç”±
â”‚   â””â”€â”€ ç›£æ§æ”¶é›†
â”œâ”€â”€ æ‡‰ç”¨æœå‹™å±¤ (Application Services)
â”‚   â”œâ”€â”€ ç§Ÿæˆ¶ç®¡ç†æœå‹™
â”‚   â”œâ”€â”€ å·¥ä½œæµç¨‹ç®¡ç†æœå‹™
â”‚   â”œâ”€â”€ Make Bridge æ•´åˆæœå‹™
â”‚   â”œâ”€â”€ é€šçŸ¥æœå‹™
â”‚   â””â”€â”€ åˆ†ææœå‹™
â”œâ”€â”€ è³‡æ–™å±¤ (Data Tier)
â”‚   â”œâ”€â”€ ä¸»è¦è³‡æ–™åº« (PostgreSQL)
â”‚   â”œâ”€â”€ å¿«å–å±¤ (Redis)
â”‚   â”œâ”€â”€ æª”æ¡ˆå„²å­˜ (S3)
â”‚   â””â”€â”€ æ™‚é–“åºåˆ—è³‡æ–™åº« (InfluxDB)
â””â”€â”€ åŸºç¤è¨­æ–½å±¤ (Infrastructure)
    â”œâ”€â”€ å®¹å™¨ç·¨æ’ (Kubernetes)
    â”œâ”€â”€ æœå‹™ç¶²æ ¼ (Istio)
    â”œâ”€â”€ ç›£æ§ç³»çµ± (Prometheus + Grafana)
    â””â”€â”€ æ—¥èªŒèšåˆ (ELK Stack)
```

## 7.2 æ­¥é©Ÿ 1ï¼šå¤šç§Ÿæˆ¶æ¶æ§‹è¨­è¨ˆ

### ğŸ¢ ç§Ÿæˆ¶ç®¡ç†ç³»çµ±

> ğŸ” **æ¦‚å¿µè§£é‡‹**
> 
> **ç§Ÿæˆ¶ (Tenant)** å°±åƒæ˜¯ä¸€æ£Ÿå¤§æ¨“ä¸­çš„ä¸åŒå…¬å¸ã€‚æ¯å®¶å…¬å¸ï¼ˆç§Ÿæˆ¶ï¼‰éƒ½æœ‰è‡ªå·±çš„è¾¦å…¬å®¤ï¼ˆè³‡æ–™ç©ºé–“ï¼‰ï¼Œå½¼æ­¤ä¸æœƒäº’ç›¸å¹²æ“¾ã€‚åœ¨ SaaS ç³»çµ±ä¸­ï¼Œæ¯å€‹ä¼æ¥­å®¢æˆ¶å°±æ˜¯ä¸€å€‹ç§Ÿæˆ¶ã€‚

#### è³‡æ–™æ¨¡å‹è¨­è¨ˆ

> ğŸ’¾ **è³‡æ–™åº«æ¦‚å¿µ**
> 
> è³‡æ–™æ¨¡å‹å°±åƒæ˜¯è¨­è¨ˆæˆ¿å±‹çš„è—åœ–ï¼Œå®šç¾©äº†ï¼š
> - éœ€è¦å“ªäº›è³‡æ–™è¡¨ï¼ˆæˆ¿é–“ï¼‰
> - æ¯å€‹è¡¨å­˜æ”¾ä»€éº¼è³‡æ–™ï¼ˆæˆ¿é–“ç”¨é€”ï¼‰
> - è¡¨ä¹‹é–“å¦‚ä½•é—œè¯ï¼ˆæˆ¿é–“ä¹‹é–“çš„é€£æ¥ï¼‰

```sql
-- tenants.sql - ç§Ÿæˆ¶è³‡æ–™è¡¨çµæ§‹

-- ç§Ÿæˆ¶ä¸»è¡¨
CREATE TABLE tenants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    slug VARCHAR(100) UNIQUE NOT NULL,
    domain VARCHAR(255),
    plan_type VARCHAR(50) NOT NULL DEFAULT 'basic',
    status VARCHAR(20) NOT NULL DEFAULT 'active',
    
    -- é…ç½®è¨­å®š
    config JSONB DEFAULT '{}',
    branding JSONB DEFAULT '{}',
    
    -- Make Bridge è¨­å®š
    make_bridge_config JSONB DEFAULT '{}',
    
    -- é™åˆ¶å’Œé…é¡
    limits JSONB DEFAULT '{
        "max_workflows": 10,
        "max_executions_per_month": 1000,
        "max_team_members": 5
    }',
    
    -- æ™‚é–“æˆ³è¨˜
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- å»ºç«‹ç´¢å¼•
    INDEX idx_tenants_slug (slug),
    INDEX idx_tenants_status (status),
    INDEX idx_tenants_plan_type (plan_type)
);

-- ç§Ÿæˆ¶ä½¿ç”¨è€…è¡¨
CREATE TABLE tenant_users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    user_id UUID NOT NULL,
    email VARCHAR(255) NOT NULL,
    role VARCHAR(50) NOT NULL DEFAULT 'member',
    
    -- æ¬Šé™è¨­å®š
    permissions JSONB DEFAULT '[]',
    
    -- ç‹€æ…‹
    status VARCHAR(20) NOT NULL DEFAULT 'active',
    invited_at TIMESTAMP WITH TIME ZONE,
    joined_at TIMESTAMP WITH TIME ZONE,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    UNIQUE(tenant_id, email),
    INDEX idx_tenant_users_tenant (tenant_id),
    INDEX idx_tenant_users_email (email),
    INDEX idx_tenant_users_role (role)
);

-- å·¥ä½œæµç¨‹è¡¨
CREATE TABLE workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    
    -- Make Bridge ç›¸é—œ
    make_template_id VARCHAR(255),
    make_scenario_id VARCHAR(255),
    
    -- é…ç½®å’Œç‹€æ…‹
    config JSONB DEFAULT '{}',
    status VARCHAR(20) NOT NULL DEFAULT 'draft',
    
    -- çµ±è¨ˆè³‡æ–™
    execution_count INTEGER DEFAULT 0,
    success_count INTEGER DEFAULT 0,
    error_count INTEGER DEFAULT 0,
    last_executed_at TIMESTAMP WITH TIME ZONE,
    
    -- å»ºç«‹è€…è³‡è¨Š
    created_by UUID NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    INDEX idx_workflows_tenant (tenant_id),
    INDEX idx_workflows_status (status),
    INDEX idx_workflows_template (make_template_id)
);

-- å·¥ä½œæµç¨‹åŸ·è¡Œè¨˜éŒ„
CREATE TABLE workflow_executions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    workflow_id UUID NOT NULL REFERENCES workflows(id) ON DELETE CASCADE,
    
    -- åŸ·è¡Œè³‡è¨Š
    trigger_data JSONB,
    execution_result JSONB,
    status VARCHAR(20) NOT NULL,
    
    -- æ™‚é–“è¿½è¹¤
    started_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    completed_at TIMESTAMP WITH TIME ZONE,
    duration_ms INTEGER,
    
    -- éŒ¯èª¤è³‡è¨Š
    error_message TEXT,
    error_details JSONB,
    
    INDEX idx_executions_tenant (tenant_id),
    INDEX idx_executions_workflow (workflow_id),
    INDEX idx_executions_status (status),
    INDEX idx_executions_started (started_at)
);
```

#### ç§Ÿæˆ¶ç®¡ç†æœå‹™

```javascript
// services/TenantService.js - ç§Ÿæˆ¶ç®¡ç†æœå‹™
const { Pool } = require('pg');
const Redis = require('redis');
const crypto = require('crypto');

class TenantService {
    constructor() {
        this.db = new Pool({
            connectionString: process.env.DATABASE_URL,
            max: 20,
            idleTimeoutMillis: 30000,
            connectionTimeoutMillis: 2000,
        });
        
        this.redis = Redis.createClient({
            url: process.env.REDIS_URL
        });
        
        this.redis.connect();
    }

    /**
     * å»ºç«‹æ–°ç§Ÿæˆ¶
     */
    async createTenant(tenantData) {
        const client = await this.db.connect();
        
        try {
            await client.query('BEGIN');
            
            // ç”Ÿæˆå”¯ä¸€çš„ slug
            const slug = await this.generateUniqueSlug(tenantData.name);
            
            // å»ºç«‹ç§Ÿæˆ¶
            const tenantResult = await client.query(`
                INSERT INTO tenants (name, slug, domain, plan_type, config, branding, limits)
                VALUES ($1, $2, $3, $4, $5, $6, $7)
                RETURNING *
            `, [
                tenantData.name,
                slug,
                tenantData.domain,
                tenantData.planType || 'basic',
                tenantData.config || {},
                tenantData.branding || {},
                this.getDefaultLimits(tenantData.planType)
            ]);
            
            const tenant = tenantResult.rows[0];
            
            // å»ºç«‹ç®¡ç†å“¡ä½¿ç”¨è€…
            if (tenantData.adminUser) {
                await client.query(`
                    INSERT INTO tenant_users (tenant_id, user_id, email, role, status, joined_at)
                    VALUES ($1, $2, $3, 'admin', 'active', NOW())
                `, [
                    tenant.id,
                    tenantData.adminUser.id,
                    tenantData.adminUser.email
                ]);
            }
            
            await client.query('COMMIT');
            
            // åˆå§‹åŒ–ç§Ÿæˆ¶è¨­å®š
            await this.initializeTenantSettings(tenant.id);
            
            return tenant;
            
        } catch (error) {
            await client.query('ROLLBACK');
            throw error;
        } finally {
            client.release();
        }
    }

    /**
     * å–å¾—ç§Ÿæˆ¶è³‡è¨Š
     */
    async getTenant(identifier) {
        // å˜—è©¦å¾å¿«å–å–å¾—
        const cacheKey = `tenant:${identifier}`;
        const cached = await this.redis.get(cacheKey);
        
        if (cached) {
            return JSON.parse(cached);
        }
        
        // å¾è³‡æ–™åº«æŸ¥è©¢
        const isUuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(identifier);
        const query = isUuid 
            ? 'SELECT * FROM tenants WHERE id = $1'
            : 'SELECT * FROM tenants WHERE slug = $1 OR domain = $1';
        
        const result = await this.db.query(query, [identifier]);
        
        if (result.rows.length === 0) {
            throw new Error('ç§Ÿæˆ¶ä¸å­˜åœ¨');
        }
        
        const tenant = result.rows[0];
        
        // å¿«å–çµæœ
        await this.redis.setEx(cacheKey, 300, JSON.stringify(tenant)); // 5åˆ†é˜å¿«å–
        
        return tenant;
    }

    /**
     * æ›´æ–°ç§Ÿæˆ¶è¨­å®š
     */
    async updateTenant(tenantId, updates) {
        const allowedFields = ['name', 'domain', 'config', 'branding', 'status'];
        const updateFields = [];
        const values = [];
        let paramIndex = 1;
        
        for (const field of allowedFields) {
            if (updates.hasOwnProperty(field)) {
                updateFields.push(`${field} = $${paramIndex}`);
                values.push(updates[field]);
                paramIndex++;
            }
        }
        
        if (updateFields.length === 0) {
            throw new Error('æ²’æœ‰å¯æ›´æ–°çš„æ¬„ä½');
        }
        
        updateFields.push(`updated_at = NOW()`);
        values.push(tenantId);
        
        const query = `
            UPDATE tenants 
            SET ${updateFields.join(', ')}
            WHERE id = $${paramIndex}
            RETURNING *
        `;
        
        const result = await this.db.query(query, values);
        
        if (result.rows.length === 0) {
            throw new Error('ç§Ÿæˆ¶ä¸å­˜åœ¨');
        }
        
        const tenant = result.rows[0];
        
        // æ¸…é™¤å¿«å–
        await this.redis.del(`tenant:${tenantId}`);
        await this.redis.del(`tenant:${tenant.slug}`);
        
        return tenant;
    }

    /**
     * æª¢æŸ¥ç§Ÿæˆ¶é™åˆ¶
     */
    async checkTenantLimits(tenantId, resource) {
        const tenant = await this.getTenant(tenantId);
        const limits = tenant.limits;
        
        switch (resource) {
            case 'workflows':
                const workflowCount = await this.getWorkflowCount(tenantId);
                return {
                    allowed: workflowCount < limits.max_workflows,
                    current: workflowCount,
                    limit: limits.max_workflows
                };
                
            case 'executions':
                const monthlyExecutions = await this.getMonthlyExecutionCount(tenantId);
                return {
                    allowed: monthlyExecutions < limits.max_executions_per_month,
                    current: monthlyExecutions,
                    limit: limits.max_executions_per_month
                };
                
            case 'team_members':
                const memberCount = await this.getTeamMemberCount(tenantId);
                return {
                    allowed: memberCount < limits.max_team_members,
                    current: memberCount,
                    limit: limits.max_team_members
                };
                
            default:
                throw new Error('æœªçŸ¥çš„è³‡æºé¡å‹');
        }
    }

    /**
     * ç”Ÿæˆå”¯ä¸€çš„ slug
     */
    async generateUniqueSlug(name) {
        const baseSlug = name
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, '-')
            .replace(/^-+|-+$/g, '');
        
        let slug = baseSlug;
        let counter = 1;
        
        while (await this.slugExists(slug)) {
            slug = `${baseSlug}-${counter}`;
            counter++;
        }
        
        return slug;
    }

    async slugExists(slug) {
        const result = await this.db.query('SELECT 1 FROM tenants WHERE slug = $1', [slug]);
        return result.rows.length > 0;
    }

    getDefaultLimits(planType) {
        const limits = {
            basic: {
                max_workflows: 5,
                max_executions_per_month: 1000,
                max_team_members: 3
            },
            pro: {
                max_workflows: 25,
                max_executions_per_month: 10000,
                max_team_members: 10
            },
            enterprise: {
                max_workflows: 100,
                max_executions_per_month: 100000,
                max_team_members: 50
            }
        };
        
        return limits[planType] || limits.basic;
    }

    async initializeTenantSettings(tenantId) {
        // å»ºç«‹é è¨­çš„ Make Bridge è¨­å®š
        await this.db.query(`
            UPDATE tenants 
            SET make_bridge_config = $1
            WHERE id = $2
        `, [
            {
                zone_url: process.env.MAKE_ZONE_URL,
                templates: [],
                default_settings: {
                    auto_activate: true,
                    notification_email: null
                }
            },
            tenantId
        ]);
    }

    async getWorkflowCount(tenantId) {
        const result = await this.db.query(
            'SELECT COUNT(*) FROM workflows WHERE tenant_id = $1',
            [tenantId]
        );
        return parseInt(result.rows[0].count);
    }

    async getMonthlyExecutionCount(tenantId) {
        const startOfMonth = new Date();
        startOfMonth.setDate(1);
        startOfMonth.setHours(0, 0, 0, 0);
        
        const result = await this.db.query(`
            SELECT COUNT(*) FROM workflow_executions 
            WHERE tenant_id = $1 AND started_at >= $2
        `, [tenantId, startOfMonth]);
        
        return parseInt(result.rows[0].count);
    }

    async getTeamMemberCount(tenantId) {
        const result = await this.db.query(
            'SELECT COUNT(*) FROM tenant_users WHERE tenant_id = $1 AND status = \'active\'',
            [tenantId]
        );
        return parseInt(result.rows[0].count);
    }
}

module.exports = TenantService;
```

### ğŸ” ä¼æ¥­ç´šèªè­‰èˆ‡æˆæ¬Š

> ğŸ”‘ **å®‰å…¨æ¦‚å¿µè§£é‡‹**
> 
> - **èªè­‰ (Authentication)**ï¼šç¢ºèªã€Œä½ æ˜¯èª°ã€ï¼ˆåƒæ˜¯æŸ¥çœ‹èº«åˆ†è­‰ï¼‰
> - **æˆæ¬Š (Authorization)**ï¼šç¢ºèªã€Œä½ èƒ½åšä»€éº¼ã€ï¼ˆåƒæ˜¯æª¢æŸ¥é–€ç¦å¡æ¬Šé™ï¼‰
> - **JWT (JSON Web Token)**ï¼šä¸€ç¨®å®‰å…¨çš„èº«åˆ†æ†‘è­‰ï¼Œå°±åƒæ˜¯æœ‰æ•¸ä½ç°½åçš„é€šè¡Œè­‰

#### JWT ä¸­é–“ä»¶èˆ‡æ¬Šé™æ§åˆ¶

```javascript
// middleware/auth.js - èªè­‰èˆ‡æˆæ¬Šä¸­é–“ä»¶
const jwt = require('jsonwebtoken');
const { promisify } = require('util');
const TenantService = require('../services/TenantService');

class AuthMiddleware {
    constructor() {
        this.tenantService = new TenantService();
        this.jwtVerify = promisify(jwt.verify);
    }

    /**
     * é©—è­‰ JWT Token
     */
    authenticateToken() {
        return async (req, res, next) => {
            try {
                const authHeader = req.headers.authorization;
                const token = authHeader && authHeader.split(' ')[1];
                
                if (!token) {
                    return res.status(401).json({ error: 'ç¼ºå°‘èªè­‰ Token' });
                }
                
                const decoded = await this.jwtVerify(token, process.env.JWT_SECRET);
                req.user = decoded;
                
                next();
            } catch (error) {
                return res.status(403).json({ error: 'Token ç„¡æ•ˆæˆ–å·²éæœŸ' });
            }
        };
    }

    /**
     * è­˜åˆ¥ç§Ÿæˆ¶
     */
    identifyTenant() {
        return async (req, res, next) => {
            try {
                let tenantIdentifier = null;
                
                // æ–¹æ³• 1: å¾ subdomain è­˜åˆ¥
                const host = req.get('Host');
                if (host) {
                    const subdomain = host.split('.')[0];
                    if (subdomain && subdomain !== 'www' && subdomain !== 'api') {
                        tenantIdentifier = subdomain;
                    }
                }
                
                // æ–¹æ³• 2: å¾ header è­˜åˆ¥
                if (!tenantIdentifier) {
                    tenantIdentifier = req.headers['x-tenant-id'];
                }
                
                // æ–¹æ³• 3: å¾è·¯å¾‘åƒæ•¸è­˜åˆ¥
                if (!tenantIdentifier) {
                    tenantIdentifier = req.params.tenantId;
                }
                
                if (!tenantIdentifier) {
                    return res.status(400).json({ error: 'ç„¡æ³•è­˜åˆ¥ç§Ÿæˆ¶' });
                }
                
                const tenant = await this.tenantService.getTenant(tenantIdentifier);
                req.tenant = tenant;
                
                next();
            } catch (error) {
                return res.status(404).json({ error: 'ç§Ÿæˆ¶ä¸å­˜åœ¨' });
            }
        };
    }

    /**
     * æª¢æŸ¥ç§Ÿæˆ¶æ¬Šé™
     */
    requireTenantPermission(permission) {
        return async (req, res, next) => {
            try {
                if (!req.tenant || !req.user) {
                    return res.status(401).json({ error: 'æœªèªè­‰' });
                }
                
                const hasPermission = await this.checkUserPermission(
                    req.user.id,
                    req.tenant.id,
                    permission
                );
                
                if (!hasPermission) {
                    return res.status(403).json({ error: 'æ¬Šé™ä¸è¶³' });
                }
                
                next();
            } catch (error) {
                return res.status(500).json({ error: 'æ¬Šé™æª¢æŸ¥å¤±æ•—' });
            }
        };
    }

    /**
     * æª¢æŸ¥ä½¿ç”¨è€…æ¬Šé™
     */
    async checkUserPermission(userId, tenantId, permission) {
        const result = await this.tenantService.db.query(`
            SELECT role, permissions 
            FROM tenant_users 
            WHERE user_id = $1 AND tenant_id = $2 AND status = 'active'
        `, [userId, tenantId]);
        
        if (result.rows.length === 0) {
            return false;
        }
        
        const { role, permissions } = result.rows[0];
        
        // è¶…ç´šç®¡ç†å“¡æ“æœ‰æ‰€æœ‰æ¬Šé™
        if (role === 'admin') {
            return true;
        }
        
        // æª¢æŸ¥è§’è‰²æ¬Šé™
        const rolePermissions = this.getRolePermissions(role);
        if (rolePermissions.includes(permission)) {
            return true;
        }
        
        // æª¢æŸ¥è‡ªå®šç¾©æ¬Šé™
        if (permissions && permissions.includes(permission)) {
            return true;
        }
        
        return false;
    }

    getRolePermissions(role) {
        const rolePermissionMap = {
            'admin': ['*'], // æ‰€æœ‰æ¬Šé™
            'manager': [
                'workflows:read',
                'workflows:write',
                'workflows:delete',
                'team:read',
                'team:write',
                'analytics:read'
            ],
            'editor': [
                'workflows:read',
                'workflows:write',
                'analytics:read'
            ],
            'viewer': [
                'workflows:read',
                'analytics:read'
            ],
            'member': [
                'workflows:read'
            ]
        };
        
        return rolePermissionMap[role] || [];
    }

    /**
     * é€Ÿç‡é™åˆ¶
     */
    rateLimitByTenant() {
        const limiters = new Map();
        
        return async (req, res, next) => {
            if (!req.tenant) {
                return next();
            }
            
            const tenantId = req.tenant.id;
            const planType = req.tenant.plan_type;
            
            // æ ¹æ“šæ–¹æ¡ˆè¨­å®šä¸åŒçš„é™åˆ¶
            const limits = {
                basic: { windowMs: 15 * 60 * 1000, max: 100 },
                pro: { windowMs: 15 * 60 * 1000, max: 500 },
                enterprise: { windowMs: 15 * 60 * 1000, max: 2000 }
            };
            
            const config = limits[planType] || limits.basic;
            
            // å¯¦ä½œç°¡å–®çš„æ»‘å‹•è¦–çª—é€Ÿç‡é™åˆ¶
            if (!limiters.has(tenantId)) {
                limiters.set(tenantId, {
                    requests: [],
                    ...config
                });
            }
            
            const limiter = limiters.get(tenantId);
            const now = Date.now();
            
            // æ¸…ç†éæœŸçš„è«‹æ±‚è¨˜éŒ„
            limiter.requests = limiter.requests.filter(
                time => now - time < limiter.windowMs
            );
            
            if (limiter.requests.length >= limiter.max) {
                return res.status(429).json({
                    error: 'è«‹æ±‚éæ–¼é »ç¹',
                    retryAfter: Math.ceil(limiter.windowMs / 1000)
                });
            }
            
            limiter.requests.push(now);
            next();
        };
    }
}

module.exports = new AuthMiddleware();
```

## 7.3 æ­¥é©Ÿ 2ï¼šå¾®æœå‹™æ¶æ§‹å¯¦ä½œ

### ğŸ”§ API é–˜é“æœå‹™

> ğŸšª **API é–˜é“æ¦‚å¿µ**
> 
> API é–˜é“å°±åƒæ˜¯å¤§æ¨“çš„æ¥å¾…è™•ï¼š
> - æ‰€æœ‰è¨ªå®¢ï¼ˆè«‹æ±‚ï¼‰éƒ½å¿…é ˆå…ˆé€šéæ¥å¾…è™•
> - æ¥å¾…å“¡æª¢æŸ¥èº«åˆ†ä¸¦æŒ‡å¼•åˆ°æ­£ç¢ºçš„æ¨“å±¤ï¼ˆæœå‹™ï¼‰
> - è¨˜éŒ„è¨ªå®¢ç´€éŒ„ï¼ˆæ—¥èªŒï¼‰ä¸¦ç›£æ§å¤§æ¨“å®‰å…¨ï¼ˆç›£æ§æŒ‡æ¨™ï¼‰

```javascript
// gateway/api-gateway.js - API é–˜é“ä¸»æœå‹™
const express = require('express');
const httpProxy = require('http-proxy-middleware');
const cors = require('cors');
const helmet = require('helmet');
const compression = require('compression');
const prometheus = require('prom-client');

class APIGateway {
    constructor() {
        this.app = express();
        this.setupMiddleware();
        this.setupMetrics();
        this.setupRoutes();
    }

    setupMiddleware() {
        // å®‰å…¨æ€§
        this.app.use(helmet());
        this.app.use(compression());
        
        // CORS è¨­å®š
        this.app.use(cors({
            origin: (origin, callback) => {
                // å‹•æ…‹ CORS é©—è­‰é‚è¼¯
                this.validateOrigin(origin, callback);
            },
            credentials: true
        }));
        
        this.app.use(express.json({ limit: '10mb' }));
        
        // è«‹æ±‚æ—¥èªŒ
        this.app.use(this.requestLogger());
        
        // å¥åº·æª¢æŸ¥
        this.app.get('/health', (req, res) => {
            res.json({
                status: 'healthy',
                timestamp: new Date().toISOString(),
                uptime: process.uptime()
            });
        });
        
        // æŒ‡æ¨™ç«¯é»
        this.app.get('/metrics', (req, res) => {
            res.set('Content-Type', prometheus.register.contentType);
            res.end(prometheus.register.metrics());
        });
    }

    setupMetrics() {
        // HTTP è«‹æ±‚è¨ˆæ•¸å™¨
        this.httpRequestCounter = new prometheus.Counter({
            name: 'http_requests_total',
            help: 'HTTP è«‹æ±‚ç¸½æ•¸',
            labelNames: ['method', 'route', 'status_code', 'tenant_id']
        });
        
        // è«‹æ±‚æŒçºŒæ™‚é–“
        this.httpRequestDuration = new prometheus.Histogram({
            name: 'http_request_duration_seconds',
            help: 'HTTP è«‹æ±‚æŒçºŒæ™‚é–“',
            labelNames: ['method', 'route', 'tenant_id'],
            buckets: [0.1, 0.5, 1, 2, 5, 10]
        });
        
        // Make Bridge è«‹æ±‚
        this.makeBridgeRequests = new prometheus.Counter({
            name: 'make_bridge_requests_total',
            help: 'Make Bridge è«‹æ±‚ç¸½æ•¸',
            labelNames: ['tenant_id', 'status']
        });
    }

    setupRoutes() {
        // ç§Ÿæˆ¶ç®¡ç†æœå‹™
        this.app.use('/api/tenants', this.createProxy({
            target: process.env.TENANT_SERVICE_URL || 'http://localhost:3001',
            pathRewrite: { '^/api/tenants': '' }
        }));
        
        // å·¥ä½œæµç¨‹ç®¡ç†æœå‹™
        this.app.use('/api/workflows', this.createProxy({
            target: process.env.WORKFLOW_SERVICE_URL || 'http://localhost:3002',
            pathRewrite: { '^/api/workflows': '' }
        }));
        
        // Make Bridge æ•´åˆæœå‹™
        this.app.use('/api/bridge', this.createProxy({
            target: process.env.BRIDGE_SERVICE_URL || 'http://localhost:3003',
            pathRewrite: { '^/api/bridge': '' }
        }));
        
        // åˆ†ææœå‹™
        this.app.use('/api/analytics', this.createProxy({
            target: process.env.ANALYTICS_SERVICE_URL || 'http://localhost:3004',
            pathRewrite: { '^/api/analytics': '' }
        }));
        
        // é€šçŸ¥æœå‹™
        this.app.use('/api/notifications', this.createProxy({
            target: process.env.NOTIFICATION_SERVICE_URL || 'http://localhost:3005',
            pathRewrite: { '^/api/notifications': '' }
        }));
    }

    createProxy(options) {
        return httpProxy({
            ...options,
            changeOrigin: true,
            timeout: 30000,
            
            // è«‹æ±‚è½‰æ›
            onProxyReq: (proxyReq, req, res) => {
                // æ·»åŠ ç§Ÿæˆ¶è³‡è¨Šåˆ° header
                if (req.tenant) {
                    proxyReq.setHeader('X-Tenant-ID', req.tenant.id);
                    proxyReq.setHeader('X-Tenant-Plan', req.tenant.plan_type);
                }
                
                // æ·»åŠ ä½¿ç”¨è€…è³‡è¨Š
                if (req.user) {
                    proxyReq.setHeader('X-User-ID', req.user.id);
                    proxyReq.setHeader('X-User-Email', req.user.email);
                }
                
                // è¨˜éŒ„è«‹æ±‚æŒ‡æ¨™
                const labels = {
                    method: req.method,
                    route: this.normalizeRoute(req.route?.path || req.path),
                    tenant_id: req.tenant?.id || 'unknown'
                };
                
                req.startTime = Date.now();
                this.httpRequestCounter.inc(labels);
            },
            
            // å›æ‡‰è½‰æ›
            onProxyRes: (proxyRes, req, res) => {
                // è¨˜éŒ„å›æ‡‰æŒ‡æ¨™
                if (req.startTime) {
                    const duration = (Date.now() - req.startTime) / 1000;
                    const labels = {
                        method: req.method,
                        route: this.normalizeRoute(req.route?.path || req.path),
                        tenant_id: req.tenant?.id || 'unknown'
                    };
                    
                    this.httpRequestDuration.observe(labels, duration);
                    this.httpRequestCounter.labels({
                        ...labels,
                        status_code: proxyRes.statusCode
                    }).inc();
                }
            },
            
            // éŒ¯èª¤è™•ç†
            onError: (err, req, res) => {
                console.error('ä»£ç†éŒ¯èª¤:', err);
                res.status(502).json({
                    error: 'æœå‹™æš«æ™‚ç„¡æ³•ä½¿ç”¨',
                    code: 'SERVICE_UNAVAILABLE'
                });
            }
        });
    }

    async validateOrigin(origin, callback) {
        // å…è¨±æœ¬åœ°é–‹ç™¼
        if (!origin || origin.includes('localhost')) {
            return callback(null, true);
        }
        
        try {
            // å¾è³‡æ–™åº«æŸ¥è©¢å…è¨±çš„åŸŸå
            const tenantService = new (require('../services/TenantService'))();
            const tenant = await tenantService.getTenant(origin);
            
            if (tenant && tenant.status === 'active') {
                callback(null, true);
            } else {
                callback(new Error('åŸŸåæœªæˆæ¬Š'), false);
            }
        } catch (error) {
            callback(error, false);
        }
    }

    requestLogger() {
        return (req, res, next) => {
            const start = Date.now();
            
            res.on('finish', () => {
                const duration = Date.now() - start;
                console.log(`${req.method} ${req.path} - ${res.statusCode} (${duration}ms)`);
            });
            
            next();
        };
    }

    normalizeRoute(path) {
        return path
            ?.replace(/\/[0-9a-f-]{36}/g, '/:id') // UUID åƒæ•¸
            ?.replace(/\/\d+/g, '/:id') // æ•¸å­— ID åƒæ•¸
            || 'unknown';
    }

    start(port = 3000) {
        this.app.listen(port, () => {
            console.log(`API Gateway å·²å•Ÿå‹•æ–¼ port ${port}`);
        });
    }
}

module.exports = APIGateway;
```

### ğŸ”„ å·¥ä½œæµç¨‹ç®¡ç†å¾®æœå‹™

> âš™ï¸ **å¾®æœå‹™æ¶æ§‹**
> 
> æƒ³åƒå‚³çµ±å–®é«”æ‡‰ç”¨ç¨‹å¼æ˜¯ä¸€å€‹å¤§å·¥å» ï¼Œæ‰€æœ‰åŠŸèƒ½éƒ½åœ¨åŒä¸€å€‹å»ºç¯‰ç‰©å…§ã€‚å¾®æœå‹™å‰‡æ˜¯å°‡åŠŸèƒ½åˆ†æ•£åˆ°ä¸åŒçš„å°å·¥å» ï¼š
> - æ¯å€‹å°å·¥å» ï¼ˆæœå‹™ï¼‰å°ˆç²¾ç‰¹å®šåŠŸèƒ½
> - å¯ä»¥ç¨ç«‹é‹ä½œã€æ›´æ–°ã€æ“´å±•
> - é€é API ç›¸äº’æºé€š
> - å…¶ä¸­ä¸€å€‹æ•…éšœä¸æœƒå½±éŸ¿å…¶ä»–æœå‹™

```javascript
// services/workflow-service/index.js - å·¥ä½œæµç¨‹ç®¡ç†æœå‹™
const express = require('express');
const { Pool } = require('pg');
const Redis = require('redis');
const TenantService = require('../TenantService');
const MakeBridgeService = require('../MakeBridgeService');

class WorkflowService {
    constructor() {
        this.app = express();
        this.db = new Pool({ connectionString: process.env.DATABASE_URL });
        this.redis = Redis.createClient({ url: process.env.REDIS_URL });
        this.tenantService = new TenantService();
        this.makeBridgeService = new MakeBridgeService();
        
        this.setupMiddleware();
        this.setupRoutes();
    }

    setupMiddleware() {
        this.app.use(express.json());
        
        // ç§Ÿæˆ¶ä¸Šä¸‹æ–‡ä¸­é–“ä»¶
        this.app.use((req, res, next) => {
            const tenantId = req.headers['x-tenant-id'];
            const userId = req.headers['x-user-id'];
            
            if (!tenantId) {
                return res.status(400).json({ error: 'ç¼ºå°‘ç§Ÿæˆ¶ ID' });
            }
            
            req.tenantId = tenantId;
            req.userId = userId;
            next();
        });
    }

    setupRoutes() {
        // å–å¾—å·¥ä½œæµç¨‹åˆ—è¡¨
        this.app.get('/', async (req, res) => {
            try {
                const { page = 1, limit = 20, status, search } = req.query;
                const offset = (page - 1) * limit;
                
                let query = `
                    SELECT w.*, 
                           u.email as created_by_email,
                           COUNT(*) OVER() as total_count
                    FROM workflows w
                    LEFT JOIN tenant_users u ON u.user_id = w.created_by AND u.tenant_id = w.tenant_id
                    WHERE w.tenant_id = $1
                `;
                
                const params = [req.tenantId];
                let paramIndex = 2;
                
                if (status) {
                    query += ` AND w.status = $${paramIndex}`;
                    params.push(status);
                    paramIndex++;
                }
                
                if (search) {
                    query += ` AND (w.name ILIKE $${paramIndex} OR w.description ILIKE $${paramIndex})`;
                    params.push(`%${search}%`);
                    paramIndex++;
                }
                
                query += ` ORDER BY w.created_at DESC LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;
                params.push(limit, offset);
                
                const result = await this.db.query(query, params);
                
                res.json({
                    workflows: result.rows,
                    pagination: {
                        page: parseInt(page),
                        limit: parseInt(limit),
                        total: result.rows.length > 0 ? parseInt(result.rows[0].total_count) : 0
                    }
                });
                
            } catch (error) {
                console.error('å–å¾—å·¥ä½œæµç¨‹åˆ—è¡¨å¤±æ•—:', error);
                res.status(500).json({ error: 'ç„¡æ³•å–å¾—å·¥ä½œæµç¨‹åˆ—è¡¨' });
            }
        });

        // å»ºç«‹æ–°å·¥ä½œæµç¨‹
        this.app.post('/', async (req, res) => {
            try {
                const { name, description, makeTemplateId, config } = req.body;
                
                // æª¢æŸ¥ç§Ÿæˆ¶é™åˆ¶
                const limitsCheck = await this.tenantService.checkTenantLimits(req.tenantId, 'workflows');
                if (!limitsCheck.allowed) {
                    return res.status(403).json({
                        error: 'å·²é”åˆ°å·¥ä½œæµç¨‹æ•¸é‡é™åˆ¶',
                        limit: limitsCheck.limit,
                        current: limitsCheck.current
                    });
                }
                
                // å»ºç«‹å·¥ä½œæµç¨‹
                const result = await this.db.query(`
                    INSERT INTO workflows (tenant_id, name, description, make_template_id, config, created_by)
                    VALUES ($1, $2, $3, $4, $5, $6)
                    RETURNING *
                `, [req.tenantId, name, description, makeTemplateId, config || {}, req.userId]);
                
                const workflow = result.rows[0];
                
                // å¦‚æœæœ‰ Make æ¨¡æ¿ IDï¼Œå»ºç«‹ Bridge æ•´åˆ
                if (makeTemplateId) {
                    try {
                        const integration = await this.makeBridgeService.createIntegration({
                            tenantId: req.tenantId,
                            templateId: makeTemplateId,
                            workflowId: workflow.id,
                            userId: req.userId
                        });
                        
                        // æ›´æ–°å·¥ä½œæµç¨‹çš„ scenario ID
                        await this.db.query(`
                            UPDATE workflows 
                            SET make_scenario_id = $1, status = 'active'
                            WHERE id = $2
                        `, [integration.scenarioId, workflow.id]);
                        
                        workflow.make_scenario_id = integration.scenarioId;
                        workflow.status = 'active';
                        
                    } catch (bridgeError) {
                        console.error('Make Bridge æ•´åˆå¤±æ•—:', bridgeError);
                        // ä¸é˜»æ­¢å·¥ä½œæµç¨‹å»ºç«‹ï¼Œä½†è¨˜éŒ„éŒ¯èª¤
                    }
                }
                
                res.status(201).json(workflow);
                
            } catch (error) {
                console.error('å»ºç«‹å·¥ä½œæµç¨‹å¤±æ•—:', error);
                res.status(500).json({ error: 'ç„¡æ³•å»ºç«‹å·¥ä½œæµç¨‹' });
            }
        });

        // å–å¾—ç‰¹å®šå·¥ä½œæµç¨‹
        this.app.get('/:id', async (req, res) => {
            try {
                const result = await this.db.query(`
                    SELECT w.*, 
                           u.email as created_by_email,
                           COUNT(we.id) as total_executions,
                           COUNT(CASE WHEN we.status = 'success' THEN 1 END) as success_executions
                    FROM workflows w
                    LEFT JOIN tenant_users u ON u.user_id = w.created_by AND u.tenant_id = w.tenant_id
                    LEFT JOIN workflow_executions we ON we.workflow_id = w.id
                    WHERE w.id = $1 AND w.tenant_id = $2
                    GROUP BY w.id, u.email
                `, [req.params.id, req.tenantId]);
                
                if (result.rows.length === 0) {
                    return res.status(404).json({ error: 'å·¥ä½œæµç¨‹ä¸å­˜åœ¨' });
                }
                
                const workflow = result.rows[0];
                
                // å–å¾—æœ€è¿‘çš„åŸ·è¡Œè¨˜éŒ„
                const executionsResult = await this.db.query(`
                    SELECT * FROM workflow_executions
                    WHERE workflow_id = $1
                    ORDER BY started_at DESC
                    LIMIT 10
                `, [workflow.id]);
                
                workflow.recent_executions = executionsResult.rows;
                
                res.json(workflow);
                
            } catch (error) {
                console.error('å–å¾—å·¥ä½œæµç¨‹å¤±æ•—:', error);
                res.status(500).json({ error: 'ç„¡æ³•å–å¾—å·¥ä½œæµç¨‹' });
            }
        });

        // æ›´æ–°å·¥ä½œæµç¨‹
        this.app.put('/:id', async (req, res) => {
            try {
                const { name, description, config, status } = req.body;
                const allowedUpdates = { name, description, config, status };
                
                // ç§»é™¤ undefined å€¼
                Object.keys(allowedUpdates).forEach(key => {
                    if (allowedUpdates[key] === undefined) {
                        delete allowedUpdates[key];
                    }
                });
                
                if (Object.keys(allowedUpdates).length === 0) {
                    return res.status(400).json({ error: 'æ²’æœ‰å¯æ›´æ–°çš„æ¬„ä½' });
                }
                
                const updateFields = [];
                const values = [];
                let paramIndex = 1;
                
                Object.entries(allowedUpdates).forEach(([field, value]) => {
                    updateFields.push(`${field} = $${paramIndex}`);
                    values.push(value);
                    paramIndex++;
                });
                
                updateFields.push('updated_at = NOW()');
                values.push(req.params.id, req.tenantId);
                
                const result = await this.db.query(`
                    UPDATE workflows 
                    SET ${updateFields.join(', ')}
                    WHERE id = $${paramIndex} AND tenant_id = $${paramIndex + 1}
                    RETURNING *
                `, values);
                
                if (result.rows.length === 0) {
                    return res.status(404).json({ error: 'å·¥ä½œæµç¨‹ä¸å­˜åœ¨' });
                }
                
                res.json(result.rows[0]);
                
            } catch (error) {
                console.error('æ›´æ–°å·¥ä½œæµç¨‹å¤±æ•—:', error);
                res.status(500).json({ error: 'ç„¡æ³•æ›´æ–°å·¥ä½œæµç¨‹' });
            }
        });

        // åˆªé™¤å·¥ä½œæµç¨‹
        this.app.delete('/:id', async (req, res) => {
            const client = await this.db.connect();
            
            try {
                await client.query('BEGIN');
                
                // å–å¾—å·¥ä½œæµç¨‹è³‡è¨Š
                const workflowResult = await client.query(`
                    SELECT * FROM workflows 
                    WHERE id = $1 AND tenant_id = $2
                `, [req.params.id, req.tenantId]);
                
                if (workflowResult.rows.length === 0) {
                    return res.status(404).json({ error: 'å·¥ä½œæµç¨‹ä¸å­˜åœ¨' });
                }
                
                const workflow = workflowResult.rows[0];
                
                // åˆªé™¤ Make Bridge æ•´åˆ
                if (workflow.make_scenario_id) {
                    try {
                        await this.makeBridgeService.deleteIntegration({
                            tenantId: req.tenantId,
                            scenarioId: workflow.make_scenario_id
                        });
                    } catch (bridgeError) {
                        console.error('åˆªé™¤ Make Bridge æ•´åˆå¤±æ•—:', bridgeError);
                        // ç¹¼çºŒåˆªé™¤æœ¬åœ°è¨˜éŒ„
                    }
                }
                
                // åˆªé™¤åŸ·è¡Œè¨˜éŒ„
                await client.query(`
                    DELETE FROM workflow_executions 
                    WHERE workflow_id = $1
                `, [req.params.id]);
                
                // åˆªé™¤å·¥ä½œæµç¨‹
                await client.query(`
                    DELETE FROM workflows 
                    WHERE id = $1 AND tenant_id = $2
                `, [req.params.id, req.tenantId]);
                
                await client.query('COMMIT');
                
                res.json({ message: 'å·¥ä½œæµç¨‹å·²åˆªé™¤' });
                
            } catch (error) {
                await client.query('ROLLBACK');
                console.error('åˆªé™¤å·¥ä½œæµç¨‹å¤±æ•—:', error);
                res.status(500).json({ error: 'ç„¡æ³•åˆªé™¤å·¥ä½œæµç¨‹' });
            } finally {
                client.release();
            }
        });

        // åŸ·è¡Œå·¥ä½œæµç¨‹
        this.app.post('/:id/execute', async (req, res) => {
            try {
                const { triggerData } = req.body;
                
                // æª¢æŸ¥åŸ·è¡Œé™åˆ¶
                const limitsCheck = await this.tenantService.checkTenantLimits(req.tenantId, 'executions');
                if (!limitsCheck.allowed) {
                    return res.status(403).json({
                        error: 'å·²é”åˆ°æœˆåŸ·è¡Œæ¬¡æ•¸é™åˆ¶',
                        limit: limitsCheck.limit,
                        current: limitsCheck.current
                    });
                }
                
                // å»ºç«‹åŸ·è¡Œè¨˜éŒ„
                const executionResult = await this.db.query(`
                    INSERT INTO workflow_executions (tenant_id, workflow_id, trigger_data, status)
                    VALUES ($1, $2, $3, 'running')
                    RETURNING *
                `, [req.tenantId, req.params.id, triggerData || {}]);
                
                const execution = executionResult.rows[0];
                
                // è§¸ç™¼ Make Bridge åŸ·è¡Œ
                try {
                    const result = await this.makeBridgeService.executeWorkflow({
                        tenantId: req.tenantId,
                        workflowId: req.params.id,
                        executionId: execution.id,
                        triggerData: triggerData
                    });
                    
                    // æ›´æ–°åŸ·è¡Œç‹€æ…‹
                    await this.db.query(`
                        UPDATE workflow_executions 
                        SET status = 'success', execution_result = $1, completed_at = NOW(),
                            duration_ms = EXTRACT(EPOCH FROM (NOW() - started_at)) * 1000
                        WHERE id = $2
                    `, [result, execution.id]);
                    
                    execution.status = 'success';
                    execution.execution_result = result;
                    
                } catch (executeError) {
                    // æ›´æ–°åŸ·è¡Œç‹€æ…‹ç‚ºå¤±æ•—
                    await this.db.query(`
                        UPDATE workflow_executions 
                        SET status = 'error', error_message = $1, completed_at = NOW(),
                            duration_ms = EXTRACT(EPOCH FROM (NOW() - started_at)) * 1000
                        WHERE id = $2
                    `, [executeError.message, execution.id]);
                    
                    execution.status = 'error';
                    execution.error_message = executeError.message;
                }
                
                // æ›´æ–°å·¥ä½œæµç¨‹çµ±è¨ˆ
                await this.updateWorkflowStats(req.params.id);
                
                res.json(execution);
                
            } catch (error) {
                console.error('åŸ·è¡Œå·¥ä½œæµç¨‹å¤±æ•—:', error);
                res.status(500).json({ error: 'ç„¡æ³•åŸ·è¡Œå·¥ä½œæµç¨‹' });
            }
        });
    }

    async updateWorkflowStats(workflowId) {
        await this.db.query(`
            UPDATE workflows 
            SET execution_count = (
                SELECT COUNT(*) FROM workflow_executions WHERE workflow_id = $1
            ),
            success_count = (
                SELECT COUNT(*) FROM workflow_executions WHERE workflow_id = $1 AND status = 'success'
            ),
            error_count = (
                SELECT COUNT(*) FROM workflow_executions WHERE workflow_id = $1 AND status = 'error'
            ),
            last_executed_at = (
                SELECT MAX(started_at) FROM workflow_executions WHERE workflow_id = $1
            )
            WHERE id = $1
        `, [workflowId]);
    }

    start(port = 3002) {
        this.app.listen(port, () => {
            console.log(`å·¥ä½œæµç¨‹æœå‹™å·²å•Ÿå‹•æ–¼ port ${port}`);
        });
    }
}

// å•Ÿå‹•æœå‹™
if (require.main === module) {
    const service = new WorkflowService();
    service.start();
}

module.exports = WorkflowService;
```

## 7.4 æ­¥é©Ÿ 3ï¼šé«˜å¯ç”¨æ€§éƒ¨ç½²

### ğŸ³ Docker å®¹å™¨åŒ–

> ğŸ“¦ **å®¹å™¨åŒ–æ¦‚å¿µ**
> 
> **å®¹å™¨ (Container)** å°±åƒæ˜¯æ¨™æº–åŒ–çš„è²¨æ«ƒï¼š
> - å°‡æ‡‰ç”¨ç¨‹å¼å’Œæ‰€æœ‰ä¾è³´é …ç›®æ‰“åŒ…åœ¨ä¸€èµ·
> - å¯ä»¥åœ¨ä»»ä½•æ”¯æ´ Docker çš„ç’°å¢ƒä¸­é‹è¡Œ
> - ç¢ºä¿ã€Œåœ¨æˆ‘é›»è…¦ä¸Šèƒ½è·‘ï¼Œåœ¨ä¼ºæœå™¨ä¸Šä¹Ÿèƒ½è·‘ã€
> - **Docker** æ˜¯æœ€æµè¡Œçš„å®¹å™¨åŒ–å¹³å°ï¼Œå°±åƒæ˜¯è²¨æ«ƒé‹è¼¸çš„æ¨™æº–

```dockerfile
# Dockerfile.gateway - API é–˜é“ Dockerfile
FROM node:18-alpine

# å»ºç«‹æ‡‰ç”¨ç›®éŒ„
WORKDIR /app

# è¤‡è£½ package æª”æ¡ˆ
COPY package*.json ./
COPY gateway/package*.json ./gateway/

# å®‰è£ä¾è³´
RUN npm ci --only=production

# è¤‡è£½æ‡‰ç”¨ç¨‹å¼ç¢¼
COPY gateway/ ./gateway/
COPY shared/ ./shared/

# å»ºç«‹é root ä½¿ç”¨è€…
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001

# è¨­å®šæª”æ¡ˆæ¬Šé™
RUN chown -R nextjs:nodejs /app
USER nextjs

# æš´éœ²ç«¯å£
EXPOSE 3000

# å¥åº·æª¢æŸ¥
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

# å•Ÿå‹•å‘½ä»¤
CMD ["node", "gateway/index.js"]
```

```dockerfile
# Dockerfile.service - å¾®æœå‹™é€šç”¨ Dockerfile
FROM node:18-alpine

ARG SERVICE_NAME
ENV SERVICE_NAME=${SERVICE_NAME}

WORKDIR /app

# è¤‡è£½ä¾è³´æª”æ¡ˆ
COPY package*.json ./
COPY services/${SERVICE_NAME}/package*.json ./services/${SERVICE_NAME}/

# å®‰è£ä¾è³´
RUN npm ci --only=production

# è¤‡è£½æ‡‰ç”¨ç¨‹å¼ç¢¼
COPY services/${SERVICE_NAME}/ ./services/${SERVICE_NAME}/
COPY shared/ ./shared/

# å»ºç«‹ä½¿ç”¨è€…
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodejs -u 1001

# è¨­å®šæ¬Šé™
RUN chown -R nodejs:nodejs /app
USER nodejs

# æš´éœ²ç«¯å£
EXPOSE 3000

# å¥åº·æª¢æŸ¥
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

# å•Ÿå‹•å‘½ä»¤
CMD node services/${SERVICE_NAME}/index.js
```

### â˜¸ï¸ Kubernetes éƒ¨ç½²é…ç½®

> ğŸš¢ **Kubernetes æ¦‚å¿µ**
> 
> **Kubernetes (K8s)** å°±åƒæ˜¯ä¸€å€‹æ™ºèƒ½çš„è²¨æ«ƒç¢¼é ­ç®¡ç†ç³»çµ±ï¼š
> - è‡ªå‹•èª¿åº¦è²¨æ«ƒï¼ˆå®¹å™¨ï¼‰åˆ°æœ€é©åˆçš„ä½ç½®ï¼ˆä¼ºæœå™¨ï¼‰
> - ç›£æ§è²¨æ«ƒç‹€æ…‹ï¼Œæœ‰å•é¡Œå°±è‡ªå‹•é‡å•Ÿæˆ–æ¬ç§»
> - æ ¹æ“šéœ€æ±‚è‡ªå‹•å¢æ¸›è²¨æ«ƒæ•¸é‡ï¼ˆè‡ªå‹•æ“´å±•ï¼‰
> - ç®¡ç†è²¨æ«ƒä¹‹é–“çš„ç¶²è·¯é€£æ¥å’Œè³‡æ–™å„²å­˜

```yaml
# k8s/namespace.yaml - å‘½åç©ºé–“
apiVersion: v1
kind: Namespace
metadata:
  name: saas-automation
  labels:
    name: saas-automation
```

```yaml
# k8s/configmap.yaml - é…ç½®æ˜ å°„
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
  namespace: saas-automation
data:
  NODE_ENV: "production"
  LOG_LEVEL: "info"
  MAKE_ZONE_URL: "https://eu2.make.com"
  REDIS_URL: "redis://redis-service:6379"
  DATABASE_URL: "postgresql://user:pass@postgres-service:5432/saas_automation"
```

```yaml
# k8s/secret.yaml - æ©Ÿå¯†è³‡æ–™
apiVersion: v1
kind: Secret
metadata:
  name: app-secrets
  namespace: saas-automation
type: Opaque
data:
  JWT_SECRET: <base64-encoded-jwt-secret>
  DATABASE_PASSWORD: <base64-encoded-db-password>
  MAKE_BRIDGE_SECRET: <base64-encoded-make-secret>
  MAKE_BRIDGE_KEY_ID: <base64-encoded-key-id>
```

```yaml
# k8s/api-gateway.yaml - API é–˜é“éƒ¨ç½²
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api-gateway
  namespace: saas-automation
  labels:
    app: api-gateway
spec:
  replicas: 3
  selector:
    matchLabels:
      app: api-gateway
  template:
    metadata:
      labels:
        app: api-gateway
    spec:
      containers:
      - name: api-gateway
        image: your-registry/saas-automation/api-gateway:latest
        ports:
        - containerPort: 3000
        env:
        - name: PORT
          value: "3000"
        envFrom:
        - configMapRef:
            name: app-config
        - secretRef:
            name: app-secrets
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: api-gateway-service
  namespace: saas-automation
spec:
  selector:
    app: api-gateway
  ports:
  - protocol: TCP
    port: 80
    targetPort: 3000
  type: ClusterIP
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: api-gateway-ingress
  namespace: saas-automation
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/rate-limit: "100"
    nginx.ingress.kubernetes.io/rate-limit-window: "1m"
spec:
  tls:
  - hosts:
    - api.yourdomain.com
    - "*.yourdomain.com"
    secretName: api-tls
  rules:
  - host: api.yourdomain.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: api-gateway-service
            port:
              number: 80
  - host: "*.yourdomain.com"
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: api-gateway-service
            port:
              number: 80
```

```yaml
# k8s/workflow-service.yaml - å·¥ä½œæµç¨‹æœå‹™éƒ¨ç½²
apiVersion: apps/v1
kind: Deployment
metadata:
  name: workflow-service
  namespace: saas-automation
spec:
  replicas: 2
  selector:
    matchLabels:
      app: workflow-service
  template:
    metadata:
      labels:
        app: workflow-service
    spec:
      containers:
      - name: workflow-service
        image: your-registry/saas-automation/workflow-service:latest
        ports:
        - containerPort: 3000
        envFrom:
        - configMapRef:
            name: app-config
        - secretRef:
            name: app-secrets
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: workflow-service
  namespace: saas-automation
spec:
  selector:
    app: workflow-service
  ports:
  - protocol: TCP
    port: 80
    targetPort: 3000
  type: ClusterIP
---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: workflow-service-hpa
  namespace: saas-automation
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: workflow-service
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
```

### ğŸ“Š ç›£æ§å’Œå‘Šè­¦é…ç½®

> ğŸ“ˆ **ç›£æ§ç³»çµ±æ¦‚å¿µ**
> 
> ç›£æ§ç³»çµ±å°±åƒæ˜¯é†«é™¢çš„ç”Ÿå‘½å¾µè±¡ç›£æ¸¬å™¨ï¼š
> - **Prometheus**ï¼šæ”¶é›†å„ç¨®æŒ‡æ¨™æ•¸æ“šï¼ˆå¿ƒè·³ã€è¡€å£“ç­‰ï¼‰
> - **Grafana**ï¼šå°‡æ•¸æ“šè¦–è¦ºåŒ–æˆåœ–è¡¨ï¼ˆç›£æ¸¬è¢å¹•ï¼‰
> - **å‘Šè­¦è¦å‰‡**ï¼šç•¶æŒ‡æ¨™ç•°å¸¸æ™‚è‡ªå‹•é€šçŸ¥ï¼ˆè­¦å ±å™¨ï¼‰
> - **ServiceMonitor**ï¼šå®šç¾©è¦ç›£æ§å“ªäº›æœå‹™ï¼ˆç›£æ¸¬é»ï¼‰

```yaml
# k8s/monitoring.yaml - Prometheus ç›£æ§é…ç½®
apiVersion: v1
kind: ServiceMonitor
metadata:
  name: app-metrics
  namespace: saas-automation
spec:
  selector:
    matchLabels:
      monitoring: enabled
  endpoints:
  - port: metrics
    interval: 30s
    path: /metrics
---
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: app-alerts
  namespace: saas-automation
spec:
  groups:
  - name: app.rules
    rules:
    - alert: HighErrorRate
      expr: rate(http_requests_total{status_code=~"5.."}[5m]) > 0.1
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "High error rate detected"
        description: "Error rate is {{ $value }} per second"
    
    - alert: HighResponseTime
      expr: histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m])) > 2
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "High response time detected"
        description: "95th percentile response time is {{ $value }} seconds"
    
    - alert: PodCrashLooping
      expr: rate(kube_pod_container_status_restarts_total[15m]) > 0
      for: 5m
      labels:
        severity: critical
      annotations:
        summary: "Pod is crash looping"
        description: "Pod {{ $labels.pod }} is restarting frequently"
```

## 7.5 æ­¥é©Ÿ 4ï¼šä¼æ¥­ç´šå‰ç«¯æ‡‰ç”¨

### âš›ï¸ React ä¼æ¥­å„€è¡¨æ¿

> ğŸ–¥ï¸ **ç¾ä»£å‰ç«¯é–‹ç™¼**
> 
> - **React**ï¼šç”± Facebook é–‹ç™¼çš„å‰ç«¯æ¡†æ¶ï¼Œè®“å»ºç«‹äº’å‹•å¼ä½¿ç”¨è€…ä»‹é¢è®Šå¾—æ›´ç°¡å–®
> - **çµ„ä»¶åŒ– (Component-based)**ï¼šå°‡ UI æ‹†åˆ†æˆå¯é‡è¤‡ä½¿ç”¨çš„å°å…ƒä»¶
> - **ç‹€æ…‹ç®¡ç†**ï¼šè¿½è¹¤å’Œç®¡ç†æ‡‰ç”¨ç¨‹å¼ä¸­çš„è³‡æ–™è®ŠåŒ–
> - **Material-UI**ï¼šæä¾›ç¾è§€ä¸”ä¸€è‡´çš„ UI å…ƒä»¶åº«

```jsx
// frontend/src/App.jsx - ä¸»æ‡‰ç”¨çµ„ä»¶
import React, { useState, useEffect } from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { Provider } from 'react-redux';
import { ThemeProvider } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';

import { store } from './store';
import { theme } from './theme';
import { AuthProvider } from './contexts/AuthContext';
import { TenantProvider } from './contexts/TenantContext';

// Layout çµ„ä»¶
import Layout from './components/Layout/Layout';
import ProtectedRoute from './components/Auth/ProtectedRoute';

// é é¢çµ„ä»¶
import LoginPage from './pages/Auth/LoginPage';
import DashboardPage from './pages/Dashboard/DashboardPage';
import WorkflowsPage from './pages/Workflows/WorkflowsPage';
import WorkflowDetailPage from './pages/Workflows/WorkflowDetailPage';
import AnalyticsPage from './pages/Analytics/AnalyticsPage';
import SettingsPage from './pages/Settings/SettingsPage';
import TeamPage from './pages/Team/TeamPage';

function App() {
  return (
    <Provider store={store}>
      <ThemeProvider theme={theme}>
        <CssBaseline />
        <AuthProvider>
          <TenantProvider>
            <Router>
              <Routes>
                {/* å…¬é–‹è·¯ç”± */}
                <Route path="/login" element={<LoginPage />} />
                
                {/* å—ä¿è­·çš„è·¯ç”± */}
                <Route path="/" element={
                  <ProtectedRoute>
                    <Layout />
                  </ProtectedRoute>
                }>
                  <Route index element={<Navigate to="/dashboard" replace />} />
                  <Route path="dashboard" element={<DashboardPage />} />
                  <Route path="workflows" element={<WorkflowsPage />} />
                  <Route path="workflows/:id" element={<WorkflowDetailPage />} />
                  <Route path="analytics" element={<AnalyticsPage />} />
                  <Route path="team" element={<TeamPage />} />
                  <Route path="settings" element={<SettingsPage />} />
                </Route>
                
                {/* 404 è™•ç† */}
                <Route path="*" element={<Navigate to="/dashboard" replace />} />
              </Routes>
            </Router>
          </TenantProvider>
        </AuthProvider>
      </ThemeProvider>
    </Provider>
  );
}

export default App;
```

```jsx
// frontend/src/pages/Workflows/WorkflowsPage.jsx - å·¥ä½œæµç¨‹ç®¡ç†é é¢
import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  Button,
  Paper,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  TablePagination,
  Chip,
  IconButton,
  Dialog,
  DialogTitle,
  DialogContent,
  Tooltip,
  Alert,
  Snackbar
} from '@mui/material';
import {
  Add as AddIcon,
  Edit as EditIcon,
  Delete as DeleteIcon,
  PlayArrow as PlayIcon,
  Settings as SettingsIcon
} from '@mui/icons-material';

import { useWorkflows } from '../../hooks/useWorkflows';
import { useTenant } from '../../contexts/TenantContext';
import WorkflowCreateDialog from '../../components/Workflows/WorkflowCreateDialog';
import MakeBridgeSetupDialog from '../../components/MakeBridge/MakeBridgeSetupDialog';
import LoadingSpinner from '../../components/UI/LoadingSpinner';

const statusColors = {
  active: 'success',
  draft: 'warning',
  inactive: 'default',
  error: 'error'
};

const statusLabels = {
  active: 'æ´»èº',
  draft: 'è‰ç¨¿',
  inactive: 'åœç”¨',
  error: 'éŒ¯èª¤'
};

export default function WorkflowsPage() {
  const { tenant } = useTenant();
  const {
    workflows,
    loading,
    error,
    pagination,
    createWorkflow,
    updateWorkflow,
    deleteWorkflow,
    executeWorkflow,
    fetchWorkflows
  } = useWorkflows();

  const [page, setPage] = useState(0);
  const [rowsPerPage, setRowsPerPage] = useState(10);
  const [createDialogOpen, setCreateDialogOpen] = useState(false);
  const [setupDialogOpen, setSetupDialogOpen] = useState(false);
  const [selectedWorkflow, setSelectedWorkflow] = useState(null);
  const [snackbar, setSnackbar] = useState({ open: false, message: '', severity: 'info' });

  useEffect(() => {
    fetchWorkflows({ page: page + 1, limit: rowsPerPage });
  }, [page, rowsPerPage, fetchWorkflows]);

  const handleChangePage = (event, newPage) => {
    setPage(newPage);
  };

  const handleChangeRowsPerPage = (event) => {
    setRowsPerPage(parseInt(event.target.value, 10));
    setPage(0);
  };

  const handleCreateWorkflow = async (workflowData) => {
    try {
      await createWorkflow(workflowData);
      setCreateDialogOpen(false);
      setSnackbar({
        open: true,
        message: 'å·¥ä½œæµç¨‹å»ºç«‹æˆåŠŸ',
        severity: 'success'
      });
    } catch (error) {
      setSnackbar({
        open: true,
        message: `å»ºç«‹å¤±æ•—: ${error.message}`,
        severity: 'error'
      });
    }
  };

  const handleExecuteWorkflow = async (workflowId) => {
    try {
      await executeWorkflow(workflowId, {});
      setSnackbar({
        open: true,
        message: 'å·¥ä½œæµç¨‹åŸ·è¡ŒæˆåŠŸ',
        severity: 'success'
      });
    } catch (error) {
      setSnackbar({
        open: true,
        message: `åŸ·è¡Œå¤±æ•—: ${error.message}`,
        severity: 'error'
      });
    }
  };

  const handleDeleteWorkflow = async (workflowId) => {
    if (window.confirm('ç¢ºå®šè¦åˆªé™¤æ­¤å·¥ä½œæµç¨‹å—ï¼Ÿ')) {
      try {
        await deleteWorkflow(workflowId);
        setSnackbar({
          open: true,
          message: 'å·¥ä½œæµç¨‹å·²åˆªé™¤',
          severity: 'success'
        });
      } catch (error) {
        setSnackbar({
          open: true,
          message: `åˆªé™¤å¤±æ•—: ${error.message}`,
          severity: 'error'
        });
      }
    }
  };

  if (loading && workflows.length === 0) {
    return <LoadingSpinner />;
  }

  return (
    <Box>
      {/* é é¢æ¨™é¡Œå’Œå‹•ä½œ */}
      <Box display="flex" justifyContent="space-between" alignItems="center" mb={3}>
        <Typography variant="h4" component="h1">
          å·¥ä½œæµç¨‹ç®¡ç†
        </Typography>
        <Box>
          <Button
            variant="outlined"
            startIcon={<SettingsIcon />}
            onClick={() => setSetupDialogOpen(true)}
            sx={{ mr: 2 }}
          >
            Make Bridge è¨­å®š
          </Button>
          <Button
            variant="contained"
            startIcon={<AddIcon />}
            onClick={() => setCreateDialogOpen(true)}
          >
            å»ºç«‹å·¥ä½œæµç¨‹
          </Button>
        </Box>
      </Box>

      {/* éŒ¯èª¤é¡¯ç¤º */}
      {error && (
        <Alert severity="error" sx={{ mb: 2 }}>
          {error}
        </Alert>
      )}

      {/* å·¥ä½œæµç¨‹è¡¨æ ¼ */}
      <Paper>
        <TableContainer>
          <Table>
            <TableHead>
              <TableRow>
                <TableCell>åç¨±</TableCell>
                <TableCell>ç‹€æ…‹</TableCell>
                <TableCell>åŸ·è¡Œæ¬¡æ•¸</TableCell>
                <TableCell>æˆåŠŸç‡</TableCell>
                <TableCell>æœ€å¾ŒåŸ·è¡Œ</TableCell>
                <TableCell>å»ºç«‹æ™‚é–“</TableCell>
                <TableCell align="right">æ“ä½œ</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {workflows.map((workflow) => (
                <TableRow key={workflow.id} hover>
                  <TableCell>
                    <Box>
                      <Typography variant="subtitle2">
                        {workflow.name}
                      </Typography>
                      {workflow.description && (
                        <Typography variant="body2" color="text.secondary">
                          {workflow.description}
                        </Typography>
                      )}
                    </Box>
                  </TableCell>
                  <TableCell>
                    <Chip
                      label={statusLabels[workflow.status]}
                      color={statusColors[workflow.status]}
                      size="small"
                    />
                  </TableCell>
                  <TableCell>
                    {workflow.execution_count || 0}
                  </TableCell>
                  <TableCell>
                    {workflow.execution_count > 0
                      ? `${Math.round((workflow.success_count / workflow.execution_count) * 100)}%`
                      : '-'
                    }
                  </TableCell>
                  <TableCell>
                    {workflow.last_executed_at
                      ? new Date(workflow.last_executed_at).toLocaleString('zh-TW')
                      : 'å¾æœªåŸ·è¡Œ'
                    }
                  </TableCell>
                  <TableCell>
                    {new Date(workflow.created_at).toLocaleDateString('zh-TW')}
                  </TableCell>
                  <TableCell align="right">
                    <Tooltip title="åŸ·è¡Œ">
                      <IconButton
                        size="small"
                        onClick={() => handleExecuteWorkflow(workflow.id)}
                        disabled={workflow.status !== 'active'}
                      >
                        <PlayIcon />
                      </IconButton>
                    </Tooltip>
                    <Tooltip title="ç·¨è¼¯">
                      <IconButton
                        size="small"
                        onClick={() => setSelectedWorkflow(workflow)}
                      >
                        <EditIcon />
                      </IconButton>
                    </Tooltip>
                    <Tooltip title="åˆªé™¤">
                      <IconButton
                        size="small"
                        onClick={() => handleDeleteWorkflow(workflow.id)}
                        color="error"
                      >
                        <DeleteIcon />
                      </IconButton>
                    </Tooltip>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </TableContainer>
        
        {/* åˆ†é  */}
        <TablePagination
          rowsPerPageOptions={[5, 10, 25]}
          component="div"
          count={pagination.total}
          rowsPerPage={rowsPerPage}
          page={page}
          onPageChange={handleChangePage}
          onRowsPerPageChange={handleChangeRowsPerPage}
          labelRowsPerPage="æ¯é ç­†æ•¸:"
          labelDisplayedRows={({ from, to, count }) =>
            `${from}-${to} / å…± ${count} ç­†`
          }
        />
      </Paper>

      {/* å»ºç«‹å·¥ä½œæµç¨‹å°è©±æ¡† */}
      <WorkflowCreateDialog
        open={createDialogOpen}
        onClose={() => setCreateDialogOpen(false)}
        onSubmit={handleCreateWorkflow}
      />

      {/* Make Bridge è¨­å®šå°è©±æ¡† */}
      <MakeBridgeSetupDialog
        open={setupDialogOpen}
        onClose={() => setSetupDialogOpen(false)}
        tenant={tenant}
      />

      {/* é€šçŸ¥ Snackbar */}
      <Snackbar
        open={snackbar.open}
        autoHideDuration={6000}
        onClose={() => setSnackbar({ ...snackbar, open: false })}
      >
        <Alert
          onClose={() => setSnackbar({ ...snackbar, open: false })}
          severity={snackbar.severity}
          sx={{ width: '100%' }}
        >
          {snackbar.message}
        </Alert>
      </Snackbar>
    </Box>
  );
}
```

### ğŸ¨ å“ç‰Œå®¢è£½åŒ–ç³»çµ±

> ğŸ¨ **ç™½æ¨™ç±¤æŠ€è¡“**
> 
> å“ç‰Œå®¢è£½åŒ–è®“æ‚¨çš„å®¢æˆ¶èƒ½å¤ ï¼š
> - ä¸Šå‚³è‡ªå·±çš„ Logo å’Œè¨­å®šå“ç‰Œé¡è‰²
> - è‡ªè¨‚ CSS æ¨£å¼ä¾†èª¿æ•´ä»‹é¢å¤–è§€
> - å®¢è£½åŒ–éƒµä»¶ç¯„æœ¬
> - è®“çµ‚ç«¯ä½¿ç”¨è€…æ„Ÿè¦ºé€™æ˜¯ä»–å€‘è‡ªå·±çš„ç”¢å“

```jsx
// frontend/src/components/Branding/BrandingCustomizer.jsx - å“ç‰Œå®¢è£½åŒ–
import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  Paper,
  Grid,
  TextField,
  Button,
  ColorPicker,
  Upload,
  Preview,
  Tabs,
  Tab,
  FormControl,
  FormLabel,
  Switch,
  Alert
} from '@mui/material';

import { useTenant } from '../../contexts/TenantContext';
import { brandingAPI } from '../../services/api';

export default function BrandingCustomizer() {
  const { tenant, updateTenant } = useTenant();
  const [activeTab, setActiveTab] = useState(0);
  const [branding, setBranding] = useState({
    logo: '',
    favicon: '',
    primaryColor: '#1976d2',
    secondaryColor: '#dc004e',
    companyName: '',
    customCSS: '',
    emailTemplates: {
      header: '',
      footer: '',
      colors: {}
    }
  });
  const [preview, setPreview] = useState(false);
  const [saving, setSaving] = useState(false);

  useEffect(() => {
    if (tenant?.branding) {
      setBranding({ ...branding, ...tenant.branding });
    }
  }, [tenant]);

  const handleSave = async () => {
    setSaving(true);
    try {
      await updateTenant({ branding });
      // é¡¯ç¤ºæˆåŠŸè¨Šæ¯
    } catch (error) {
      // é¡¯ç¤ºéŒ¯èª¤è¨Šæ¯
    } finally {
      setSaving(false);
    }
  };

  const handleLogoUpload = async (file) => {
    const formData = new FormData();
    formData.append('logo', file);
    
    try {
      const result = await brandingAPI.uploadLogo(formData);
      setBranding({ ...branding, logo: result.url });
    } catch (error) {
      console.error('Logo ä¸Šå‚³å¤±æ•—:', error);
    }
  };

  const generatePreviewCSS = () => {
    return `
      :root {
        --primary-color: ${branding.primaryColor};
        --secondary-color: ${branding.secondaryColor};
        --logo-url: url('${branding.logo}');
      }
      
      .custom-branding .logo {
        background-image: var(--logo-url);
        background-size: contain;
        background-repeat: no-repeat;
      }
      
      .custom-branding .btn-primary {
        background-color: var(--primary-color);
        border-color: var(--primary-color);
      }
      
      .custom-branding .btn-secondary {
        background-color: var(--secondary-color);
        border-color: var(--secondary-color);
      }
      
      ${branding.customCSS}
    `;
  };

  return (
    <Box>
      <Typography variant="h5" gutterBottom>
        å“ç‰Œå®¢è£½åŒ–
      </Typography>
      
      <Paper sx={{ p: 3 }}>
        <Tabs value={activeTab} onChange={(e, v) => setActiveTab(v)}>
          <Tab label="åŸºæœ¬è¨­å®š" />
          <Tab label="é¡è‰²ä¸»é¡Œ" />
          <Tab label="è‡ªå®šç¾© CSS" />
          <Tab label="éƒµä»¶ç¯„æœ¬" />
        </Tabs>
        
        {/* åŸºæœ¬è¨­å®šé ç±¤ */}
        {activeTab === 0 && (
          <Box sx={{ mt: 3 }}>
            <Grid container spacing={3}>
              <Grid item xs={12} md={6}>
                <TextField
                  fullWidth
                  label="å…¬å¸åç¨±"
                  value={branding.companyName}
                  onChange={(e) => setBranding({
                    ...branding,
                    companyName: e.target.value
                  })}
                />
              </Grid>
              
              <Grid item xs={12} md={6}>
                <FormControl fullWidth>
                  <FormLabel>Logo ä¸Šå‚³</FormLabel>
                  <Upload
                    accept="image/*"
                    onUpload={handleLogoUpload}
                    preview={branding.logo}
                  />
                </FormControl>
              </Grid>
              
              <Grid item xs={12}>
                <Preview
                  css={generatePreviewCSS()}
                  branding={branding}
                />
              </Grid>
            </Grid>
          </Box>
        )}
        
        {/* é¡è‰²ä¸»é¡Œé ç±¤ */}
        {activeTab === 1 && (
          <Box sx={{ mt: 3 }}>
            <Grid container spacing={3}>
              <Grid item xs={12} md={6}>
                <FormControl fullWidth>
                  <FormLabel>ä¸»è¦é¡è‰²</FormLabel>
                  <ColorPicker
                    value={branding.primaryColor}
                    onChange={(color) => setBranding({
                      ...branding,
                      primaryColor: color
                    })}
                  />
                </FormControl>
              </Grid>
              
              <Grid item xs={12} md={6}>
                <FormControl fullWidth>
                  <FormLabel>æ¬¡è¦é¡è‰²</FormLabel>
                  <ColorPicker
                    value={branding.secondaryColor}
                    onChange={(color) => setBranding({
                      ...branding,
                      secondaryColor: color
                    })}
                  />
                </FormControl>
              </Grid>
            </Grid>
          </Box>
        )}
        
        {/* è‡ªå®šç¾© CSS é ç±¤ */}
        {activeTab === 2 && (
          <Box sx={{ mt: 3 }}>
            <Alert severity="info" sx={{ mb: 2 }}>
              æ‚¨å¯ä»¥æ·»åŠ è‡ªå®šç¾© CSS ä¾†é€²ä¸€æ­¥å®¢è£½åŒ–ä»‹é¢å¤–è§€ã€‚
            </Alert>
            
            <TextField
              fullWidth
              multiline
              rows={10}
              label="è‡ªå®šç¾© CSS"
              value={branding.customCSS}
              onChange={(e) => setBranding({
                ...branding,
                customCSS: e.target.value
              })}
              placeholder="/* åœ¨é€™è£¡æ·»åŠ æ‚¨çš„è‡ªå®šç¾© CSS */"
            />
          </Box>
        )}
        
        {/* éƒµä»¶ç¯„æœ¬é ç±¤ */}
        {activeTab === 3 && (
          <Box sx={{ mt: 3 }}>
            <Grid container spacing={3}>
              <Grid item xs={12}>
                <TextField
                  fullWidth
                  multiline
                  rows={4}
                  label="éƒµä»¶æ¨™é ­"
                  value={branding.emailTemplates.header}
                  onChange={(e) => setBranding({
                    ...branding,
                    emailTemplates: {
                      ...branding.emailTemplates,
                      header: e.target.value
                    }
                  })}
                />
              </Grid>
              
              <Grid item xs={12}>
                <TextField
                  fullWidth
                  multiline
                  rows={4}
                  label="éƒµä»¶é å°¾"
                  value={branding.emailTemplates.footer}
                  onChange={(e) => setBranding({
                    ...branding,
                    emailTemplates: {
                      ...branding.emailTemplates,
                      footer: e.target.value
                    }
                  })}
                />
              </Grid>
            </Grid>
          </Box>
        )}
        
        {/* å‹•ä½œæŒ‰éˆ• */}
        <Box sx={{ mt: 4, display: 'flex', gap: 2 }}>
          <Button
            variant="outlined"
            onClick={() => setPreview(!preview)}
          >
            {preview ? 'é—œé–‰é è¦½' : 'é è¦½è®Šæ›´'}
          </Button>
          
          <Button
            variant="contained"
            onClick={handleSave}
            disabled={saving}
          >
            {saving ? 'å„²å­˜ä¸­...' : 'å„²å­˜è®Šæ›´'}
          </Button>
        </Box>
      </Paper>
    </Box>
  );
}
```

## 7.6 æœ¬ç« ç¸½çµ

å®Œæˆæœ¬ç« å¾Œï¼Œæ‚¨å·²ç¶“å»ºç«‹äº†ä¸€å€‹å®Œæ•´çš„ä¼æ¥­ç´šå¤šç§Ÿæˆ¶ SaaS è‡ªå‹•åŒ–å¹³å°ï¼ŒåŒ…æ‹¬ï¼š

âœ… **å¤šç§Ÿæˆ¶æ¶æ§‹è¨­è¨ˆèˆ‡å¯¦ä½œ**  
âœ… **å¾®æœå‹™åŒ–çš„ç³»çµ±æ¶æ§‹**  
âœ… **ä¼æ¥­ç´šèªè­‰èˆ‡æˆæ¬Šç³»çµ±**  
âœ… **é«˜å¯ç”¨æ€§å®¹å™¨åŒ–éƒ¨ç½²**  
âœ… **å®Œæ•´çš„ç›£æ§å’Œå‘Šè­¦æ©Ÿåˆ¶**  
âœ… **ä¼æ¥­ç´šå‰ç«¯ç®¡ç†ä»‹é¢**  
âœ… **å“ç‰Œå®¢è£½åŒ–ç³»çµ±**  

### ğŸ“ˆ ä¼æ¥­ç´šæŠ€èƒ½æŒæ¡

é€šéæœ¬é …ç›®ï¼Œæ‚¨å·²å…·å‚™ï¼š
- è¨­è¨ˆå’Œå¯¦ä½œå¤šç§Ÿæˆ¶ SaaS æ¶æ§‹çš„èƒ½åŠ›
- å¾®æœå‹™ç³»çµ±è¨­è¨ˆå’Œå®¹å™¨åŒ–éƒ¨ç½²æŠ€èƒ½
- ä¼æ¥­ç´šå®‰å…¨æ§åˆ¶å’Œæ¬Šé™ç®¡ç†ç¶“é©—
- é«˜å¯ç”¨æ€§å’Œå¯æ“´å±•æ€§ç³»çµ±è¨­è¨ˆèƒ½åŠ›
- å®Œæ•´çš„ DevOps å’Œç›£æ§é«”ç³»å»ºç½®ç¶“é©—

> ğŸ¯ **å­¸ç¿’æˆå°±è§£é–**
> 
> æ­å–œï¼æ‚¨ç¾åœ¨å·²ç¶“æŒæ¡äº†ä¼æ¥­ç´šè»Ÿé«”é–‹ç™¼çš„æ ¸å¿ƒæŠ€èƒ½ï¼š
> - **æ¶æ§‹è¨­è¨ˆå¸«**ï¼šèƒ½å¤ è¨­è¨ˆå¯æ“´å±•çš„ç³»çµ±æ¶æ§‹
> - **DevOps å·¥ç¨‹å¸«**ï¼šç†Ÿæ‚‰å®¹å™¨åŒ–å’Œè‡ªå‹•åŒ–éƒ¨ç½²
> - **å…¨ç«¯é–‹ç™¼è€…**ï¼šå…·å‚™å‰å¾Œç«¯æ•´åˆé–‹ç™¼èƒ½åŠ›
> - **å®‰å…¨å°ˆå®¶**ï¼šç†è§£ä¼æ¥­ç´šå®‰å…¨æ§åˆ¶æªæ–½
> 
> é€™äº›æŠ€èƒ½ä¸åƒ…é©ç”¨æ–¼ Make Bridgeï¼Œä¹Ÿæ˜¯ç¾ä»£è»Ÿé«”é–‹ç™¼çš„é€šç”¨æŠ€èƒ½ï¼

### ğŸš€ ä¸‹ä¸€æ­¥

é«˜ç´šå°ˆæ¡ˆå®Œæˆå¾Œï¼Œæ‚¨å·²ç¶“æŒæ¡äº† Make Bridge çš„æ‰€æœ‰æ ¸å¿ƒæŠ€è¡“å’Œä¼æ¥­ç´šæ‡‰ç”¨å ´æ™¯ã€‚ä¸‹ä¸€ç« å°‡ç‚ºæ‚¨æä¾›å¸¸è¦‹æ‡‰ç”¨å ´æ™¯çš„å¯¦ä½œç¯„ä¾‹å’Œæœ€ä½³å¯¦è¸æŒ‡å—ã€‚