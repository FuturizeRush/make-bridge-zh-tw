# 第7章：完整專案實作 - 高級

本章將帶您開發一個企業級的「多租戶 SaaS 自動化平台」，這是一個複雜的高級專案，涵蓋多租戶架構、微服務設計、高可用性部署以及企業級安全性要求。

> 📚 **低代碼友善提示**
> 
> 本章包含許多企業級技術概念。為了幫助您更好理解，我們會在相關技術出現時提供簡明解釋。不用擔心，我們會循序漸進地引導您掌握這些概念！

## 7.1 專案概述

### 🎯 專案目標

建立一個企業級的多租戶 SaaS 平台，讓不同的企業客戶能夠：
1. 建立和管理自己的自動化工作流程
2. 設定複雜的業務規則和條件邏輯
3. 整合自己的企業系統（ERP、CRM、等）
4. 監控和分析自動化執行效果
5. 管理團隊成員和權限設定
6. 自訂品牌和介面外觀

### 📋 企業級需求

**高級專案特色：**
- 多租戶資料隔離
- 微服務架構設計
- 高可用性和容錯性
- 企業級安全控制
- 水平擴展能力
- 即時監控和告警
- API 速率限制和配額管理
- 白標籤客製化

> 💡 **術語解釋盒子**
> 
> - **多租戶 (Multi-tenant)**：一個應用程式同時服務多個客戶（租戶），每個租戶的資料完全隔離
> - **微服務 (Microservices)**：將大型應用程式拆分成多個小的、獨立的服務，各自負責特定功能
> - **高可用性 (High Availability)**：系統能夠持續運行，即使部分組件故障也不會影響整體服務
> - **容錯性 (Fault Tolerance)**：系統在遇到錯誤時能夠自動恢復，不會完全停機
> - **水平擴展 (Horizontal Scaling)**：透過增加更多伺服器來提升系統性能（vs 垂直擴展：升級單一伺服器硬體）
> - **白標籤 (White Label)**：可以客製化品牌外觀的解決方案，讓您的客戶以為是您開發的產品

### 🏗️ 系統架構

```
多租戶 SaaS 自動化平台
├── 前端層 (Frontend Tier)
│   ├── 管理者儀表板
│   ├── 租戶管理介面
│   ├── 終端使用者介面
│   └── 品牌客製化層
├── API 閘道層 (API Gateway)
│   ├── 認證與授權
│   ├── 速率限制
│   ├── 請求路由
│   └── 監控收集
├── 應用服務層 (Application Services)
│   ├── 租戶管理服務
│   ├── 工作流程管理服務
│   ├── Make Bridge 整合服務
│   ├── 通知服務
│   └── 分析服務
├── 資料層 (Data Tier)
│   ├── 主要資料庫 (PostgreSQL)
│   ├── 快取層 (Redis)
│   ├── 檔案儲存 (S3)
│   └── 時間序列資料庫 (InfluxDB)
└── 基礎設施層 (Infrastructure)
    ├── 容器編排 (Kubernetes)
    ├── 服務網格 (Istio)
    ├── 監控系統 (Prometheus + Grafana)
    └── 日誌聚合 (ELK Stack)
```

## 7.2 步驟 1：多租戶架構設計

### 🏢 租戶管理系統

> 🔍 **概念解釋**
> 
> **租戶 (Tenant)** 就像是一棟大樓中的不同公司。每家公司（租戶）都有自己的辦公室（資料空間），彼此不會互相干擾。在 SaaS 系統中，每個企業客戶就是一個租戶。

#### 資料模型設計

> 💾 **資料庫概念**
> 
> 資料模型就像是設計房屋的藍圖，定義了：
> - 需要哪些資料表（房間）
> - 每個表存放什麼資料（房間用途）
> - 表之間如何關聯（房間之間的連接）

```sql
-- tenants.sql - 租戶資料表結構

-- 租戶主表
CREATE TABLE tenants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    slug VARCHAR(100) UNIQUE NOT NULL,
    domain VARCHAR(255),
    plan_type VARCHAR(50) NOT NULL DEFAULT 'basic',
    status VARCHAR(20) NOT NULL DEFAULT 'active',
    
    -- 配置設定
    config JSONB DEFAULT '{}',
    branding JSONB DEFAULT '{}',
    
    -- Make Bridge 設定
    make_bridge_config JSONB DEFAULT '{}',
    
    -- 限制和配額
    limits JSONB DEFAULT '{
        "max_workflows": 10,
        "max_executions_per_month": 1000,
        "max_team_members": 5
    }',
    
    -- 時間戳記
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- 建立索引
    INDEX idx_tenants_slug (slug),
    INDEX idx_tenants_status (status),
    INDEX idx_tenants_plan_type (plan_type)
);

-- 租戶使用者表
CREATE TABLE tenant_users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    user_id UUID NOT NULL,
    email VARCHAR(255) NOT NULL,
    role VARCHAR(50) NOT NULL DEFAULT 'member',
    
    -- 權限設定
    permissions JSONB DEFAULT '[]',
    
    -- 狀態
    status VARCHAR(20) NOT NULL DEFAULT 'active',
    invited_at TIMESTAMP WITH TIME ZONE,
    joined_at TIMESTAMP WITH TIME ZONE,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    UNIQUE(tenant_id, email),
    INDEX idx_tenant_users_tenant (tenant_id),
    INDEX idx_tenant_users_email (email),
    INDEX idx_tenant_users_role (role)
);

-- 工作流程表
CREATE TABLE workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    
    -- Make Bridge 相關
    make_template_id VARCHAR(255),
    make_scenario_id VARCHAR(255),
    
    -- 配置和狀態
    config JSONB DEFAULT '{}',
    status VARCHAR(20) NOT NULL DEFAULT 'draft',
    
    -- 統計資料
    execution_count INTEGER DEFAULT 0,
    success_count INTEGER DEFAULT 0,
    error_count INTEGER DEFAULT 0,
    last_executed_at TIMESTAMP WITH TIME ZONE,
    
    -- 建立者資訊
    created_by UUID NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    INDEX idx_workflows_tenant (tenant_id),
    INDEX idx_workflows_status (status),
    INDEX idx_workflows_template (make_template_id)
);

-- 工作流程執行記錄
CREATE TABLE workflow_executions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    workflow_id UUID NOT NULL REFERENCES workflows(id) ON DELETE CASCADE,
    
    -- 執行資訊
    trigger_data JSONB,
    execution_result JSONB,
    status VARCHAR(20) NOT NULL,
    
    -- 時間追蹤
    started_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    completed_at TIMESTAMP WITH TIME ZONE,
    duration_ms INTEGER,
    
    -- 錯誤資訊
    error_message TEXT,
    error_details JSONB,
    
    INDEX idx_executions_tenant (tenant_id),
    INDEX idx_executions_workflow (workflow_id),
    INDEX idx_executions_status (status),
    INDEX idx_executions_started (started_at)
);
```

#### 租戶管理服務

```javascript
// services/TenantService.js - 租戶管理服務
const { Pool } = require('pg');
const Redis = require('redis');
const crypto = require('crypto');

class TenantService {
    constructor() {
        this.db = new Pool({
            connectionString: process.env.DATABASE_URL,
            max: 20,
            idleTimeoutMillis: 30000,
            connectionTimeoutMillis: 2000,
        });
        
        this.redis = Redis.createClient({
            url: process.env.REDIS_URL
        });
        
        this.redis.connect();
    }

    /**
     * 建立新租戶
     */
    async createTenant(tenantData) {
        const client = await this.db.connect();
        
        try {
            await client.query('BEGIN');
            
            // 生成唯一的 slug
            const slug = await this.generateUniqueSlug(tenantData.name);
            
            // 建立租戶
            const tenantResult = await client.query(`
                INSERT INTO tenants (name, slug, domain, plan_type, config, branding, limits)
                VALUES ($1, $2, $3, $4, $5, $6, $7)
                RETURNING *
            `, [
                tenantData.name,
                slug,
                tenantData.domain,
                tenantData.planType || 'basic',
                tenantData.config || {},
                tenantData.branding || {},
                this.getDefaultLimits(tenantData.planType)
            ]);
            
            const tenant = tenantResult.rows[0];
            
            // 建立管理員使用者
            if (tenantData.adminUser) {
                await client.query(`
                    INSERT INTO tenant_users (tenant_id, user_id, email, role, status, joined_at)
                    VALUES ($1, $2, $3, 'admin', 'active', NOW())
                `, [
                    tenant.id,
                    tenantData.adminUser.id,
                    tenantData.adminUser.email
                ]);
            }
            
            await client.query('COMMIT');
            
            // 初始化租戶設定
            await this.initializeTenantSettings(tenant.id);
            
            return tenant;
            
        } catch (error) {
            await client.query('ROLLBACK');
            throw error;
        } finally {
            client.release();
        }
    }

    /**
     * 取得租戶資訊
     */
    async getTenant(identifier) {
        // 嘗試從快取取得
        const cacheKey = `tenant:${identifier}`;
        const cached = await this.redis.get(cacheKey);
        
        if (cached) {
            return JSON.parse(cached);
        }
        
        // 從資料庫查詢
        const isUuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(identifier);
        const query = isUuid 
            ? 'SELECT * FROM tenants WHERE id = $1'
            : 'SELECT * FROM tenants WHERE slug = $1 OR domain = $1';
        
        const result = await this.db.query(query, [identifier]);
        
        if (result.rows.length === 0) {
            throw new Error('租戶不存在');
        }
        
        const tenant = result.rows[0];
        
        // 快取結果
        await this.redis.setEx(cacheKey, 300, JSON.stringify(tenant)); // 5分鐘快取
        
        return tenant;
    }

    /**
     * 更新租戶設定
     */
    async updateTenant(tenantId, updates) {
        const allowedFields = ['name', 'domain', 'config', 'branding', 'status'];
        const updateFields = [];
        const values = [];
        let paramIndex = 1;
        
        for (const field of allowedFields) {
            if (updates.hasOwnProperty(field)) {
                updateFields.push(`${field} = $${paramIndex}`);
                values.push(updates[field]);
                paramIndex++;
            }
        }
        
        if (updateFields.length === 0) {
            throw new Error('沒有可更新的欄位');
        }
        
        updateFields.push(`updated_at = NOW()`);
        values.push(tenantId);
        
        const query = `
            UPDATE tenants 
            SET ${updateFields.join(', ')}
            WHERE id = $${paramIndex}
            RETURNING *
        `;
        
        const result = await this.db.query(query, values);
        
        if (result.rows.length === 0) {
            throw new Error('租戶不存在');
        }
        
        const tenant = result.rows[0];
        
        // 清除快取
        await this.redis.del(`tenant:${tenantId}`);
        await this.redis.del(`tenant:${tenant.slug}`);
        
        return tenant;
    }

    /**
     * 檢查租戶限制
     */
    async checkTenantLimits(tenantId, resource) {
        const tenant = await this.getTenant(tenantId);
        const limits = tenant.limits;
        
        switch (resource) {
            case 'workflows':
                const workflowCount = await this.getWorkflowCount(tenantId);
                return {
                    allowed: workflowCount < limits.max_workflows,
                    current: workflowCount,
                    limit: limits.max_workflows
                };
                
            case 'executions':
                const monthlyExecutions = await this.getMonthlyExecutionCount(tenantId);
                return {
                    allowed: monthlyExecutions < limits.max_executions_per_month,
                    current: monthlyExecutions,
                    limit: limits.max_executions_per_month
                };
                
            case 'team_members':
                const memberCount = await this.getTeamMemberCount(tenantId);
                return {
                    allowed: memberCount < limits.max_team_members,
                    current: memberCount,
                    limit: limits.max_team_members
                };
                
            default:
                throw new Error('未知的資源類型');
        }
    }

    /**
     * 生成唯一的 slug
     */
    async generateUniqueSlug(name) {
        const baseSlug = name
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, '-')
            .replace(/^-+|-+$/g, '');
        
        let slug = baseSlug;
        let counter = 1;
        
        while (await this.slugExists(slug)) {
            slug = `${baseSlug}-${counter}`;
            counter++;
        }
        
        return slug;
    }

    async slugExists(slug) {
        const result = await this.db.query('SELECT 1 FROM tenants WHERE slug = $1', [slug]);
        return result.rows.length > 0;
    }

    getDefaultLimits(planType) {
        const limits = {
            basic: {
                max_workflows: 5,
                max_executions_per_month: 1000,
                max_team_members: 3
            },
            pro: {
                max_workflows: 25,
                max_executions_per_month: 10000,
                max_team_members: 10
            },
            enterprise: {
                max_workflows: 100,
                max_executions_per_month: 100000,
                max_team_members: 50
            }
        };
        
        return limits[planType] || limits.basic;
    }

    async initializeTenantSettings(tenantId) {
        // 建立預設的 Make Bridge 設定
        await this.db.query(`
            UPDATE tenants 
            SET make_bridge_config = $1
            WHERE id = $2
        `, [
            {
                zone_url: process.env.MAKE_ZONE_URL,
                templates: [],
                default_settings: {
                    auto_activate: true,
                    notification_email: null
                }
            },
            tenantId
        ]);
    }

    async getWorkflowCount(tenantId) {
        const result = await this.db.query(
            'SELECT COUNT(*) FROM workflows WHERE tenant_id = $1',
            [tenantId]
        );
        return parseInt(result.rows[0].count);
    }

    async getMonthlyExecutionCount(tenantId) {
        const startOfMonth = new Date();
        startOfMonth.setDate(1);
        startOfMonth.setHours(0, 0, 0, 0);
        
        const result = await this.db.query(`
            SELECT COUNT(*) FROM workflow_executions 
            WHERE tenant_id = $1 AND started_at >= $2
        `, [tenantId, startOfMonth]);
        
        return parseInt(result.rows[0].count);
    }

    async getTeamMemberCount(tenantId) {
        const result = await this.db.query(
            'SELECT COUNT(*) FROM tenant_users WHERE tenant_id = $1 AND status = \'active\'',
            [tenantId]
        );
        return parseInt(result.rows[0].count);
    }
}

module.exports = TenantService;
```

### 🔐 企業級認證與授權

> 🔑 **安全概念解釋**
> 
> - **認證 (Authentication)**：確認「你是誰」（像是查看身分證）
> - **授權 (Authorization)**：確認「你能做什麼」（像是檢查門禁卡權限）
> - **JWT (JSON Web Token)**：一種安全的身分憑證，就像是有數位簽名的通行證

#### JWT 中間件與權限控制

```javascript
// middleware/auth.js - 認證與授權中間件
const jwt = require('jsonwebtoken');
const { promisify } = require('util');
const TenantService = require('../services/TenantService');

class AuthMiddleware {
    constructor() {
        this.tenantService = new TenantService();
        this.jwtVerify = promisify(jwt.verify);
    }

    /**
     * 驗證 JWT Token
     */
    authenticateToken() {
        return async (req, res, next) => {
            try {
                const authHeader = req.headers.authorization;
                const token = authHeader && authHeader.split(' ')[1];
                
                if (!token) {
                    return res.status(401).json({ error: '缺少認證 Token' });
                }
                
                const decoded = await this.jwtVerify(token, process.env.JWT_SECRET);
                req.user = decoded;
                
                next();
            } catch (error) {
                return res.status(403).json({ error: 'Token 無效或已過期' });
            }
        };
    }

    /**
     * 識別租戶
     */
    identifyTenant() {
        return async (req, res, next) => {
            try {
                let tenantIdentifier = null;
                
                // 方法 1: 從 subdomain 識別
                const host = req.get('Host');
                if (host) {
                    const subdomain = host.split('.')[0];
                    if (subdomain && subdomain !== 'www' && subdomain !== 'api') {
                        tenantIdentifier = subdomain;
                    }
                }
                
                // 方法 2: 從 header 識別
                if (!tenantIdentifier) {
                    tenantIdentifier = req.headers['x-tenant-id'];
                }
                
                // 方法 3: 從路徑參數識別
                if (!tenantIdentifier) {
                    tenantIdentifier = req.params.tenantId;
                }
                
                if (!tenantIdentifier) {
                    return res.status(400).json({ error: '無法識別租戶' });
                }
                
                const tenant = await this.tenantService.getTenant(tenantIdentifier);
                req.tenant = tenant;
                
                next();
            } catch (error) {
                return res.status(404).json({ error: '租戶不存在' });
            }
        };
    }

    /**
     * 檢查租戶權限
     */
    requireTenantPermission(permission) {
        return async (req, res, next) => {
            try {
                if (!req.tenant || !req.user) {
                    return res.status(401).json({ error: '未認證' });
                }
                
                const hasPermission = await this.checkUserPermission(
                    req.user.id,
                    req.tenant.id,
                    permission
                );
                
                if (!hasPermission) {
                    return res.status(403).json({ error: '權限不足' });
                }
                
                next();
            } catch (error) {
                return res.status(500).json({ error: '權限檢查失敗' });
            }
        };
    }

    /**
     * 檢查使用者權限
     */
    async checkUserPermission(userId, tenantId, permission) {
        const result = await this.tenantService.db.query(`
            SELECT role, permissions 
            FROM tenant_users 
            WHERE user_id = $1 AND tenant_id = $2 AND status = 'active'
        `, [userId, tenantId]);
        
        if (result.rows.length === 0) {
            return false;
        }
        
        const { role, permissions } = result.rows[0];
        
        // 超級管理員擁有所有權限
        if (role === 'admin') {
            return true;
        }
        
        // 檢查角色權限
        const rolePermissions = this.getRolePermissions(role);
        if (rolePermissions.includes(permission)) {
            return true;
        }
        
        // 檢查自定義權限
        if (permissions && permissions.includes(permission)) {
            return true;
        }
        
        return false;
    }

    getRolePermissions(role) {
        const rolePermissionMap = {
            'admin': ['*'], // 所有權限
            'manager': [
                'workflows:read',
                'workflows:write',
                'workflows:delete',
                'team:read',
                'team:write',
                'analytics:read'
            ],
            'editor': [
                'workflows:read',
                'workflows:write',
                'analytics:read'
            ],
            'viewer': [
                'workflows:read',
                'analytics:read'
            ],
            'member': [
                'workflows:read'
            ]
        };
        
        return rolePermissionMap[role] || [];
    }

    /**
     * 速率限制
     */
    rateLimitByTenant() {
        const limiters = new Map();
        
        return async (req, res, next) => {
            if (!req.tenant) {
                return next();
            }
            
            const tenantId = req.tenant.id;
            const planType = req.tenant.plan_type;
            
            // 根據方案設定不同的限制
            const limits = {
                basic: { windowMs: 15 * 60 * 1000, max: 100 },
                pro: { windowMs: 15 * 60 * 1000, max: 500 },
                enterprise: { windowMs: 15 * 60 * 1000, max: 2000 }
            };
            
            const config = limits[planType] || limits.basic;
            
            // 實作簡單的滑動視窗速率限制
            if (!limiters.has(tenantId)) {
                limiters.set(tenantId, {
                    requests: [],
                    ...config
                });
            }
            
            const limiter = limiters.get(tenantId);
            const now = Date.now();
            
            // 清理過期的請求記錄
            limiter.requests = limiter.requests.filter(
                time => now - time < limiter.windowMs
            );
            
            if (limiter.requests.length >= limiter.max) {
                return res.status(429).json({
                    error: '請求過於頻繁',
                    retryAfter: Math.ceil(limiter.windowMs / 1000)
                });
            }
            
            limiter.requests.push(now);
            next();
        };
    }
}

module.exports = new AuthMiddleware();
```

## 7.3 步驟 2：微服務架構實作

### 🔧 API 閘道服務

> 🚪 **API 閘道概念**
> 
> API 閘道就像是大樓的接待處：
> - 所有訪客（請求）都必須先通過接待處
> - 接待員檢查身分並指引到正確的樓層（服務）
> - 記錄訪客紀錄（日誌）並監控大樓安全（監控指標）

```javascript
// gateway/api-gateway.js - API 閘道主服務
const express = require('express');
const httpProxy = require('http-proxy-middleware');
const cors = require('cors');
const helmet = require('helmet');
const compression = require('compression');
const prometheus = require('prom-client');

class APIGateway {
    constructor() {
        this.app = express();
        this.setupMiddleware();
        this.setupMetrics();
        this.setupRoutes();
    }

    setupMiddleware() {
        // 安全性
        this.app.use(helmet());
        this.app.use(compression());
        
        // CORS 設定
        this.app.use(cors({
            origin: (origin, callback) => {
                // 動態 CORS 驗證邏輯
                this.validateOrigin(origin, callback);
            },
            credentials: true
        }));
        
        this.app.use(express.json({ limit: '10mb' }));
        
        // 請求日誌
        this.app.use(this.requestLogger());
        
        // 健康檢查
        this.app.get('/health', (req, res) => {
            res.json({
                status: 'healthy',
                timestamp: new Date().toISOString(),
                uptime: process.uptime()
            });
        });
        
        // 指標端點
        this.app.get('/metrics', (req, res) => {
            res.set('Content-Type', prometheus.register.contentType);
            res.end(prometheus.register.metrics());
        });
    }

    setupMetrics() {
        // HTTP 請求計數器
        this.httpRequestCounter = new prometheus.Counter({
            name: 'http_requests_total',
            help: 'HTTP 請求總數',
            labelNames: ['method', 'route', 'status_code', 'tenant_id']
        });
        
        // 請求持續時間
        this.httpRequestDuration = new prometheus.Histogram({
            name: 'http_request_duration_seconds',
            help: 'HTTP 請求持續時間',
            labelNames: ['method', 'route', 'tenant_id'],
            buckets: [0.1, 0.5, 1, 2, 5, 10]
        });
        
        // Make Bridge 請求
        this.makeBridgeRequests = new prometheus.Counter({
            name: 'make_bridge_requests_total',
            help: 'Make Bridge 請求總數',
            labelNames: ['tenant_id', 'status']
        });
    }

    setupRoutes() {
        // 租戶管理服務
        this.app.use('/api/tenants', this.createProxy({
            target: process.env.TENANT_SERVICE_URL || 'http://localhost:3001',
            pathRewrite: { '^/api/tenants': '' }
        }));
        
        // 工作流程管理服務
        this.app.use('/api/workflows', this.createProxy({
            target: process.env.WORKFLOW_SERVICE_URL || 'http://localhost:3002',
            pathRewrite: { '^/api/workflows': '' }
        }));
        
        // Make Bridge 整合服務
        this.app.use('/api/bridge', this.createProxy({
            target: process.env.BRIDGE_SERVICE_URL || 'http://localhost:3003',
            pathRewrite: { '^/api/bridge': '' }
        }));
        
        // 分析服務
        this.app.use('/api/analytics', this.createProxy({
            target: process.env.ANALYTICS_SERVICE_URL || 'http://localhost:3004',
            pathRewrite: { '^/api/analytics': '' }
        }));
        
        // 通知服務
        this.app.use('/api/notifications', this.createProxy({
            target: process.env.NOTIFICATION_SERVICE_URL || 'http://localhost:3005',
            pathRewrite: { '^/api/notifications': '' }
        }));
    }

    createProxy(options) {
        return httpProxy({
            ...options,
            changeOrigin: true,
            timeout: 30000,
            
            // 請求轉換
            onProxyReq: (proxyReq, req, res) => {
                // 添加租戶資訊到 header
                if (req.tenant) {
                    proxyReq.setHeader('X-Tenant-ID', req.tenant.id);
                    proxyReq.setHeader('X-Tenant-Plan', req.tenant.plan_type);
                }
                
                // 添加使用者資訊
                if (req.user) {
                    proxyReq.setHeader('X-User-ID', req.user.id);
                    proxyReq.setHeader('X-User-Email', req.user.email);
                }
                
                // 記錄請求指標
                const labels = {
                    method: req.method,
                    route: this.normalizeRoute(req.route?.path || req.path),
                    tenant_id: req.tenant?.id || 'unknown'
                };
                
                req.startTime = Date.now();
                this.httpRequestCounter.inc(labels);
            },
            
            // 回應轉換
            onProxyRes: (proxyRes, req, res) => {
                // 記錄回應指標
                if (req.startTime) {
                    const duration = (Date.now() - req.startTime) / 1000;
                    const labels = {
                        method: req.method,
                        route: this.normalizeRoute(req.route?.path || req.path),
                        tenant_id: req.tenant?.id || 'unknown'
                    };
                    
                    this.httpRequestDuration.observe(labels, duration);
                    this.httpRequestCounter.labels({
                        ...labels,
                        status_code: proxyRes.statusCode
                    }).inc();
                }
            },
            
            // 錯誤處理
            onError: (err, req, res) => {
                console.error('代理錯誤:', err);
                res.status(502).json({
                    error: '服務暫時無法使用',
                    code: 'SERVICE_UNAVAILABLE'
                });
            }
        });
    }

    async validateOrigin(origin, callback) {
        // 允許本地開發
        if (!origin || origin.includes('localhost')) {
            return callback(null, true);
        }
        
        try {
            // 從資料庫查詢允許的域名
            const tenantService = new (require('../services/TenantService'))();
            const tenant = await tenantService.getTenant(origin);
            
            if (tenant && tenant.status === 'active') {
                callback(null, true);
            } else {
                callback(new Error('域名未授權'), false);
            }
        } catch (error) {
            callback(error, false);
        }
    }

    requestLogger() {
        return (req, res, next) => {
            const start = Date.now();
            
            res.on('finish', () => {
                const duration = Date.now() - start;
                console.log(`${req.method} ${req.path} - ${res.statusCode} (${duration}ms)`);
            });
            
            next();
        };
    }

    normalizeRoute(path) {
        return path
            ?.replace(/\/[0-9a-f-]{36}/g, '/:id') // UUID 參數
            ?.replace(/\/\d+/g, '/:id') // 數字 ID 參數
            || 'unknown';
    }

    start(port = 3000) {
        this.app.listen(port, () => {
            console.log(`API Gateway 已啟動於 port ${port}`);
        });
    }
}

module.exports = APIGateway;
```

### 🔄 工作流程管理微服務

> ⚙️ **微服務架構**
> 
> 想像傳統單體應用程式是一個大工廠，所有功能都在同一個建築物內。微服務則是將功能分散到不同的小工廠：
> - 每個小工廠（服務）專精特定功能
> - 可以獨立運作、更新、擴展
> - 透過 API 相互溝通
> - 其中一個故障不會影響其他服務

```javascript
// services/workflow-service/index.js - 工作流程管理服務
const express = require('express');
const { Pool } = require('pg');
const Redis = require('redis');
const TenantService = require('../TenantService');
const MakeBridgeService = require('../MakeBridgeService');

class WorkflowService {
    constructor() {
        this.app = express();
        this.db = new Pool({ connectionString: process.env.DATABASE_URL });
        this.redis = Redis.createClient({ url: process.env.REDIS_URL });
        this.tenantService = new TenantService();
        this.makeBridgeService = new MakeBridgeService();
        
        this.setupMiddleware();
        this.setupRoutes();
    }

    setupMiddleware() {
        this.app.use(express.json());
        
        // 租戶上下文中間件
        this.app.use((req, res, next) => {
            const tenantId = req.headers['x-tenant-id'];
            const userId = req.headers['x-user-id'];
            
            if (!tenantId) {
                return res.status(400).json({ error: '缺少租戶 ID' });
            }
            
            req.tenantId = tenantId;
            req.userId = userId;
            next();
        });
    }

    setupRoutes() {
        // 取得工作流程列表
        this.app.get('/', async (req, res) => {
            try {
                const { page = 1, limit = 20, status, search } = req.query;
                const offset = (page - 1) * limit;
                
                let query = `
                    SELECT w.*, 
                           u.email as created_by_email,
                           COUNT(*) OVER() as total_count
                    FROM workflows w
                    LEFT JOIN tenant_users u ON u.user_id = w.created_by AND u.tenant_id = w.tenant_id
                    WHERE w.tenant_id = $1
                `;
                
                const params = [req.tenantId];
                let paramIndex = 2;
                
                if (status) {
                    query += ` AND w.status = $${paramIndex}`;
                    params.push(status);
                    paramIndex++;
                }
                
                if (search) {
                    query += ` AND (w.name ILIKE $${paramIndex} OR w.description ILIKE $${paramIndex})`;
                    params.push(`%${search}%`);
                    paramIndex++;
                }
                
                query += ` ORDER BY w.created_at DESC LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;
                params.push(limit, offset);
                
                const result = await this.db.query(query, params);
                
                res.json({
                    workflows: result.rows,
                    pagination: {
                        page: parseInt(page),
                        limit: parseInt(limit),
                        total: result.rows.length > 0 ? parseInt(result.rows[0].total_count) : 0
                    }
                });
                
            } catch (error) {
                console.error('取得工作流程列表失敗:', error);
                res.status(500).json({ error: '無法取得工作流程列表' });
            }
        });

        // 建立新工作流程
        this.app.post('/', async (req, res) => {
            try {
                const { name, description, makeTemplateId, config } = req.body;
                
                // 檢查租戶限制
                const limitsCheck = await this.tenantService.checkTenantLimits(req.tenantId, 'workflows');
                if (!limitsCheck.allowed) {
                    return res.status(403).json({
                        error: '已達到工作流程數量限制',
                        limit: limitsCheck.limit,
                        current: limitsCheck.current
                    });
                }
                
                // 建立工作流程
                const result = await this.db.query(`
                    INSERT INTO workflows (tenant_id, name, description, make_template_id, config, created_by)
                    VALUES ($1, $2, $3, $4, $5, $6)
                    RETURNING *
                `, [req.tenantId, name, description, makeTemplateId, config || {}, req.userId]);
                
                const workflow = result.rows[0];
                
                // 如果有 Make 模板 ID，建立 Bridge 整合
                if (makeTemplateId) {
                    try {
                        const integration = await this.makeBridgeService.createIntegration({
                            tenantId: req.tenantId,
                            templateId: makeTemplateId,
                            workflowId: workflow.id,
                            userId: req.userId
                        });
                        
                        // 更新工作流程的 scenario ID
                        await this.db.query(`
                            UPDATE workflows 
                            SET make_scenario_id = $1, status = 'active'
                            WHERE id = $2
                        `, [integration.scenarioId, workflow.id]);
                        
                        workflow.make_scenario_id = integration.scenarioId;
                        workflow.status = 'active';
                        
                    } catch (bridgeError) {
                        console.error('Make Bridge 整合失敗:', bridgeError);
                        // 不阻止工作流程建立，但記錄錯誤
                    }
                }
                
                res.status(201).json(workflow);
                
            } catch (error) {
                console.error('建立工作流程失敗:', error);
                res.status(500).json({ error: '無法建立工作流程' });
            }
        });

        // 取得特定工作流程
        this.app.get('/:id', async (req, res) => {
            try {
                const result = await this.db.query(`
                    SELECT w.*, 
                           u.email as created_by_email,
                           COUNT(we.id) as total_executions,
                           COUNT(CASE WHEN we.status = 'success' THEN 1 END) as success_executions
                    FROM workflows w
                    LEFT JOIN tenant_users u ON u.user_id = w.created_by AND u.tenant_id = w.tenant_id
                    LEFT JOIN workflow_executions we ON we.workflow_id = w.id
                    WHERE w.id = $1 AND w.tenant_id = $2
                    GROUP BY w.id, u.email
                `, [req.params.id, req.tenantId]);
                
                if (result.rows.length === 0) {
                    return res.status(404).json({ error: '工作流程不存在' });
                }
                
                const workflow = result.rows[0];
                
                // 取得最近的執行記錄
                const executionsResult = await this.db.query(`
                    SELECT * FROM workflow_executions
                    WHERE workflow_id = $1
                    ORDER BY started_at DESC
                    LIMIT 10
                `, [workflow.id]);
                
                workflow.recent_executions = executionsResult.rows;
                
                res.json(workflow);
                
            } catch (error) {
                console.error('取得工作流程失敗:', error);
                res.status(500).json({ error: '無法取得工作流程' });
            }
        });

        // 更新工作流程
        this.app.put('/:id', async (req, res) => {
            try {
                const { name, description, config, status } = req.body;
                const allowedUpdates = { name, description, config, status };
                
                // 移除 undefined 值
                Object.keys(allowedUpdates).forEach(key => {
                    if (allowedUpdates[key] === undefined) {
                        delete allowedUpdates[key];
                    }
                });
                
                if (Object.keys(allowedUpdates).length === 0) {
                    return res.status(400).json({ error: '沒有可更新的欄位' });
                }
                
                const updateFields = [];
                const values = [];
                let paramIndex = 1;
                
                Object.entries(allowedUpdates).forEach(([field, value]) => {
                    updateFields.push(`${field} = $${paramIndex}`);
                    values.push(value);
                    paramIndex++;
                });
                
                updateFields.push('updated_at = NOW()');
                values.push(req.params.id, req.tenantId);
                
                const result = await this.db.query(`
                    UPDATE workflows 
                    SET ${updateFields.join(', ')}
                    WHERE id = $${paramIndex} AND tenant_id = $${paramIndex + 1}
                    RETURNING *
                `, values);
                
                if (result.rows.length === 0) {
                    return res.status(404).json({ error: '工作流程不存在' });
                }
                
                res.json(result.rows[0]);
                
            } catch (error) {
                console.error('更新工作流程失敗:', error);
                res.status(500).json({ error: '無法更新工作流程' });
            }
        });

        // 刪除工作流程
        this.app.delete('/:id', async (req, res) => {
            const client = await this.db.connect();
            
            try {
                await client.query('BEGIN');
                
                // 取得工作流程資訊
                const workflowResult = await client.query(`
                    SELECT * FROM workflows 
                    WHERE id = $1 AND tenant_id = $2
                `, [req.params.id, req.tenantId]);
                
                if (workflowResult.rows.length === 0) {
                    return res.status(404).json({ error: '工作流程不存在' });
                }
                
                const workflow = workflowResult.rows[0];
                
                // 刪除 Make Bridge 整合
                if (workflow.make_scenario_id) {
                    try {
                        await this.makeBridgeService.deleteIntegration({
                            tenantId: req.tenantId,
                            scenarioId: workflow.make_scenario_id
                        });
                    } catch (bridgeError) {
                        console.error('刪除 Make Bridge 整合失敗:', bridgeError);
                        // 繼續刪除本地記錄
                    }
                }
                
                // 刪除執行記錄
                await client.query(`
                    DELETE FROM workflow_executions 
                    WHERE workflow_id = $1
                `, [req.params.id]);
                
                // 刪除工作流程
                await client.query(`
                    DELETE FROM workflows 
                    WHERE id = $1 AND tenant_id = $2
                `, [req.params.id, req.tenantId]);
                
                await client.query('COMMIT');
                
                res.json({ message: '工作流程已刪除' });
                
            } catch (error) {
                await client.query('ROLLBACK');
                console.error('刪除工作流程失敗:', error);
                res.status(500).json({ error: '無法刪除工作流程' });
            } finally {
                client.release();
            }
        });

        // 執行工作流程
        this.app.post('/:id/execute', async (req, res) => {
            try {
                const { triggerData } = req.body;
                
                // 檢查執行限制
                const limitsCheck = await this.tenantService.checkTenantLimits(req.tenantId, 'executions');
                if (!limitsCheck.allowed) {
                    return res.status(403).json({
                        error: '已達到月執行次數限制',
                        limit: limitsCheck.limit,
                        current: limitsCheck.current
                    });
                }
                
                // 建立執行記錄
                const executionResult = await this.db.query(`
                    INSERT INTO workflow_executions (tenant_id, workflow_id, trigger_data, status)
                    VALUES ($1, $2, $3, 'running')
                    RETURNING *
                `, [req.tenantId, req.params.id, triggerData || {}]);
                
                const execution = executionResult.rows[0];
                
                // 觸發 Make Bridge 執行
                try {
                    const result = await this.makeBridgeService.executeWorkflow({
                        tenantId: req.tenantId,
                        workflowId: req.params.id,
                        executionId: execution.id,
                        triggerData: triggerData
                    });
                    
                    // 更新執行狀態
                    await this.db.query(`
                        UPDATE workflow_executions 
                        SET status = 'success', execution_result = $1, completed_at = NOW(),
                            duration_ms = EXTRACT(EPOCH FROM (NOW() - started_at)) * 1000
                        WHERE id = $2
                    `, [result, execution.id]);
                    
                    execution.status = 'success';
                    execution.execution_result = result;
                    
                } catch (executeError) {
                    // 更新執行狀態為失敗
                    await this.db.query(`
                        UPDATE workflow_executions 
                        SET status = 'error', error_message = $1, completed_at = NOW(),
                            duration_ms = EXTRACT(EPOCH FROM (NOW() - started_at)) * 1000
                        WHERE id = $2
                    `, [executeError.message, execution.id]);
                    
                    execution.status = 'error';
                    execution.error_message = executeError.message;
                }
                
                // 更新工作流程統計
                await this.updateWorkflowStats(req.params.id);
                
                res.json(execution);
                
            } catch (error) {
                console.error('執行工作流程失敗:', error);
                res.status(500).json({ error: '無法執行工作流程' });
            }
        });
    }

    async updateWorkflowStats(workflowId) {
        await this.db.query(`
            UPDATE workflows 
            SET execution_count = (
                SELECT COUNT(*) FROM workflow_executions WHERE workflow_id = $1
            ),
            success_count = (
                SELECT COUNT(*) FROM workflow_executions WHERE workflow_id = $1 AND status = 'success'
            ),
            error_count = (
                SELECT COUNT(*) FROM workflow_executions WHERE workflow_id = $1 AND status = 'error'
            ),
            last_executed_at = (
                SELECT MAX(started_at) FROM workflow_executions WHERE workflow_id = $1
            )
            WHERE id = $1
        `, [workflowId]);
    }

    start(port = 3002) {
        this.app.listen(port, () => {
            console.log(`工作流程服務已啟動於 port ${port}`);
        });
    }
}

// 啟動服務
if (require.main === module) {
    const service = new WorkflowService();
    service.start();
}

module.exports = WorkflowService;
```

## 7.4 步驟 3：高可用性部署

### 🐳 Docker 容器化

> 📦 **容器化概念**
> 
> **容器 (Container)** 就像是標準化的貨櫃：
> - 將應用程式和所有依賴項目打包在一起
> - 可以在任何支援 Docker 的環境中運行
> - 確保「在我電腦上能跑，在伺服器上也能跑」
> - **Docker** 是最流行的容器化平台，就像是貨櫃運輸的標準

```dockerfile
# Dockerfile.gateway - API 閘道 Dockerfile
FROM node:18-alpine

# 建立應用目錄
WORKDIR /app

# 複製 package 檔案
COPY package*.json ./
COPY gateway/package*.json ./gateway/

# 安裝依賴
RUN npm ci --only=production

# 複製應用程式碼
COPY gateway/ ./gateway/
COPY shared/ ./shared/

# 建立非 root 使用者
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001

# 設定檔案權限
RUN chown -R nextjs:nodejs /app
USER nextjs

# 暴露端口
EXPOSE 3000

# 健康檢查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

# 啟動命令
CMD ["node", "gateway/index.js"]
```

```dockerfile
# Dockerfile.service - 微服務通用 Dockerfile
FROM node:18-alpine

ARG SERVICE_NAME
ENV SERVICE_NAME=${SERVICE_NAME}

WORKDIR /app

# 複製依賴檔案
COPY package*.json ./
COPY services/${SERVICE_NAME}/package*.json ./services/${SERVICE_NAME}/

# 安裝依賴
RUN npm ci --only=production

# 複製應用程式碼
COPY services/${SERVICE_NAME}/ ./services/${SERVICE_NAME}/
COPY shared/ ./shared/

# 建立使用者
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodejs -u 1001

# 設定權限
RUN chown -R nodejs:nodejs /app
USER nodejs

# 暴露端口
EXPOSE 3000

# 健康檢查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

# 啟動命令
CMD node services/${SERVICE_NAME}/index.js
```

### ☸️ Kubernetes 部署配置

> 🚢 **Kubernetes 概念**
> 
> **Kubernetes (K8s)** 就像是一個智能的貨櫃碼頭管理系統：
> - 自動調度貨櫃（容器）到最適合的位置（伺服器）
> - 監控貨櫃狀態，有問題就自動重啟或搬移
> - 根據需求自動增減貨櫃數量（自動擴展）
> - 管理貨櫃之間的網路連接和資料儲存

```yaml
# k8s/namespace.yaml - 命名空間
apiVersion: v1
kind: Namespace
metadata:
  name: saas-automation
  labels:
    name: saas-automation
```

```yaml
# k8s/configmap.yaml - 配置映射
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
  namespace: saas-automation
data:
  NODE_ENV: "production"
  LOG_LEVEL: "info"
  MAKE_ZONE_URL: "https://eu2.make.com"
  REDIS_URL: "redis://redis-service:6379"
  DATABASE_URL: "postgresql://user:pass@postgres-service:5432/saas_automation"
```

```yaml
# k8s/secret.yaml - 機密資料
apiVersion: v1
kind: Secret
metadata:
  name: app-secrets
  namespace: saas-automation
type: Opaque
data:
  JWT_SECRET: <base64-encoded-jwt-secret>
  DATABASE_PASSWORD: <base64-encoded-db-password>
  MAKE_BRIDGE_SECRET: <base64-encoded-make-secret>
  MAKE_BRIDGE_KEY_ID: <base64-encoded-key-id>
```

```yaml
# k8s/api-gateway.yaml - API 閘道部署
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api-gateway
  namespace: saas-automation
  labels:
    app: api-gateway
spec:
  replicas: 3
  selector:
    matchLabels:
      app: api-gateway
  template:
    metadata:
      labels:
        app: api-gateway
    spec:
      containers:
      - name: api-gateway
        image: your-registry/saas-automation/api-gateway:latest
        ports:
        - containerPort: 3000
        env:
        - name: PORT
          value: "3000"
        envFrom:
        - configMapRef:
            name: app-config
        - secretRef:
            name: app-secrets
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: api-gateway-service
  namespace: saas-automation
spec:
  selector:
    app: api-gateway
  ports:
  - protocol: TCP
    port: 80
    targetPort: 3000
  type: ClusterIP
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: api-gateway-ingress
  namespace: saas-automation
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/rate-limit: "100"
    nginx.ingress.kubernetes.io/rate-limit-window: "1m"
spec:
  tls:
  - hosts:
    - api.yourdomain.com
    - "*.yourdomain.com"
    secretName: api-tls
  rules:
  - host: api.yourdomain.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: api-gateway-service
            port:
              number: 80
  - host: "*.yourdomain.com"
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: api-gateway-service
            port:
              number: 80
```

```yaml
# k8s/workflow-service.yaml - 工作流程服務部署
apiVersion: apps/v1
kind: Deployment
metadata:
  name: workflow-service
  namespace: saas-automation
spec:
  replicas: 2
  selector:
    matchLabels:
      app: workflow-service
  template:
    metadata:
      labels:
        app: workflow-service
    spec:
      containers:
      - name: workflow-service
        image: your-registry/saas-automation/workflow-service:latest
        ports:
        - containerPort: 3000
        envFrom:
        - configMapRef:
            name: app-config
        - secretRef:
            name: app-secrets
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: workflow-service
  namespace: saas-automation
spec:
  selector:
    app: workflow-service
  ports:
  - protocol: TCP
    port: 80
    targetPort: 3000
  type: ClusterIP
---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: workflow-service-hpa
  namespace: saas-automation
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: workflow-service
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
```

### 📊 監控和告警配置

> 📈 **監控系統概念**
> 
> 監控系統就像是醫院的生命徵象監測器：
> - **Prometheus**：收集各種指標數據（心跳、血壓等）
> - **Grafana**：將數據視覺化成圖表（監測螢幕）
> - **告警規則**：當指標異常時自動通知（警報器）
> - **ServiceMonitor**：定義要監控哪些服務（監測點）

```yaml
# k8s/monitoring.yaml - Prometheus 監控配置
apiVersion: v1
kind: ServiceMonitor
metadata:
  name: app-metrics
  namespace: saas-automation
spec:
  selector:
    matchLabels:
      monitoring: enabled
  endpoints:
  - port: metrics
    interval: 30s
    path: /metrics
---
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: app-alerts
  namespace: saas-automation
spec:
  groups:
  - name: app.rules
    rules:
    - alert: HighErrorRate
      expr: rate(http_requests_total{status_code=~"5.."}[5m]) > 0.1
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "High error rate detected"
        description: "Error rate is {{ $value }} per second"
    
    - alert: HighResponseTime
      expr: histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m])) > 2
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "High response time detected"
        description: "95th percentile response time is {{ $value }} seconds"
    
    - alert: PodCrashLooping
      expr: rate(kube_pod_container_status_restarts_total[15m]) > 0
      for: 5m
      labels:
        severity: critical
      annotations:
        summary: "Pod is crash looping"
        description: "Pod {{ $labels.pod }} is restarting frequently"
```

## 7.5 步驟 4：企業級前端應用

### ⚛️ React 企業儀表板

> 🖥️ **現代前端開發**
> 
> - **React**：由 Facebook 開發的前端框架，讓建立互動式使用者介面變得更簡單
> - **組件化 (Component-based)**：將 UI 拆分成可重複使用的小元件
> - **狀態管理**：追蹤和管理應用程式中的資料變化
> - **Material-UI**：提供美觀且一致的 UI 元件庫

```jsx
// frontend/src/App.jsx - 主應用組件
import React, { useState, useEffect } from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { Provider } from 'react-redux';
import { ThemeProvider } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';

import { store } from './store';
import { theme } from './theme';
import { AuthProvider } from './contexts/AuthContext';
import { TenantProvider } from './contexts/TenantContext';

// Layout 組件
import Layout from './components/Layout/Layout';
import ProtectedRoute from './components/Auth/ProtectedRoute';

// 頁面組件
import LoginPage from './pages/Auth/LoginPage';
import DashboardPage from './pages/Dashboard/DashboardPage';
import WorkflowsPage from './pages/Workflows/WorkflowsPage';
import WorkflowDetailPage from './pages/Workflows/WorkflowDetailPage';
import AnalyticsPage from './pages/Analytics/AnalyticsPage';
import SettingsPage from './pages/Settings/SettingsPage';
import TeamPage from './pages/Team/TeamPage';

function App() {
  return (
    <Provider store={store}>
      <ThemeProvider theme={theme}>
        <CssBaseline />
        <AuthProvider>
          <TenantProvider>
            <Router>
              <Routes>
                {/* 公開路由 */}
                <Route path="/login" element={<LoginPage />} />
                
                {/* 受保護的路由 */}
                <Route path="/" element={
                  <ProtectedRoute>
                    <Layout />
                  </ProtectedRoute>
                }>
                  <Route index element={<Navigate to="/dashboard" replace />} />
                  <Route path="dashboard" element={<DashboardPage />} />
                  <Route path="workflows" element={<WorkflowsPage />} />
                  <Route path="workflows/:id" element={<WorkflowDetailPage />} />
                  <Route path="analytics" element={<AnalyticsPage />} />
                  <Route path="team" element={<TeamPage />} />
                  <Route path="settings" element={<SettingsPage />} />
                </Route>
                
                {/* 404 處理 */}
                <Route path="*" element={<Navigate to="/dashboard" replace />} />
              </Routes>
            </Router>
          </TenantProvider>
        </AuthProvider>
      </ThemeProvider>
    </Provider>
  );
}

export default App;
```

```jsx
// frontend/src/pages/Workflows/WorkflowsPage.jsx - 工作流程管理頁面
import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  Button,
  Paper,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  TablePagination,
  Chip,
  IconButton,
  Dialog,
  DialogTitle,
  DialogContent,
  Tooltip,
  Alert,
  Snackbar
} from '@mui/material';
import {
  Add as AddIcon,
  Edit as EditIcon,
  Delete as DeleteIcon,
  PlayArrow as PlayIcon,
  Settings as SettingsIcon
} from '@mui/icons-material';

import { useWorkflows } from '../../hooks/useWorkflows';
import { useTenant } from '../../contexts/TenantContext';
import WorkflowCreateDialog from '../../components/Workflows/WorkflowCreateDialog';
import MakeBridgeSetupDialog from '../../components/MakeBridge/MakeBridgeSetupDialog';
import LoadingSpinner from '../../components/UI/LoadingSpinner';

const statusColors = {
  active: 'success',
  draft: 'warning',
  inactive: 'default',
  error: 'error'
};

const statusLabels = {
  active: '活躍',
  draft: '草稿',
  inactive: '停用',
  error: '錯誤'
};

export default function WorkflowsPage() {
  const { tenant } = useTenant();
  const {
    workflows,
    loading,
    error,
    pagination,
    createWorkflow,
    updateWorkflow,
    deleteWorkflow,
    executeWorkflow,
    fetchWorkflows
  } = useWorkflows();

  const [page, setPage] = useState(0);
  const [rowsPerPage, setRowsPerPage] = useState(10);
  const [createDialogOpen, setCreateDialogOpen] = useState(false);
  const [setupDialogOpen, setSetupDialogOpen] = useState(false);
  const [selectedWorkflow, setSelectedWorkflow] = useState(null);
  const [snackbar, setSnackbar] = useState({ open: false, message: '', severity: 'info' });

  useEffect(() => {
    fetchWorkflows({ page: page + 1, limit: rowsPerPage });
  }, [page, rowsPerPage, fetchWorkflows]);

  const handleChangePage = (event, newPage) => {
    setPage(newPage);
  };

  const handleChangeRowsPerPage = (event) => {
    setRowsPerPage(parseInt(event.target.value, 10));
    setPage(0);
  };

  const handleCreateWorkflow = async (workflowData) => {
    try {
      await createWorkflow(workflowData);
      setCreateDialogOpen(false);
      setSnackbar({
        open: true,
        message: '工作流程建立成功',
        severity: 'success'
      });
    } catch (error) {
      setSnackbar({
        open: true,
        message: `建立失敗: ${error.message}`,
        severity: 'error'
      });
    }
  };

  const handleExecuteWorkflow = async (workflowId) => {
    try {
      await executeWorkflow(workflowId, {});
      setSnackbar({
        open: true,
        message: '工作流程執行成功',
        severity: 'success'
      });
    } catch (error) {
      setSnackbar({
        open: true,
        message: `執行失敗: ${error.message}`,
        severity: 'error'
      });
    }
  };

  const handleDeleteWorkflow = async (workflowId) => {
    if (window.confirm('確定要刪除此工作流程嗎？')) {
      try {
        await deleteWorkflow(workflowId);
        setSnackbar({
          open: true,
          message: '工作流程已刪除',
          severity: 'success'
        });
      } catch (error) {
        setSnackbar({
          open: true,
          message: `刪除失敗: ${error.message}`,
          severity: 'error'
        });
      }
    }
  };

  if (loading && workflows.length === 0) {
    return <LoadingSpinner />;
  }

  return (
    <Box>
      {/* 頁面標題和動作 */}
      <Box display="flex" justifyContent="space-between" alignItems="center" mb={3}>
        <Typography variant="h4" component="h1">
          工作流程管理
        </Typography>
        <Box>
          <Button
            variant="outlined"
            startIcon={<SettingsIcon />}
            onClick={() => setSetupDialogOpen(true)}
            sx={{ mr: 2 }}
          >
            Make Bridge 設定
          </Button>
          <Button
            variant="contained"
            startIcon={<AddIcon />}
            onClick={() => setCreateDialogOpen(true)}
          >
            建立工作流程
          </Button>
        </Box>
      </Box>

      {/* 錯誤顯示 */}
      {error && (
        <Alert severity="error" sx={{ mb: 2 }}>
          {error}
        </Alert>
      )}

      {/* 工作流程表格 */}
      <Paper>
        <TableContainer>
          <Table>
            <TableHead>
              <TableRow>
                <TableCell>名稱</TableCell>
                <TableCell>狀態</TableCell>
                <TableCell>執行次數</TableCell>
                <TableCell>成功率</TableCell>
                <TableCell>最後執行</TableCell>
                <TableCell>建立時間</TableCell>
                <TableCell align="right">操作</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {workflows.map((workflow) => (
                <TableRow key={workflow.id} hover>
                  <TableCell>
                    <Box>
                      <Typography variant="subtitle2">
                        {workflow.name}
                      </Typography>
                      {workflow.description && (
                        <Typography variant="body2" color="text.secondary">
                          {workflow.description}
                        </Typography>
                      )}
                    </Box>
                  </TableCell>
                  <TableCell>
                    <Chip
                      label={statusLabels[workflow.status]}
                      color={statusColors[workflow.status]}
                      size="small"
                    />
                  </TableCell>
                  <TableCell>
                    {workflow.execution_count || 0}
                  </TableCell>
                  <TableCell>
                    {workflow.execution_count > 0
                      ? `${Math.round((workflow.success_count / workflow.execution_count) * 100)}%`
                      : '-'
                    }
                  </TableCell>
                  <TableCell>
                    {workflow.last_executed_at
                      ? new Date(workflow.last_executed_at).toLocaleString('zh-TW')
                      : '從未執行'
                    }
                  </TableCell>
                  <TableCell>
                    {new Date(workflow.created_at).toLocaleDateString('zh-TW')}
                  </TableCell>
                  <TableCell align="right">
                    <Tooltip title="執行">
                      <IconButton
                        size="small"
                        onClick={() => handleExecuteWorkflow(workflow.id)}
                        disabled={workflow.status !== 'active'}
                      >
                        <PlayIcon />
                      </IconButton>
                    </Tooltip>
                    <Tooltip title="編輯">
                      <IconButton
                        size="small"
                        onClick={() => setSelectedWorkflow(workflow)}
                      >
                        <EditIcon />
                      </IconButton>
                    </Tooltip>
                    <Tooltip title="刪除">
                      <IconButton
                        size="small"
                        onClick={() => handleDeleteWorkflow(workflow.id)}
                        color="error"
                      >
                        <DeleteIcon />
                      </IconButton>
                    </Tooltip>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </TableContainer>
        
        {/* 分頁 */}
        <TablePagination
          rowsPerPageOptions={[5, 10, 25]}
          component="div"
          count={pagination.total}
          rowsPerPage={rowsPerPage}
          page={page}
          onPageChange={handleChangePage}
          onRowsPerPageChange={handleChangeRowsPerPage}
          labelRowsPerPage="每頁筆數:"
          labelDisplayedRows={({ from, to, count }) =>
            `${from}-${to} / 共 ${count} 筆`
          }
        />
      </Paper>

      {/* 建立工作流程對話框 */}
      <WorkflowCreateDialog
        open={createDialogOpen}
        onClose={() => setCreateDialogOpen(false)}
        onSubmit={handleCreateWorkflow}
      />

      {/* Make Bridge 設定對話框 */}
      <MakeBridgeSetupDialog
        open={setupDialogOpen}
        onClose={() => setSetupDialogOpen(false)}
        tenant={tenant}
      />

      {/* 通知 Snackbar */}
      <Snackbar
        open={snackbar.open}
        autoHideDuration={6000}
        onClose={() => setSnackbar({ ...snackbar, open: false })}
      >
        <Alert
          onClose={() => setSnackbar({ ...snackbar, open: false })}
          severity={snackbar.severity}
          sx={{ width: '100%' }}
        >
          {snackbar.message}
        </Alert>
      </Snackbar>
    </Box>
  );
}
```

### 🎨 品牌客製化系統

> 🎨 **白標籤技術**
> 
> 品牌客製化讓您的客戶能夠：
> - 上傳自己的 Logo 和設定品牌顏色
> - 自訂 CSS 樣式來調整介面外觀
> - 客製化郵件範本
> - 讓終端使用者感覺這是他們自己的產品

```jsx
// frontend/src/components/Branding/BrandingCustomizer.jsx - 品牌客製化
import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  Paper,
  Grid,
  TextField,
  Button,
  ColorPicker,
  Upload,
  Preview,
  Tabs,
  Tab,
  FormControl,
  FormLabel,
  Switch,
  Alert
} from '@mui/material';

import { useTenant } from '../../contexts/TenantContext';
import { brandingAPI } from '../../services/api';

export default function BrandingCustomizer() {
  const { tenant, updateTenant } = useTenant();
  const [activeTab, setActiveTab] = useState(0);
  const [branding, setBranding] = useState({
    logo: '',
    favicon: '',
    primaryColor: '#1976d2',
    secondaryColor: '#dc004e',
    companyName: '',
    customCSS: '',
    emailTemplates: {
      header: '',
      footer: '',
      colors: {}
    }
  });
  const [preview, setPreview] = useState(false);
  const [saving, setSaving] = useState(false);

  useEffect(() => {
    if (tenant?.branding) {
      setBranding({ ...branding, ...tenant.branding });
    }
  }, [tenant]);

  const handleSave = async () => {
    setSaving(true);
    try {
      await updateTenant({ branding });
      // 顯示成功訊息
    } catch (error) {
      // 顯示錯誤訊息
    } finally {
      setSaving(false);
    }
  };

  const handleLogoUpload = async (file) => {
    const formData = new FormData();
    formData.append('logo', file);
    
    try {
      const result = await brandingAPI.uploadLogo(formData);
      setBranding({ ...branding, logo: result.url });
    } catch (error) {
      console.error('Logo 上傳失敗:', error);
    }
  };

  const generatePreviewCSS = () => {
    return `
      :root {
        --primary-color: ${branding.primaryColor};
        --secondary-color: ${branding.secondaryColor};
        --logo-url: url('${branding.logo}');
      }
      
      .custom-branding .logo {
        background-image: var(--logo-url);
        background-size: contain;
        background-repeat: no-repeat;
      }
      
      .custom-branding .btn-primary {
        background-color: var(--primary-color);
        border-color: var(--primary-color);
      }
      
      .custom-branding .btn-secondary {
        background-color: var(--secondary-color);
        border-color: var(--secondary-color);
      }
      
      ${branding.customCSS}
    `;
  };

  return (
    <Box>
      <Typography variant="h5" gutterBottom>
        品牌客製化
      </Typography>
      
      <Paper sx={{ p: 3 }}>
        <Tabs value={activeTab} onChange={(e, v) => setActiveTab(v)}>
          <Tab label="基本設定" />
          <Tab label="顏色主題" />
          <Tab label="自定義 CSS" />
          <Tab label="郵件範本" />
        </Tabs>
        
        {/* 基本設定頁籤 */}
        {activeTab === 0 && (
          <Box sx={{ mt: 3 }}>
            <Grid container spacing={3}>
              <Grid item xs={12} md={6}>
                <TextField
                  fullWidth
                  label="公司名稱"
                  value={branding.companyName}
                  onChange={(e) => setBranding({
                    ...branding,
                    companyName: e.target.value
                  })}
                />
              </Grid>
              
              <Grid item xs={12} md={6}>
                <FormControl fullWidth>
                  <FormLabel>Logo 上傳</FormLabel>
                  <Upload
                    accept="image/*"
                    onUpload={handleLogoUpload}
                    preview={branding.logo}
                  />
                </FormControl>
              </Grid>
              
              <Grid item xs={12}>
                <Preview
                  css={generatePreviewCSS()}
                  branding={branding}
                />
              </Grid>
            </Grid>
          </Box>
        )}
        
        {/* 顏色主題頁籤 */}
        {activeTab === 1 && (
          <Box sx={{ mt: 3 }}>
            <Grid container spacing={3}>
              <Grid item xs={12} md={6}>
                <FormControl fullWidth>
                  <FormLabel>主要顏色</FormLabel>
                  <ColorPicker
                    value={branding.primaryColor}
                    onChange={(color) => setBranding({
                      ...branding,
                      primaryColor: color
                    })}
                  />
                </FormControl>
              </Grid>
              
              <Grid item xs={12} md={6}>
                <FormControl fullWidth>
                  <FormLabel>次要顏色</FormLabel>
                  <ColorPicker
                    value={branding.secondaryColor}
                    onChange={(color) => setBranding({
                      ...branding,
                      secondaryColor: color
                    })}
                  />
                </FormControl>
              </Grid>
            </Grid>
          </Box>
        )}
        
        {/* 自定義 CSS 頁籤 */}
        {activeTab === 2 && (
          <Box sx={{ mt: 3 }}>
            <Alert severity="info" sx={{ mb: 2 }}>
              您可以添加自定義 CSS 來進一步客製化介面外觀。
            </Alert>
            
            <TextField
              fullWidth
              multiline
              rows={10}
              label="自定義 CSS"
              value={branding.customCSS}
              onChange={(e) => setBranding({
                ...branding,
                customCSS: e.target.value
              })}
              placeholder="/* 在這裡添加您的自定義 CSS */"
            />
          </Box>
        )}
        
        {/* 郵件範本頁籤 */}
        {activeTab === 3 && (
          <Box sx={{ mt: 3 }}>
            <Grid container spacing={3}>
              <Grid item xs={12}>
                <TextField
                  fullWidth
                  multiline
                  rows={4}
                  label="郵件標頭"
                  value={branding.emailTemplates.header}
                  onChange={(e) => setBranding({
                    ...branding,
                    emailTemplates: {
                      ...branding.emailTemplates,
                      header: e.target.value
                    }
                  })}
                />
              </Grid>
              
              <Grid item xs={12}>
                <TextField
                  fullWidth
                  multiline
                  rows={4}
                  label="郵件頁尾"
                  value={branding.emailTemplates.footer}
                  onChange={(e) => setBranding({
                    ...branding,
                    emailTemplates: {
                      ...branding.emailTemplates,
                      footer: e.target.value
                    }
                  })}
                />
              </Grid>
            </Grid>
          </Box>
        )}
        
        {/* 動作按鈕 */}
        <Box sx={{ mt: 4, display: 'flex', gap: 2 }}>
          <Button
            variant="outlined"
            onClick={() => setPreview(!preview)}
          >
            {preview ? '關閉預覽' : '預覽變更'}
          </Button>
          
          <Button
            variant="contained"
            onClick={handleSave}
            disabled={saving}
          >
            {saving ? '儲存中...' : '儲存變更'}
          </Button>
        </Box>
      </Paper>
    </Box>
  );
}
```

## 7.6 本章總結

完成本章後，您已經建立了一個完整的企業級多租戶 SaaS 自動化平台，包括：

✅ **多租戶架構設計與實作**  
✅ **微服務化的系統架構**  
✅ **企業級認證與授權系統**  
✅ **高可用性容器化部署**  
✅ **完整的監控和告警機制**  
✅ **企業級前端管理介面**  
✅ **品牌客製化系統**  

### 📈 企業級技能掌握

通過本項目，您已具備：
- 設計和實作多租戶 SaaS 架構的能力
- 微服務系統設計和容器化部署技能
- 企業級安全控制和權限管理經驗
- 高可用性和可擴展性系統設計能力
- 完整的 DevOps 和監控體系建置經驗

> 🎯 **學習成就解鎖**
> 
> 恭喜！您現在已經掌握了企業級軟體開發的核心技能：
> - **架構設計師**：能夠設計可擴展的系統架構
> - **DevOps 工程師**：熟悉容器化和自動化部署
> - **全端開發者**：具備前後端整合開發能力
> - **安全專家**：理解企業級安全控制措施
> 
> 這些技能不僅適用於 Make Bridge，也是現代軟體開發的通用技能！

### 🚀 下一步

高級專案完成後，您已經掌握了 Make Bridge 的所有核心技術和企業級應用場景。下一章將為您提供常見應用場景的實作範例和最佳實踐指南。