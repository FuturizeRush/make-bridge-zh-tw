# 第十二章：疑難排解與維護

## 本章概述

本章提供完整的疑難排解指南和維護最佳實踐，幫助開發者快速解決常見問題，並確保 Make Bridge 整合的長期穩定運行。

## 12.1 常見問題與解決方案

### 12.1.1 初始化問題

**問題：Bridge 初始化失敗**

症狀：
- 收到 401 或 403 錯誤
- JWT token 無法驗證
- 整合介面無法載入

解決步驟：

```javascript
// 1. 檢查 JWT 生成
function debugJWT() {
    const payload = {
        sub: userId,
        jti: crypto.randomUUID(),
    };
    
    console.log('JWT Payload:', payload);
    console.log('Secret Key exists:', !!process.env.JWT_SECRET);
    console.log('Key ID:', process.env.KEY_ID);
    
    try {
        const token = jwt.sign(payload, process.env.JWT_SECRET, {
            expiresIn: '2m',
            keyid: process.env.KEY_ID,
            algorithm: 'HS256'
        });
        
        console.log('Generated token:', token);
        
        // 驗證 token
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        console.log('Decoded token:', decoded);
        
        return token;
    } catch (error) {
        console.error('JWT Error:', error);
        return null;
    }
}

// 2. 檢查環境變數
function checkEnvironment() {
    const required = ['JWT_SECRET', 'KEY_ID', 'APP_ID'];
    const missing = required.filter(key => !process.env[key]);
    
    if (missing.length > 0) {
        console.error('Missing environment variables:', missing);
        return false;
    }
    
    return true;
}

// 3. 測試 API 連接
async function testAPIConnection() {
    try {
        const response = await fetch('https://api.make.com/v1/health');
        const data = await response.json();
        console.log('API Health:', data);
        return response.ok;
    } catch (error) {
        console.error('API Connection Error:', error);
        return false;
    }
}
```

**問題：CORS 錯誤**

症狀：
- 瀏覽器控制台顯示 CORS 錯誤
- 預檢請求失敗

解決方案：

```javascript
// Express.js CORS 設定
const cors = require('cors');

app.use(cors({
    origin: [
        'https://integrations.make.com',
        'https://api.make.com',
        process.env.FRONTEND_URL
    ],
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization', 'X-API-Key'],
    maxAge: 86400 // 24小時
}));

// 手動處理 OPTIONS 請求
app.options('*', (req, res) => {
    res.header('Access-Control-Allow-Origin', req.headers.origin);
    res.header('Access-Control-Allow-Methods', 'GET,POST,PUT,DELETE,OPTIONS');
    res.header('Access-Control-Allow-Headers', 'Content-Type,Authorization');
    res.header('Access-Control-Allow-Credentials', 'true');
    res.sendStatus(200);
});
```

### 12.1.2 場景執行問題

**問題：場景執行失敗**

症狀：
- 場景狀態顯示錯誤
- Webhook 無回應
- 執行超時

診斷工具：

```javascript
// 場景診斷工具
class ScenarioDiagnostics {
    async diagnose(scenarioId) {
        const report = {
            scenario: null,
            connections: [],
            webhooks: [],
            executions: [],
            issues: []
        };

        try {
            // 1. 檢查場景狀態
            report.scenario = await this.checkScenarioStatus(scenarioId);
            
            // 2. 檢查連接
            report.connections = await this.checkConnections(scenarioId);
            
            // 3. 檢查 Webhook
            report.webhooks = await this.checkWebhooks(scenarioId);
            
            // 4. 檢查最近執行
            report.executions = await this.checkRecentExecutions(scenarioId);
            
            // 5. 分析問題
            report.issues = this.analyzeIssues(report);
            
            return report;
        } catch (error) {
            report.issues.push({
                type: 'DIAGNOSTIC_ERROR',
                message: error.message
            });
            return report;
        }
    }

    async checkScenarioStatus(scenarioId) {
        const scenario = await api.get(`/v1/scenarios/${scenarioId}`);
        
        if (scenario.status === 'error') {
            this.addIssue('SCENARIO_ERROR', 'Scenario is in error state');
        }
        
        if (!scenario.webhook_url) {
            this.addIssue('NO_WEBHOOK', 'Scenario has no webhook URL');
        }
        
        return scenario;
    }

    async checkConnections(scenarioId) {
        const connections = await api.get(`/v1/scenarios/${scenarioId}/connections`);
        const issues = [];

        for (const connection of connections) {
            if (connection.status !== 'active') {
                issues.push({
                    connectionId: connection.id,
                    service: connection.service,
                    status: connection.status,
                    error: connection.error_message
                });
            }
        }

        return { connections, issues };
    }

    async checkWebhooks(scenarioId) {
        const webhook = await api.get(`/v1/scenarios/${scenarioId}/webhook`);
        
        // 測試 Webhook
        try {
            const testResponse = await fetch(webhook.url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Test-Request': 'true'
                },
                body: JSON.stringify({ test: true })
            });

            return {
                url: webhook.url,
                reachable: testResponse.ok,
                statusCode: testResponse.status,
                response: await testResponse.text()
            };
        } catch (error) {
            return {
                url: webhook.url,
                reachable: false,
                error: error.message
            };
        }
    }

    async checkRecentExecutions(scenarioId) {
        const executions = await api.get(`/v1/scenarios/${scenarioId}/executions`, {
            limit: 10,
            sort: 'desc'
        });

        const stats = {
            total: executions.length,
            successful: 0,
            failed: 0,
            errors: []
        };

        executions.forEach(exec => {
            if (exec.status === 'success') {
                stats.successful++;
            } else {
                stats.failed++;
                stats.errors.push({
                    executionId: exec.id,
                    error: exec.error_message,
                    timestamp: exec.completed_at
                });
            }
        });

        return stats;
    }
}
```

**問題：Webhook 接收不到資料**

解決方案：

```javascript
// Webhook 除錯中間件
function webhookDebugger() {
    return (req, res, next) => {
        console.log('=== Webhook Request Debug ===');
        console.log('URL:', req.url);
        console.log('Method:', req.method);
        console.log('Headers:', req.headers);
        console.log('Body:', req.body);
        console.log('Query:', req.query);
        console.log('IP:', req.ip);
        console.log('========================');
        
        // 儲存請求資訊供除錯
        saveWebhookRequest({
            timestamp: new Date(),
            url: req.url,
            method: req.method,
            headers: req.headers,
            body: req.body,
            query: req.query,
            ip: req.ip
        });
        
        next();
    };
}

// Webhook 處理器加入錯誤處理
app.post('/webhook/:path', webhookDebugger(), async (req, res) => {
    try {
        // 驗證 Webhook 路徑
        const webhookPath = req.params.path;
        const webhook = await getWebhookByPath(webhookPath);
        
        if (!webhook) {
            console.error('Webhook not found:', webhookPath);
            return res.status(404).json({ error: 'Webhook not found' });
        }
        
        // 轉發到 Make
        const makeResponse = await forwardToMake(webhook, req.body);
        
        res.json({
            success: true,
            executionId: makeResponse.executionId
        });
    } catch (error) {
        console.error('Webhook processing error:', error);
        
        // 記錄錯誤但仍回傳成功（避免第三方重試）
        res.status(200).json({
            success: false,
            error: error.message,
            timestamp: new Date()
        });
    }
});
```

### 12.1.3 效能問題

**問題：API 回應緩慢**

診斷與優化：

```javascript
// 效能監控中間件
const performanceMonitor = {
    middleware() {
        return async (req, res, next) => {
            const start = process.hrtime.bigint();
            
            // 監聽回應完成
            res.on('finish', () => {
                const end = process.hrtime.bigint();
                const duration = Number(end - start) / 1e6; // 轉換為毫秒
                
                // 記錄慢請求
                if (duration > 1000) {
                    console.warn('Slow request detected:', {
                        method: req.method,
                        url: req.url,
                        duration: `${duration}ms`,
                        statusCode: res.statusCode
                    });
                    
                    // 分析慢請求原因
                    this.analyzeSlowRequest(req, duration);
                }
                
                // 發送指標
                metrics.histogram('http_request_duration', duration, {
                    method: req.method,
                    path: req.route?.path || req.path,
                    status: res.statusCode
                });
            });
            
            next();
        };
    },

    async analyzeSlowRequest(req, duration) {
        const analysis = {
            url: req.url,
            duration,
            timestamp: new Date(),
            causes: []
        };

        // 檢查資料庫查詢
        if (req.dbQueries && req.dbQueries.length > 0) {
            const slowQueries = req.dbQueries.filter(q => q.duration > 100);
            if (slowQueries.length > 0) {
                analysis.causes.push({
                    type: 'SLOW_DB_QUERY',
                    queries: slowQueries
                });
            }
        }

        // 檢查外部 API 呼叫
        if (req.apiCalls && req.apiCalls.length > 0) {
            const slowAPIs = req.apiCalls.filter(c => c.duration > 500);
            if (slowAPIs.length > 0) {
                analysis.causes.push({
                    type: 'SLOW_API_CALL',
                    calls: slowAPIs
                });
            }
        }

        // 儲存分析結果
        await savePerformanceAnalysis(analysis);
    }
};

// 資料庫查詢優化
class DatabaseOptimizer {
    async optimizeSlowQueries() {
        // 獲取慢查詢日誌
        const slowQueries = await this.getSlowQueries();
        
        for (const query of slowQueries) {
            // 分析執行計劃
            const plan = await this.explainQuery(query.sql);
            
            // 建議優化
            const suggestions = this.analyzePlan(plan);
            
            console.log('Query Optimization Suggestions:', {
                query: query.sql,
                duration: query.duration,
                suggestions
            });
        }
    }

    analyzePlan(plan) {
        const suggestions = [];

        // 檢查全表掃描
        if (plan.includes('Seq Scan')) {
            suggestions.push('Consider adding an index');
        }

        // 檢查排序操作
        if (plan.includes('Sort') && !plan.includes('Index Scan')) {
            suggestions.push('Consider adding a sorted index');
        }

        // 檢查連接類型
        if (plan.includes('Nested Loop') && plan.rows > 1000) {
            suggestions.push('Consider using Hash Join for large datasets');
        }

        return suggestions;
    }
}
```

### 12.1.4 記憶體洩漏問題

**問題：應用程式記憶體使用持續增長**

診斷工具：

```javascript
// 記憶體監控
const memoryMonitor = {
    start() {
        setInterval(() => {
            const usage = process.memoryUsage();
            const report = {
                timestamp: new Date(),
                rss: Math.round(usage.rss / 1024 / 1024) + ' MB',
                heapTotal: Math.round(usage.heapTotal / 1024 / 1024) + ' MB',
                heapUsed: Math.round(usage.heapUsed / 1024 / 1024) + ' MB',
                external: Math.round(usage.external / 1024 / 1024) + ' MB'
            };

            console.log('Memory Usage:', report);

            // 檢查記憶體洩漏
            if (usage.heapUsed > 500 * 1024 * 1024) { // 500MB
                console.warn('High memory usage detected!');
                this.createHeapSnapshot();
            }
        }, 60000); // 每分鐘檢查一次
    },

    createHeapSnapshot() {
        const v8 = require('v8');
        const fs = require('fs');
        
        const filename = `heap-${Date.now()}.heapsnapshot`;
        const stream = fs.createWriteStream(filename);
        
        v8.writeHeapSnapshot(stream);
        console.log(`Heap snapshot written to ${filename}`);
    }
};

// 常見記憶體洩漏來源與修復
class MemoryLeakFixes {
    // 1. 事件監聽器洩漏
    fixEventListeners() {
        // 錯誤：忘記移除監聽器
        // emitter.on('data', handler);

        // 正確：使用 once 或記得移除
        emitter.once('data', handler);
        // 或
        emitter.on('data', handler);
        // 清理時
        emitter.removeListener('data', handler);
    }

    // 2. 定時器洩漏
    fixTimers() {
        const timers = new Set();

        // 建立定時器時記錄
        function createTimer(callback, delay) {
            const timer = setTimeout(() => {
                callback();
                timers.delete(timer);
            }, delay);
            
            timers.add(timer);
            return timer;
        }

        // 清理所有定時器
        function cleanup() {
            timers.forEach(timer => clearTimeout(timer));
            timers.clear();
        }
    }

    // 3. 快取無限增長
    fixCache() {
        class BoundedCache {
            constructor(maxSize = 1000) {
                this.cache = new Map();
                this.maxSize = maxSize;
            }

            set(key, value) {
                // 移除最舊的項目
                if (this.cache.size >= this.maxSize) {
                    const firstKey = this.cache.keys().next().value;
                    this.cache.delete(firstKey);
                }

                this.cache.set(key, {
                    value,
                    timestamp: Date.now()
                });
            }

            get(key) {
                const item = this.cache.get(key);
                return item ? item.value : null;
            }

            // 定期清理過期項目
            cleanup(maxAge = 3600000) { // 1小時
                const now = Date.now();
                
                for (const [key, item] of this.cache) {
                    if (now - item.timestamp > maxAge) {
                        this.cache.delete(key);
                    }
                }
            }
        }
    }
}
```

## 12.2 監控與告警

### 12.2.1 健康檢查端點

```javascript
// 健康檢查實作
class HealthChecker {
    constructor() {
        this.checks = new Map();
        this.registerDefaultChecks();
    }

    registerDefaultChecks() {
        // 資料庫連接檢查
        this.register('database', async () => {
            try {
                await db.query('SELECT 1');
                return { status: 'healthy' };
            } catch (error) {
                return { 
                    status: 'unhealthy', 
                    error: error.message 
                };
            }
        });

        // Redis 連接檢查
        this.register('redis', async () => {
            try {
                await redis.ping();
                return { status: 'healthy' };
            } catch (error) {
                return { 
                    status: 'unhealthy', 
                    error: error.message 
                };
            }
        });

        // Make API 連接檢查
        this.register('make-api', async () => {
            try {
                const response = await fetch('https://api.make.com/v1/health');
                return { 
                    status: response.ok ? 'healthy' : 'unhealthy',
                    statusCode: response.status
                };
            } catch (error) {
                return { 
                    status: 'unhealthy', 
                    error: error.message 
                };
            }
        });

        // 記憶體使用檢查
        this.register('memory', async () => {
            const usage = process.memoryUsage();
            const heapUsedMB = usage.heapUsed / 1024 / 1024;
            
            return {
                status: heapUsedMB < 500 ? 'healthy' : 'warning',
                heapUsed: `${Math.round(heapUsedMB)} MB`,
                heapTotal: `${Math.round(usage.heapTotal / 1024 / 1024)} MB`
            };
        });
    }

    register(name, checkFn) {
        this.checks.set(name, checkFn);
    }

    async runAll() {
        const results = {
            status: 'healthy',
            timestamp: new Date().toISOString(),
            checks: {}
        };

        for (const [name, checkFn] of this.checks) {
            try {
                results.checks[name] = await checkFn();
                
                if (results.checks[name].status === 'unhealthy') {
                    results.status = 'unhealthy';
                }
            } catch (error) {
                results.checks[name] = {
                    status: 'error',
                    error: error.message
                };
                results.status = 'unhealthy';
            }
        }

        return results;
    }
}

// Express 路由
app.get('/health', async (req, res) => {
    const health = await healthChecker.runAll();
    const statusCode = health.status === 'healthy' ? 200 : 503;
    
    res.status(statusCode).json(health);
});

// 詳細健康檢查
app.get('/health/detailed', authenticate, async (req, res) => {
    const detailed = await healthChecker.runAll();
    
    // 加入額外資訊
    detailed.metrics = {
        uptime: process.uptime(),
        requests: {
            total: metrics.get('http_requests_total'),
            errors: metrics.get('http_errors_total')
        },
        scenarios: {
            active: await getActiveScenarioCount(),
            executions: await getExecutionStats()
        }
    };

    res.json(detailed);
});
```

### 12.2.2 告警設定

```javascript
// 告警管理器
class AlertManager {
    constructor() {
        this.rules = [];
        this.channels = new Map();
        this.setupDefaultRules();
    }

    setupDefaultRules() {
        // CPU 使用率告警
        this.addRule({
            name: 'high-cpu-usage',
            condition: (metrics) => metrics.cpu.usage > 80,
            severity: 'warning',
            message: 'CPU usage is above 80%'
        });

        // 記憶體使用告警
        this.addRule({
            name: 'high-memory-usage',
            condition: (metrics) => metrics.memory.percentage > 90,
            severity: 'critical',
            message: 'Memory usage is above 90%'
        });

        // 錯誤率告警
        this.addRule({
            name: 'high-error-rate',
            condition: (metrics) => metrics.errors.rate > 5,
            severity: 'critical',
            message: 'Error rate is above 5%'
        });

        // API 延遲告警
        this.addRule({
            name: 'high-api-latency',
            condition: (metrics) => metrics.api.p95Latency > 1000,
            severity: 'warning',
            message: 'API p95 latency is above 1000ms'
        });
    }

    addRule(rule) {
        this.rules.push(rule);
    }

    async checkRules(metrics) {
        const alerts = [];

        for (const rule of this.rules) {
            if (rule.condition(metrics)) {
                const alert = {
                    rule: rule.name,
                    severity: rule.severity,
                    message: rule.message,
                    timestamp: new Date(),
                    metrics: metrics
                };

                alerts.push(alert);
                await this.sendAlert(alert);
            }
        }

        return alerts;
    }

    async sendAlert(alert) {
        // 發送到所有配置的頻道
        for (const [name, channel] of this.channels) {
            try {
                await channel.send(alert);
            } catch (error) {
                console.error(`Failed to send alert to ${name}:`, error);
            }
        }
    }

    // 配置告警頻道
    addChannel(name, channel) {
        this.channels.set(name, channel);
    }
}

// Slack 告警頻道
class SlackAlertChannel {
    constructor(webhookUrl) {
        this.webhookUrl = webhookUrl;
    }

    async send(alert) {
        const color = {
            'critical': '#FF0000',
            'warning': '#FFA500',
            'info': '#0000FF'
        }[alert.severity] || '#808080';

        const payload = {
            attachments: [{
                color,
                title: `🚨 ${alert.severity.toUpperCase()}: ${alert.rule}`,
                text: alert.message,
                fields: [
                    {
                        title: 'Timestamp',
                        value: alert.timestamp.toISOString(),
                        short: true
                    },
                    {
                        title: 'Environment',
                        value: process.env.NODE_ENV,
                        short: true
                    }
                ],
                footer: 'Make Bridge Alert System'
            }]
        };

        await fetch(this.webhookUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
    }
}

// Email 告警頻道
class EmailAlertChannel {
    constructor(config) {
        this.transporter = nodemailer.createTransport(config);
    }

    async send(alert) {
        const html = `
            <h2>Alert: ${alert.rule}</h2>
            <p><strong>Severity:</strong> ${alert.severity}</p>
            <p><strong>Message:</strong> ${alert.message}</p>
            <p><strong>Time:</strong> ${alert.timestamp.toISOString()}</p>
            <hr>
            <h3>Metrics:</h3>
            <pre>${JSON.stringify(alert.metrics, null, 2)}</pre>
        `;

        await this.transporter.sendMail({
            from: 'alerts@makebridge.com',
            to: process.env.ALERT_EMAIL,
            subject: `[${alert.severity.toUpperCase()}] ${alert.rule}`,
            html
        });
    }
}
```

## 12.3 日誌管理

### 12.3.1 結構化日誌

```javascript
// 日誌設定
const winston = require('winston');
const { format } = winston;

class Logger {
    constructor() {
        this.logger = winston.createLogger({
            level: process.env.LOG_LEVEL || 'info',
            format: format.combine(
                format.timestamp(),
                format.errors({ stack: true }),
                format.metadata(),
                format.json()
            ),
            defaultMeta: {
                service: 'make-bridge',
                environment: process.env.NODE_ENV,
                version: process.env.APP_VERSION
            },
            transports: this.getTransports()
        });
    }

    getTransports() {
        const transports = [];

        // 控制台輸出（開發環境）
        if (process.env.NODE_ENV !== 'production') {
            transports.push(new winston.transports.Console({
                format: format.combine(
                    format.colorize(),
                    format.printf(info => {
                        const { timestamp, level, message, ...meta } = info;
                        return `${timestamp} ${level}: ${message} ${
                            Object.keys(meta).length ? JSON.stringify(meta) : ''
                        }`;
                    })
                )
            }));
        }

        // 檔案輸出
        transports.push(new winston.transports.File({
            filename: 'logs/error.log',
            level: 'error',
            maxsize: 10485760, // 10MB
            maxFiles: 5,
            tailable: true
        }));

        transports.push(new winston.transports.File({
            filename: 'logs/combined.log',
            maxsize: 10485760,
            maxFiles: 5,
            tailable: true
        }));

        return transports;
    }

    // 請求日誌
    logRequest(req, res, duration) {
        this.logger.info('HTTP Request', {
            method: req.method,
            path: req.path,
            query: req.query,
            statusCode: res.statusCode,
            duration,
            userAgent: req.headers['user-agent'],
            ip: req.ip,
            userId: req.user?.id
        });
    }

    // 錯誤日誌
    logError(error, context = {}) {
        this.logger.error(error.message, {
            ...context,
            stack: error.stack,
            name: error.name,
            code: error.code
        });
    }

    // 審計日誌
    logAudit(action, userId, details) {
        this.logger.info('Audit Log', {
            type: 'audit',
            action,
            userId,
            details,
            timestamp: new Date().toISOString()
        });
    }

    // 效能日誌
    logPerformance(operation, duration, metadata = {}) {
        this.logger.info('Performance', {
            type: 'performance',
            operation,
            duration,
            ...metadata
        });
    }
}

// 日誌搜尋工具
class LogSearcher {
    async search(criteria) {
        const { 
            level, 
            startTime, 
            endTime, 
            message, 
            userId,
            limit = 100 
        } = criteria;

        const command = this.buildGrepCommand(criteria);
        const results = await exec(command);
        
        return this.parseLogResults(results);
    }

    buildGrepCommand(criteria) {
        let command = 'grep';
        
        if (criteria.message) {
            command += ` -i "${criteria.message}"`;
        }
        
        if (criteria.userId) {
            command += ` | grep "userId.*${criteria.userId}"`;
        }
        
        if (criteria.level) {
            command += ` | grep "level.*${criteria.level}"`;
        }
        
        command += ` logs/combined.log | tail -n ${criteria.limit}`;
        
        return command;
    }

    parseLogResults(rawOutput) {
        const lines = rawOutput.split('\n');
        return lines
            .filter(line => line.trim())
            .map(line => {
                try {
                    return JSON.parse(line);
                } catch {
                    return { raw: line };
                }
            });
    }
}
```

### 12.3.2 日誌分析

```javascript
// 日誌分析器
class LogAnalyzer {
    async analyzeErrorPatterns(timeRange) {
        const errors = await this.getErrorLogs(timeRange);
        const patterns = new Map();

        errors.forEach(error => {
            const pattern = this.extractErrorPattern(error);
            
            if (!patterns.has(pattern)) {
                patterns.set(pattern, {
                    count: 0,
                    firstSeen: error.timestamp,
                    lastSeen: error.timestamp,
                    examples: []
                });
            }

            const data = patterns.get(pattern);
            data.count++;
            data.lastSeen = error.timestamp;
            
            if (data.examples.length < 5) {
                data.examples.push(error);
            }
        });

        return this.formatPatternReport(patterns);
    }

    extractErrorPattern(error) {
        // 移除動態資訊
        let pattern = error.message;
        
        // 移除 ID
        pattern = pattern.replace(/[a-f0-9]{24}/gi, '[ID]');
        
        // 移除數字
        pattern = pattern.replace(/\d+/g, '[NUM]');
        
        // 移除 URL
        pattern = pattern.replace(/https?:\/\/[^\s]+/g, '[URL]');
        
        return pattern;
    }

    async generateDailyReport() {
        const report = {
            date: new Date().toISOString().split('T')[0],
            summary: {
                totalRequests: 0,
                errorCount: 0,
                errorRate: 0,
                avgResponseTime: 0,
                uniqueUsers: new Set(),
                topEndpoints: new Map()
            },
            errors: [],
            performance: [],
            alerts: []
        };

        // 分析日誌
        const logs = await this.getTodayLogs();
        
        logs.forEach(log => {
            if (log.type === 'request') {
                report.summary.totalRequests++;
                report.summary.uniqueUsers.add(log.userId);
                
                const endpoint = `${log.method} ${log.path}`;
                const count = report.summary.topEndpoints.get(endpoint) || 0;
                report.summary.topEndpoints.set(endpoint, count + 1);
            }
            
            if (log.level === 'error') {
                report.summary.errorCount++;
                report.errors.push(log);
            }
        });

        report.summary.errorRate = 
            (report.summary.errorCount / report.summary.totalRequests) * 100;

        return report;
    }
}
```

## 12.4 備份與恢復

### 12.4.1 自動備份策略

```javascript
// 備份管理器
class BackupManager {
    constructor() {
        this.scheduleBackups();
    }

    scheduleBackups() {
        // 每日備份
        cron.schedule('0 2 * * *', async () => {
            console.log('Starting daily backup...');
            await this.performBackup('daily');
        });

        // 每週備份
        cron.schedule('0 3 * * 0', async () => {
            console.log('Starting weekly backup...');
            await this.performBackup('weekly');
        });

        // 每月備份
        cron.schedule('0 4 1 * *', async () => {
            console.log('Starting monthly backup...');
            await this.performBackup('monthly');
        });
    }

    async performBackup(type) {
        const timestamp = new Date().toISOString().replace(/[:]/g, '-');
        const backupDir = `backups/${type}/${timestamp}`;

        try {
            // 建立備份目錄
            await fs.mkdir(backupDir, { recursive: true });

            // 備份資料庫
            await this.backupDatabase(backupDir);

            // 備份設定檔
            await this.backupConfigs(backupDir);

            // 備份日誌
            await this.backupLogs(backupDir);

            // 壓縮備份
            await this.compressBackup(backupDir);

            // 上傳到雲端
            await this.uploadBackup(`${backupDir}.tar.gz`);

            // 清理舊備份
            await this.cleanupOldBackups(type);

            console.log(`Backup completed: ${backupDir}`);
        } catch (error) {
            console.error('Backup failed:', error);
            await this.notifyBackupFailure(error);
        }
    }

    async backupDatabase(backupDir) {
        const command = `pg_dump ${process.env.DATABASE_URL} > ${backupDir}/database.sql`;
        await exec(command);
    }

    async backupConfigs(backupDir) {
        const configs = [
            '.env',
            'config/',
            'package.json',
            'package-lock.json'
        ];

        for (const config of configs) {
            await fs.cp(config, `${backupDir}/${config}`, { recursive: true });
        }
    }

    async backupLogs(backupDir) {
        await fs.cp('logs/', `${backupDir}/logs/`, { recursive: true });
    }

    async compressBackup(backupDir) {
        const command = `tar -czf ${backupDir}.tar.gz -C ${path.dirname(backupDir)} ${path.basename(backupDir)}`;
        await exec(command);
        
        // 刪除未壓縮的備份
        await fs.rm(backupDir, { recursive: true });
    }

    async uploadBackup(filePath) {
        // 上傳到 S3
        const s3 = new AWS.S3();
        const fileStream = fs.createReadStream(filePath);
        const key = `make-bridge-backups/${filePath}`;

        await s3.upload({
            Bucket: process.env.BACKUP_BUCKET,
            Key: key,
            Body: fileStream,
            ServerSideEncryption: 'AES256'
        }).promise();
    }

    async cleanupOldBackups(type) {
        const retentionDays = {
            daily: 7,
            weekly: 30,
            monthly: 365
        };

        const cutoffDate = new Date();
        cutoffDate.setDate(cutoffDate.getDate() - retentionDays[type]);

        const backups = await fs.readdir(`backups/${type}/`);
        
        for (const backup of backups) {
            const backupDate = new Date(backup.split('.')[0]);
            if (backupDate < cutoffDate) {
                await fs.rm(`backups/${type}/${backup}`);
            }
        }
    }
}
```

### 12.4.2 災難恢復程序

```javascript
// 恢復管理器
class RecoveryManager {
    async restoreFromBackup(backupPath) {
        console.log(`Starting recovery from ${backupPath}`);
        
        try {
            // 1. 解壓備份
            const tempDir = await this.extractBackup(backupPath);
            
            // 2. 停止服務
            await this.stopServices();
            
            // 3. 恢復資料庫
            await this.restoreDatabase(`${tempDir}/database.sql`);
            
            // 4. 恢復設定
            await this.restoreConfigs(tempDir);
            
            // 5. 驗證恢復
            await this.verifyRecovery();
            
            // 6. 重新啟動服務
            await this.startServices();
            
            console.log('Recovery completed successfully');
        } catch (error) {
            console.error('Recovery failed:', error);
            await this.rollback();
            throw error;
        }
    }

    async extractBackup(backupPath) {
        const tempDir = `/tmp/recovery-${Date.now()}`;
        await fs.mkdir(tempDir);
        
        const command = `tar -xzf ${backupPath} -C ${tempDir}`;
        await exec(command);
        
        return tempDir;
    }

    async stopServices() {
        console.log('Stopping services...');
        await exec('pm2 stop all');
    }

    async restoreDatabase(sqlPath) {
        console.log('Restoring database...');
        
        // 建立備份
        await exec(`pg_dump ${process.env.DATABASE_URL} > /tmp/pre-recovery-backup.sql`);
        
        // 恢復資料庫
        await exec(`psql ${process.env.DATABASE_URL} < ${sqlPath}`);
    }

    async restoreConfigs(tempDir) {
        console.log('Restoring configurations...');
        
        // 備份當前設定
        await fs.cp('.env', '.env.pre-recovery');
        
        // 恢復設定
        await fs.cp(`${tempDir}/.env`, '.env');
        await fs.cp(`${tempDir}/config/`, 'config/', { recursive: true });
    }

    async verifyRecovery() {
        console.log('Verifying recovery...');
        
        const checks = [
            this.checkDatabaseConnection(),
            this.checkAPIEndpoints(),
            this.checkDataIntegrity()
        ];

        const results = await Promise.all(checks);
        
        if (results.some(r => !r.success)) {
            throw new Error('Recovery verification failed');
        }
    }

    async rollback() {
        console.log('Rolling back...');
        
        try {
            // 恢復原始資料庫
            await exec(`psql ${process.env.DATABASE_URL} < /tmp/pre-recovery-backup.sql`);
            
            // 恢復原始設定
            await fs.cp('.env.pre-recovery', '.env');
            
            // 重新啟動服務
            await this.startServices();
        } catch (error) {
            console.error('Rollback failed:', error);
        }
    }
}
```

## 12.5 安全性維護

### 12.5.1 安全更新流程

```javascript
// 安全掃描器
class SecurityScanner {
    async scanDependencies() {
        console.log('Scanning dependencies for vulnerabilities...');
        
        // npm audit
        const npmAudit = await exec('npm audit --json');
        const auditResult = JSON.parse(npmAudit);
        
        if (auditResult.vulnerabilities) {
            console.log('Vulnerabilities found:', auditResult.metadata.vulnerabilities);
            
            // 嘗試自動修復
            if (auditResult.metadata.vulnerabilities.total > 0) {
                console.log('Attempting automatic fix...');
                await exec('npm audit fix');
            }
        }

        return auditResult;
    }

    async scanCode() {
        console.log('Scanning code for security issues...');
        
        // 使用 ESLint security plugin
        const eslintResult = await exec('eslint . --plugin security --format json');
        
        return JSON.parse(eslintResult);
    }

    async scanSecrets() {
        console.log('Scanning for exposed secrets...');
        
        // 使用 git-secrets 或類似工具
        const patterns = [
            /api[_-]?key/i,
            /secret[_-]?key/i,
            /password/i,
            /token/i,
            /private[_-]?key/i
        ];

        const files = await this.getAllFiles();
        const issues = [];

        for (const file of files) {
            const content = await fs.readFile(file, 'utf-8');
            
            patterns.forEach(pattern => {
                if (pattern.test(content)) {
                    const lines = content.split('\n');
                    lines.forEach((line, index) => {
                        if (pattern.test(line)) {
                            issues.push({
                                file,
                                line: index + 1,
                                pattern: pattern.toString(),
                                content: line.substring(0, 100)
                            });
                        }
                    });
                }
            });
        }

        return issues;
    }
}

// 安全更新管理
class SecurityUpdateManager {
    async checkUpdates() {
        const updates = {
            system: await this.checkSystemUpdates(),
            node: await this.checkNodeUpdates(),
            dependencies: await this.checkDependencyUpdates()
        };

        return updates;
    }

    async applySecurityPatches() {
        console.log('Applying security patches...');
        
        // 1. 備份當前狀態
        await this.createBackup();
        
        // 2. 更新系統套件
        await exec('apt-get update && apt-get upgrade -y');
        
        // 3. 更新 Node.js
        await this.updateNode();
        
        // 4. 更新依賴
        await exec('npm update');
        
        // 5. 重新測試
        await exec('npm test');
        
        // 6. 重新部署
        await this.redeploy();
    }
}
```

### 12.5.2 存取控制審計

```javascript
// 存取審計器
class AccessAuditor {
    async auditPermissions() {
        const report = {
            timestamp: new Date(),
            users: await this.auditUserPermissions(),
            apiKeys: await this.auditAPIKeys(),
            tokens: await this.auditTokens(),
            recommendations: []
        };

        // 分析並產生建議
        this.analyzeAndRecommend(report);
        
        return report;
    }

    async auditUserPermissions() {
        const users = await db.query('SELECT * FROM users');
        const issues = [];

        for (const user of users) {
            // 檢查過度權限
            if (user.role === 'admin' && !user.admin_approved) {
                issues.push({
                    userId: user.id,
                    issue: 'Unapproved admin access',
                    severity: 'high'
                });
            }

            // 檢查休眠帳戶
            const lastActivity = new Date(user.last_activity);
            const daysSinceActivity = (Date.now() - lastActivity) / (1000 * 60 * 60 * 24);
            
            if (daysSinceActivity > 90) {
                issues.push({
                    userId: user.id,
                    issue: 'Dormant account',
                    severity: 'medium',
                    lastActivity: user.last_activity
                });
            }
        }

        return issues;
    }

    async auditAPIKeys() {
        const apiKeys = await db.query('SELECT * FROM api_keys');
        const issues = [];

        for (const key of apiKeys) {
            // 檢查過期金鑰
            if (new Date(key.expires_at) < new Date()) {
                issues.push({
                    keyId: key.id,
                    issue: 'Expired API key still active',
                    severity: 'high'
                });
            }

            // 檢查未使用的金鑰
            if (!key.last_used) {
                issues.push({
                    keyId: key.id,
                    issue: 'API key never used',
                    severity: 'low'
                });
            }
        }

        return issues;
    }
}
```

## 12.6 效能調優

### 12.6.1 資料庫優化

```sql
-- 建立必要的索引
CREATE INDEX idx_scenarios_user_id ON scenarios(user_id);
CREATE INDEX idx_scenarios_status ON scenarios(status);
CREATE INDEX idx_scenarios_created_at ON scenarios(created_at DESC);
CREATE INDEX idx_executions_scenario_id ON executions(scenario_id);
CREATE INDEX idx_executions_status ON executions(status);

-- 複合索引
CREATE INDEX idx_scenarios_user_status ON scenarios(user_id, status);
CREATE INDEX idx_executions_scenario_status ON executions(scenario_id, status);

-- 分析查詢效能
EXPLAIN ANALYZE 
SELECT s.*, COUNT(e.id) as execution_count
FROM scenarios s
LEFT JOIN executions e ON s.id = e.scenario_id
WHERE s.user_id = 'user_123'
  AND s.status = 'active'
GROUP BY s.id
ORDER BY s.created_at DESC
LIMIT 20;
```

### 12.6.2 快取優化

```javascript
// 智慧快取策略
class SmartCache {
    constructor() {
        this.cache = new NodeCache({
            stdTTL: 600, // 10分鐘預設 TTL
            checkperiod: 120, // 每2分鐘檢查過期
            useClones: false // 效能優化
        });
        
        this.hitRate = 0;
        this.missRate = 0;
    }

    async get(key, fetchFn, options = {}) {
        const cached = this.cache.get(key);
        
        if (cached !== undefined) {
            this.hitRate++;
            return cached;
        }

        this.missRate++;
        
        // 防止快取擊穿
        const lock = await this.acquireLock(key);
        if (!lock) {
            // 等待其他請求完成
            await this.waitForLock(key);
            return this.cache.get(key);
        }

        try {
            const data = await fetchFn();
            
            // 根據資料特性調整 TTL
            const ttl = this.calculateTTL(key, data, options);
            this.cache.set(key, data, ttl);
            
            return data;
        } finally {
            await this.releaseLock(key);
        }
    }

    calculateTTL(key, data, options) {
        // 根據不同類型的資料使用不同的 TTL
        if (key.startsWith('user:')) {
            return 300; // 使用者資料 5分鐘
        } else if (key.startsWith('scenario:')) {
            return 600; // 場景資料 10分鐘
        } else if (key.startsWith('stats:')) {
            return 60; // 統計資料 1分鐘
        }
        
        return options.ttl || 600;
    }

    getStats() {
        const total = this.hitRate + this.missRate;
        return {
            hitRate: this.hitRate,
            missRate: this.missRate,
            hitRatio: total > 0 ? (this.hitRate / total) * 100 : 0,
            keys: this.cache.keys().length,
            size: this.cache.getStats()
        };
    }
}
```

## 總結

本章提供了完整的疑難排解和維護指南，涵蓋：

1. **常見問題解決**：初始化、執行、效能和記憶體問題
2. **監控告警**：健康檢查、告警規則、通知管道
3. **日誌管理**：結構化日誌、日誌分析、搜尋工具
4. **備份恢復**：自動備份、災難恢復、資料完整性
5. **安全維護**：漏洞掃描、安全更新、存取審計
6. **效能調優**：資料庫優化、快取策略、資源管理

遵循這些最佳實踐，可以確保 Make Bridge 整合的穩定性和可靠性。

## 🎯 完成學習旅程

恭喜您完成了 Make Bridge 的完整學習！經過這 13 個章節的深入探索，您已經掌握了：

✅ **核心概念**：深入理解 Make Bridge 的架構和運作原理  
✅ **實作技能**：能夠獨立開發和部署 Make Bridge 整合  
✅ **進階應用**：掌握企業級的架構設計和最佳實踐  
✅ **維護能力**：具備監控、除錯和優化的專業技能  

### 📚 持續學習資源

- **官方文檔**：持續關注 Make.com 的更新和新功能
- **社群論壇**：參與討論，分享經驗，學習他人的最佳實踐
- **GitHub 專案**：查看開源專案，貢獻您的程式碼
- **技術部落格**：撰寫和分享您的 Make Bridge 開發經驗

### 🚀 下一步建議

1. **實戰專案**：選擇一個真實的業務場景，實作完整的解決方案
2. **優化現有系統**：使用本書的知識改進您現有的整合
3. **分享知識**：將您的經驗分享給團隊或社群
4. **持續創新**：探索 Make Bridge 與新技術的結合可能

感謝您選擇本教程作為學習 Make Bridge 的指南。祝您在自動化整合的道路上取得成功！

如需更多參考資訊，請查閱**附錄：詞彙表與參考資源**。