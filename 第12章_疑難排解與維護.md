# ç¬¬åäºŒç« ï¼šç–‘é›£æ’è§£èˆ‡ç¶­è­·

## æœ¬ç« æ¦‚è¿°

æœ¬ç« æä¾›å®Œæ•´çš„ç–‘é›£æ’è§£æŒ‡å—å’Œç¶­è­·æœ€ä½³å¯¦è¸ï¼Œå¹«åŠ©é–‹ç™¼è€…å¿«é€Ÿè§£æ±ºå¸¸è¦‹å•é¡Œï¼Œä¸¦ç¢ºä¿ Make Bridge æ•´åˆçš„é•·æœŸç©©å®šé‹è¡Œã€‚

## 12.1 å¸¸è¦‹å•é¡Œèˆ‡è§£æ±ºæ–¹æ¡ˆ

### 12.1.1 åˆå§‹åŒ–å•é¡Œ

**å•é¡Œï¼šBridge åˆå§‹åŒ–å¤±æ•—**

ç—‡ç‹€ï¼š
- æ”¶åˆ° 401 æˆ– 403 éŒ¯èª¤
- JWT token ç„¡æ³•é©—è­‰
- æ•´åˆä»‹é¢ç„¡æ³•è¼‰å…¥

è§£æ±ºæ­¥é©Ÿï¼š

```javascript
// 1. æª¢æŸ¥ JWT ç”Ÿæˆ
function debugJWT() {
    const payload = {
        sub: userId,
        jti: crypto.randomUUID(),
    };
    
    console.log('JWT Payload:', payload);
    console.log('Secret Key exists:', !!process.env.JWT_SECRET);
    console.log('Key ID:', process.env.KEY_ID);
    
    try {
        const token = jwt.sign(payload, process.env.JWT_SECRET, {
            expiresIn: '2m',
            keyid: process.env.KEY_ID,
            algorithm: 'HS256'
        });
        
        console.log('Generated token:', token);
        
        // é©—è­‰ token
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        console.log('Decoded token:', decoded);
        
        return token;
    } catch (error) {
        console.error('JWT Error:', error);
        return null;
    }
}

// 2. æª¢æŸ¥ç’°å¢ƒè®Šæ•¸
function checkEnvironment() {
    const required = ['JWT_SECRET', 'KEY_ID', 'APP_ID'];
    const missing = required.filter(key => !process.env[key]);
    
    if (missing.length > 0) {
        console.error('Missing environment variables:', missing);
        return false;
    }
    
    return true;
}

// 3. æ¸¬è©¦ API é€£æ¥
async function testAPIConnection() {
    try {
        const response = await fetch('https://api.make.com/v1/health');
        const data = await response.json();
        console.log('API Health:', data);
        return response.ok;
    } catch (error) {
        console.error('API Connection Error:', error);
        return false;
    }
}
```

**å•é¡Œï¼šCORS éŒ¯èª¤**

ç—‡ç‹€ï¼š
- ç€è¦½å™¨æ§åˆ¶å°é¡¯ç¤º CORS éŒ¯èª¤
- é æª¢è«‹æ±‚å¤±æ•—

è§£æ±ºæ–¹æ¡ˆï¼š

```javascript
// Express.js CORS è¨­å®š
const cors = require('cors');

app.use(cors({
    origin: [
        'https://integrations.make.com',
        'https://api.make.com',
        process.env.FRONTEND_URL
    ],
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization', 'X-API-Key'],
    maxAge: 86400 // 24å°æ™‚
}));

// æ‰‹å‹•è™•ç† OPTIONS è«‹æ±‚
app.options('*', (req, res) => {
    res.header('Access-Control-Allow-Origin', req.headers.origin);
    res.header('Access-Control-Allow-Methods', 'GET,POST,PUT,DELETE,OPTIONS');
    res.header('Access-Control-Allow-Headers', 'Content-Type,Authorization');
    res.header('Access-Control-Allow-Credentials', 'true');
    res.sendStatus(200);
});
```

### 12.1.2 å ´æ™¯åŸ·è¡Œå•é¡Œ

**å•é¡Œï¼šå ´æ™¯åŸ·è¡Œå¤±æ•—**

ç—‡ç‹€ï¼š
- å ´æ™¯ç‹€æ…‹é¡¯ç¤ºéŒ¯èª¤
- Webhook ç„¡å›æ‡‰
- åŸ·è¡Œè¶…æ™‚

è¨ºæ–·å·¥å…·ï¼š

```javascript
// å ´æ™¯è¨ºæ–·å·¥å…·
class ScenarioDiagnostics {
    async diagnose(scenarioId) {
        const report = {
            scenario: null,
            connections: [],
            webhooks: [],
            executions: [],
            issues: []
        };

        try {
            // 1. æª¢æŸ¥å ´æ™¯ç‹€æ…‹
            report.scenario = await this.checkScenarioStatus(scenarioId);
            
            // 2. æª¢æŸ¥é€£æ¥
            report.connections = await this.checkConnections(scenarioId);
            
            // 3. æª¢æŸ¥ Webhook
            report.webhooks = await this.checkWebhooks(scenarioId);
            
            // 4. æª¢æŸ¥æœ€è¿‘åŸ·è¡Œ
            report.executions = await this.checkRecentExecutions(scenarioId);
            
            // 5. åˆ†æå•é¡Œ
            report.issues = this.analyzeIssues(report);
            
            return report;
        } catch (error) {
            report.issues.push({
                type: 'DIAGNOSTIC_ERROR',
                message: error.message
            });
            return report;
        }
    }

    async checkScenarioStatus(scenarioId) {
        const scenario = await api.get(`/v1/scenarios/${scenarioId}`);
        
        if (scenario.status === 'error') {
            this.addIssue('SCENARIO_ERROR', 'Scenario is in error state');
        }
        
        if (!scenario.webhook_url) {
            this.addIssue('NO_WEBHOOK', 'Scenario has no webhook URL');
        }
        
        return scenario;
    }

    async checkConnections(scenarioId) {
        const connections = await api.get(`/v1/scenarios/${scenarioId}/connections`);
        const issues = [];

        for (const connection of connections) {
            if (connection.status !== 'active') {
                issues.push({
                    connectionId: connection.id,
                    service: connection.service,
                    status: connection.status,
                    error: connection.error_message
                });
            }
        }

        return { connections, issues };
    }

    async checkWebhooks(scenarioId) {
        const webhook = await api.get(`/v1/scenarios/${scenarioId}/webhook`);
        
        // æ¸¬è©¦ Webhook
        try {
            const testResponse = await fetch(webhook.url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Test-Request': 'true'
                },
                body: JSON.stringify({ test: true })
            });

            return {
                url: webhook.url,
                reachable: testResponse.ok,
                statusCode: testResponse.status,
                response: await testResponse.text()
            };
        } catch (error) {
            return {
                url: webhook.url,
                reachable: false,
                error: error.message
            };
        }
    }

    async checkRecentExecutions(scenarioId) {
        const executions = await api.get(`/v1/scenarios/${scenarioId}/executions`, {
            limit: 10,
            sort: 'desc'
        });

        const stats = {
            total: executions.length,
            successful: 0,
            failed: 0,
            errors: []
        };

        executions.forEach(exec => {
            if (exec.status === 'success') {
                stats.successful++;
            } else {
                stats.failed++;
                stats.errors.push({
                    executionId: exec.id,
                    error: exec.error_message,
                    timestamp: exec.completed_at
                });
            }
        });

        return stats;
    }
}
```

**å•é¡Œï¼šWebhook æ¥æ”¶ä¸åˆ°è³‡æ–™**

è§£æ±ºæ–¹æ¡ˆï¼š

```javascript
// Webhook é™¤éŒ¯ä¸­é–“ä»¶
function webhookDebugger() {
    return (req, res, next) => {
        console.log('=== Webhook Request Debug ===');
        console.log('URL:', req.url);
        console.log('Method:', req.method);
        console.log('Headers:', req.headers);
        console.log('Body:', req.body);
        console.log('Query:', req.query);
        console.log('IP:', req.ip);
        console.log('========================');
        
        // å„²å­˜è«‹æ±‚è³‡è¨Šä¾›é™¤éŒ¯
        saveWebhookRequest({
            timestamp: new Date(),
            url: req.url,
            method: req.method,
            headers: req.headers,
            body: req.body,
            query: req.query,
            ip: req.ip
        });
        
        next();
    };
}

// Webhook è™•ç†å™¨åŠ å…¥éŒ¯èª¤è™•ç†
app.post('/webhook/:path', webhookDebugger(), async (req, res) => {
    try {
        // é©—è­‰ Webhook è·¯å¾‘
        const webhookPath = req.params.path;
        const webhook = await getWebhookByPath(webhookPath);
        
        if (!webhook) {
            console.error('Webhook not found:', webhookPath);
            return res.status(404).json({ error: 'Webhook not found' });
        }
        
        // è½‰ç™¼åˆ° Make
        const makeResponse = await forwardToMake(webhook, req.body);
        
        res.json({
            success: true,
            executionId: makeResponse.executionId
        });
    } catch (error) {
        console.error('Webhook processing error:', error);
        
        // è¨˜éŒ„éŒ¯èª¤ä½†ä»å›å‚³æˆåŠŸï¼ˆé¿å…ç¬¬ä¸‰æ–¹é‡è©¦ï¼‰
        res.status(200).json({
            success: false,
            error: error.message,
            timestamp: new Date()
        });
    }
});
```

### 12.1.3 æ•ˆèƒ½å•é¡Œ

**å•é¡Œï¼šAPI å›æ‡‰ç·©æ…¢**

è¨ºæ–·èˆ‡å„ªåŒ–ï¼š

```javascript
// æ•ˆèƒ½ç›£æ§ä¸­é–“ä»¶
const performanceMonitor = {
    middleware() {
        return async (req, res, next) => {
            const start = process.hrtime.bigint();
            
            // ç›£è½å›æ‡‰å®Œæˆ
            res.on('finish', () => {
                const end = process.hrtime.bigint();
                const duration = Number(end - start) / 1e6; // è½‰æ›ç‚ºæ¯«ç§’
                
                // è¨˜éŒ„æ…¢è«‹æ±‚
                if (duration > 1000) {
                    console.warn('Slow request detected:', {
                        method: req.method,
                        url: req.url,
                        duration: `${duration}ms`,
                        statusCode: res.statusCode
                    });
                    
                    // åˆ†ææ…¢è«‹æ±‚åŸå› 
                    this.analyzeSlowRequest(req, duration);
                }
                
                // ç™¼é€æŒ‡æ¨™
                metrics.histogram('http_request_duration', duration, {
                    method: req.method,
                    path: req.route?.path || req.path,
                    status: res.statusCode
                });
            });
            
            next();
        };
    },

    async analyzeSlowRequest(req, duration) {
        const analysis = {
            url: req.url,
            duration,
            timestamp: new Date(),
            causes: []
        };

        // æª¢æŸ¥è³‡æ–™åº«æŸ¥è©¢
        if (req.dbQueries && req.dbQueries.length > 0) {
            const slowQueries = req.dbQueries.filter(q => q.duration > 100);
            if (slowQueries.length > 0) {
                analysis.causes.push({
                    type: 'SLOW_DB_QUERY',
                    queries: slowQueries
                });
            }
        }

        // æª¢æŸ¥å¤–éƒ¨ API å‘¼å«
        if (req.apiCalls && req.apiCalls.length > 0) {
            const slowAPIs = req.apiCalls.filter(c => c.duration > 500);
            if (slowAPIs.length > 0) {
                analysis.causes.push({
                    type: 'SLOW_API_CALL',
                    calls: slowAPIs
                });
            }
        }

        // å„²å­˜åˆ†æçµæœ
        await savePerformanceAnalysis(analysis);
    }
};

// è³‡æ–™åº«æŸ¥è©¢å„ªåŒ–
class DatabaseOptimizer {
    async optimizeSlowQueries() {
        // ç²å–æ…¢æŸ¥è©¢æ—¥èªŒ
        const slowQueries = await this.getSlowQueries();
        
        for (const query of slowQueries) {
            // åˆ†æåŸ·è¡Œè¨ˆåŠƒ
            const plan = await this.explainQuery(query.sql);
            
            // å»ºè­°å„ªåŒ–
            const suggestions = this.analyzePlan(plan);
            
            console.log('Query Optimization Suggestions:', {
                query: query.sql,
                duration: query.duration,
                suggestions
            });
        }
    }

    analyzePlan(plan) {
        const suggestions = [];

        // æª¢æŸ¥å…¨è¡¨æƒæ
        if (plan.includes('Seq Scan')) {
            suggestions.push('Consider adding an index');
        }

        // æª¢æŸ¥æ’åºæ“ä½œ
        if (plan.includes('Sort') && !plan.includes('Index Scan')) {
            suggestions.push('Consider adding a sorted index');
        }

        // æª¢æŸ¥é€£æ¥é¡å‹
        if (plan.includes('Nested Loop') && plan.rows > 1000) {
            suggestions.push('Consider using Hash Join for large datasets');
        }

        return suggestions;
    }
}
```

### 12.1.4 è¨˜æ†¶é«”æ´©æ¼å•é¡Œ

**å•é¡Œï¼šæ‡‰ç”¨ç¨‹å¼è¨˜æ†¶é«”ä½¿ç”¨æŒçºŒå¢é•·**

è¨ºæ–·å·¥å…·ï¼š

```javascript
// è¨˜æ†¶é«”ç›£æ§
const memoryMonitor = {
    start() {
        setInterval(() => {
            const usage = process.memoryUsage();
            const report = {
                timestamp: new Date(),
                rss: Math.round(usage.rss / 1024 / 1024) + ' MB',
                heapTotal: Math.round(usage.heapTotal / 1024 / 1024) + ' MB',
                heapUsed: Math.round(usage.heapUsed / 1024 / 1024) + ' MB',
                external: Math.round(usage.external / 1024 / 1024) + ' MB'
            };

            console.log('Memory Usage:', report);

            // æª¢æŸ¥è¨˜æ†¶é«”æ´©æ¼
            if (usage.heapUsed > 500 * 1024 * 1024) { // 500MB
                console.warn('High memory usage detected!');
                this.createHeapSnapshot();
            }
        }, 60000); // æ¯åˆ†é˜æª¢æŸ¥ä¸€æ¬¡
    },

    createHeapSnapshot() {
        const v8 = require('v8');
        const fs = require('fs');
        
        const filename = `heap-${Date.now()}.heapsnapshot`;
        const stream = fs.createWriteStream(filename);
        
        v8.writeHeapSnapshot(stream);
        console.log(`Heap snapshot written to ${filename}`);
    }
};

// å¸¸è¦‹è¨˜æ†¶é«”æ´©æ¼ä¾†æºèˆ‡ä¿®å¾©
class MemoryLeakFixes {
    // 1. äº‹ä»¶ç›£è½å™¨æ´©æ¼
    fixEventListeners() {
        // éŒ¯èª¤ï¼šå¿˜è¨˜ç§»é™¤ç›£è½å™¨
        // emitter.on('data', handler);

        // æ­£ç¢ºï¼šä½¿ç”¨ once æˆ–è¨˜å¾—ç§»é™¤
        emitter.once('data', handler);
        // æˆ–
        emitter.on('data', handler);
        // æ¸…ç†æ™‚
        emitter.removeListener('data', handler);
    }

    // 2. å®šæ™‚å™¨æ´©æ¼
    fixTimers() {
        const timers = new Set();

        // å»ºç«‹å®šæ™‚å™¨æ™‚è¨˜éŒ„
        function createTimer(callback, delay) {
            const timer = setTimeout(() => {
                callback();
                timers.delete(timer);
            }, delay);
            
            timers.add(timer);
            return timer;
        }

        // æ¸…ç†æ‰€æœ‰å®šæ™‚å™¨
        function cleanup() {
            timers.forEach(timer => clearTimeout(timer));
            timers.clear();
        }
    }

    // 3. å¿«å–ç„¡é™å¢é•·
    fixCache() {
        class BoundedCache {
            constructor(maxSize = 1000) {
                this.cache = new Map();
                this.maxSize = maxSize;
            }

            set(key, value) {
                // ç§»é™¤æœ€èˆŠçš„é …ç›®
                if (this.cache.size >= this.maxSize) {
                    const firstKey = this.cache.keys().next().value;
                    this.cache.delete(firstKey);
                }

                this.cache.set(key, {
                    value,
                    timestamp: Date.now()
                });
            }

            get(key) {
                const item = this.cache.get(key);
                return item ? item.value : null;
            }

            // å®šæœŸæ¸…ç†éæœŸé …ç›®
            cleanup(maxAge = 3600000) { // 1å°æ™‚
                const now = Date.now();
                
                for (const [key, item] of this.cache) {
                    if (now - item.timestamp > maxAge) {
                        this.cache.delete(key);
                    }
                }
            }
        }
    }
}
```

## 12.2 ç›£æ§èˆ‡å‘Šè­¦

### 12.2.1 å¥åº·æª¢æŸ¥ç«¯é»

```javascript
// å¥åº·æª¢æŸ¥å¯¦ä½œ
class HealthChecker {
    constructor() {
        this.checks = new Map();
        this.registerDefaultChecks();
    }

    registerDefaultChecks() {
        // è³‡æ–™åº«é€£æ¥æª¢æŸ¥
        this.register('database', async () => {
            try {
                await db.query('SELECT 1');
                return { status: 'healthy' };
            } catch (error) {
                return { 
                    status: 'unhealthy', 
                    error: error.message 
                };
            }
        });

        // Redis é€£æ¥æª¢æŸ¥
        this.register('redis', async () => {
            try {
                await redis.ping();
                return { status: 'healthy' };
            } catch (error) {
                return { 
                    status: 'unhealthy', 
                    error: error.message 
                };
            }
        });

        // Make API é€£æ¥æª¢æŸ¥
        this.register('make-api', async () => {
            try {
                const response = await fetch('https://api.make.com/v1/health');
                return { 
                    status: response.ok ? 'healthy' : 'unhealthy',
                    statusCode: response.status
                };
            } catch (error) {
                return { 
                    status: 'unhealthy', 
                    error: error.message 
                };
            }
        });

        // è¨˜æ†¶é«”ä½¿ç”¨æª¢æŸ¥
        this.register('memory', async () => {
            const usage = process.memoryUsage();
            const heapUsedMB = usage.heapUsed / 1024 / 1024;
            
            return {
                status: heapUsedMB < 500 ? 'healthy' : 'warning',
                heapUsed: `${Math.round(heapUsedMB)} MB`,
                heapTotal: `${Math.round(usage.heapTotal / 1024 / 1024)} MB`
            };
        });
    }

    register(name, checkFn) {
        this.checks.set(name, checkFn);
    }

    async runAll() {
        const results = {
            status: 'healthy',
            timestamp: new Date().toISOString(),
            checks: {}
        };

        for (const [name, checkFn] of this.checks) {
            try {
                results.checks[name] = await checkFn();
                
                if (results.checks[name].status === 'unhealthy') {
                    results.status = 'unhealthy';
                }
            } catch (error) {
                results.checks[name] = {
                    status: 'error',
                    error: error.message
                };
                results.status = 'unhealthy';
            }
        }

        return results;
    }
}

// Express è·¯ç”±
app.get('/health', async (req, res) => {
    const health = await healthChecker.runAll();
    const statusCode = health.status === 'healthy' ? 200 : 503;
    
    res.status(statusCode).json(health);
});

// è©³ç´°å¥åº·æª¢æŸ¥
app.get('/health/detailed', authenticate, async (req, res) => {
    const detailed = await healthChecker.runAll();
    
    // åŠ å…¥é¡å¤–è³‡è¨Š
    detailed.metrics = {
        uptime: process.uptime(),
        requests: {
            total: metrics.get('http_requests_total'),
            errors: metrics.get('http_errors_total')
        },
        scenarios: {
            active: await getActiveScenarioCount(),
            executions: await getExecutionStats()
        }
    };

    res.json(detailed);
});
```

### 12.2.2 å‘Šè­¦è¨­å®š

```javascript
// å‘Šè­¦ç®¡ç†å™¨
class AlertManager {
    constructor() {
        this.rules = [];
        this.channels = new Map();
        this.setupDefaultRules();
    }

    setupDefaultRules() {
        // CPU ä½¿ç”¨ç‡å‘Šè­¦
        this.addRule({
            name: 'high-cpu-usage',
            condition: (metrics) => metrics.cpu.usage > 80,
            severity: 'warning',
            message: 'CPU usage is above 80%'
        });

        // è¨˜æ†¶é«”ä½¿ç”¨å‘Šè­¦
        this.addRule({
            name: 'high-memory-usage',
            condition: (metrics) => metrics.memory.percentage > 90,
            severity: 'critical',
            message: 'Memory usage is above 90%'
        });

        // éŒ¯èª¤ç‡å‘Šè­¦
        this.addRule({
            name: 'high-error-rate',
            condition: (metrics) => metrics.errors.rate > 5,
            severity: 'critical',
            message: 'Error rate is above 5%'
        });

        // API å»¶é²å‘Šè­¦
        this.addRule({
            name: 'high-api-latency',
            condition: (metrics) => metrics.api.p95Latency > 1000,
            severity: 'warning',
            message: 'API p95 latency is above 1000ms'
        });
    }

    addRule(rule) {
        this.rules.push(rule);
    }

    async checkRules(metrics) {
        const alerts = [];

        for (const rule of this.rules) {
            if (rule.condition(metrics)) {
                const alert = {
                    rule: rule.name,
                    severity: rule.severity,
                    message: rule.message,
                    timestamp: new Date(),
                    metrics: metrics
                };

                alerts.push(alert);
                await this.sendAlert(alert);
            }
        }

        return alerts;
    }

    async sendAlert(alert) {
        // ç™¼é€åˆ°æ‰€æœ‰é…ç½®çš„é »é“
        for (const [name, channel] of this.channels) {
            try {
                await channel.send(alert);
            } catch (error) {
                console.error(`Failed to send alert to ${name}:`, error);
            }
        }
    }

    // é…ç½®å‘Šè­¦é »é“
    addChannel(name, channel) {
        this.channels.set(name, channel);
    }
}

// Slack å‘Šè­¦é »é“
class SlackAlertChannel {
    constructor(webhookUrl) {
        this.webhookUrl = webhookUrl;
    }

    async send(alert) {
        const color = {
            'critical': '#FF0000',
            'warning': '#FFA500',
            'info': '#0000FF'
        }[alert.severity] || '#808080';

        const payload = {
            attachments: [{
                color,
                title: `ğŸš¨ ${alert.severity.toUpperCase()}: ${alert.rule}`,
                text: alert.message,
                fields: [
                    {
                        title: 'Timestamp',
                        value: alert.timestamp.toISOString(),
                        short: true
                    },
                    {
                        title: 'Environment',
                        value: process.env.NODE_ENV,
                        short: true
                    }
                ],
                footer: 'Make Bridge Alert System'
            }]
        };

        await fetch(this.webhookUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
    }
}

// Email å‘Šè­¦é »é“
class EmailAlertChannel {
    constructor(config) {
        this.transporter = nodemailer.createTransport(config);
    }

    async send(alert) {
        const html = `
            <h2>Alert: ${alert.rule}</h2>
            <p><strong>Severity:</strong> ${alert.severity}</p>
            <p><strong>Message:</strong> ${alert.message}</p>
            <p><strong>Time:</strong> ${alert.timestamp.toISOString()}</p>
            <hr>
            <h3>Metrics:</h3>
            <pre>${JSON.stringify(alert.metrics, null, 2)}</pre>
        `;

        await this.transporter.sendMail({
            from: 'alerts@makebridge.com',
            to: process.env.ALERT_EMAIL,
            subject: `[${alert.severity.toUpperCase()}] ${alert.rule}`,
            html
        });
    }
}
```

## 12.3 æ—¥èªŒç®¡ç†

### 12.3.1 çµæ§‹åŒ–æ—¥èªŒ

```javascript
// æ—¥èªŒè¨­å®š
const winston = require('winston');
const { format } = winston;

class Logger {
    constructor() {
        this.logger = winston.createLogger({
            level: process.env.LOG_LEVEL || 'info',
            format: format.combine(
                format.timestamp(),
                format.errors({ stack: true }),
                format.metadata(),
                format.json()
            ),
            defaultMeta: {
                service: 'make-bridge',
                environment: process.env.NODE_ENV,
                version: process.env.APP_VERSION
            },
            transports: this.getTransports()
        });
    }

    getTransports() {
        const transports = [];

        // æ§åˆ¶å°è¼¸å‡ºï¼ˆé–‹ç™¼ç’°å¢ƒï¼‰
        if (process.env.NODE_ENV !== 'production') {
            transports.push(new winston.transports.Console({
                format: format.combine(
                    format.colorize(),
                    format.printf(info => {
                        const { timestamp, level, message, ...meta } = info;
                        return `${timestamp} ${level}: ${message} ${
                            Object.keys(meta).length ? JSON.stringify(meta) : ''
                        }`;
                    })
                )
            }));
        }

        // æª”æ¡ˆè¼¸å‡º
        transports.push(new winston.transports.File({
            filename: 'logs/error.log',
            level: 'error',
            maxsize: 10485760, // 10MB
            maxFiles: 5,
            tailable: true
        }));

        transports.push(new winston.transports.File({
            filename: 'logs/combined.log',
            maxsize: 10485760,
            maxFiles: 5,
            tailable: true
        }));

        return transports;
    }

    // è«‹æ±‚æ—¥èªŒ
    logRequest(req, res, duration) {
        this.logger.info('HTTP Request', {
            method: req.method,
            path: req.path,
            query: req.query,
            statusCode: res.statusCode,
            duration,
            userAgent: req.headers['user-agent'],
            ip: req.ip,
            userId: req.user?.id
        });
    }

    // éŒ¯èª¤æ—¥èªŒ
    logError(error, context = {}) {
        this.logger.error(error.message, {
            ...context,
            stack: error.stack,
            name: error.name,
            code: error.code
        });
    }

    // å¯©è¨ˆæ—¥èªŒ
    logAudit(action, userId, details) {
        this.logger.info('Audit Log', {
            type: 'audit',
            action,
            userId,
            details,
            timestamp: new Date().toISOString()
        });
    }

    // æ•ˆèƒ½æ—¥èªŒ
    logPerformance(operation, duration, metadata = {}) {
        this.logger.info('Performance', {
            type: 'performance',
            operation,
            duration,
            ...metadata
        });
    }
}

// æ—¥èªŒæœå°‹å·¥å…·
class LogSearcher {
    async search(criteria) {
        const { 
            level, 
            startTime, 
            endTime, 
            message, 
            userId,
            limit = 100 
        } = criteria;

        const command = this.buildGrepCommand(criteria);
        const results = await exec(command);
        
        return this.parseLogResults(results);
    }

    buildGrepCommand(criteria) {
        let command = 'grep';
        
        if (criteria.message) {
            command += ` -i "${criteria.message}"`;
        }
        
        if (criteria.userId) {
            command += ` | grep "userId.*${criteria.userId}"`;
        }
        
        if (criteria.level) {
            command += ` | grep "level.*${criteria.level}"`;
        }
        
        command += ` logs/combined.log | tail -n ${criteria.limit}`;
        
        return command;
    }

    parseLogResults(rawOutput) {
        const lines = rawOutput.split('\n');
        return lines
            .filter(line => line.trim())
            .map(line => {
                try {
                    return JSON.parse(line);
                } catch {
                    return { raw: line };
                }
            });
    }
}
```

### 12.3.2 æ—¥èªŒåˆ†æ

```javascript
// æ—¥èªŒåˆ†æå™¨
class LogAnalyzer {
    async analyzeErrorPatterns(timeRange) {
        const errors = await this.getErrorLogs(timeRange);
        const patterns = new Map();

        errors.forEach(error => {
            const pattern = this.extractErrorPattern(error);
            
            if (!patterns.has(pattern)) {
                patterns.set(pattern, {
                    count: 0,
                    firstSeen: error.timestamp,
                    lastSeen: error.timestamp,
                    examples: []
                });
            }

            const data = patterns.get(pattern);
            data.count++;
            data.lastSeen = error.timestamp;
            
            if (data.examples.length < 5) {
                data.examples.push(error);
            }
        });

        return this.formatPatternReport(patterns);
    }

    extractErrorPattern(error) {
        // ç§»é™¤å‹•æ…‹è³‡è¨Š
        let pattern = error.message;
        
        // ç§»é™¤ ID
        pattern = pattern.replace(/[a-f0-9]{24}/gi, '[ID]');
        
        // ç§»é™¤æ•¸å­—
        pattern = pattern.replace(/\d+/g, '[NUM]');
        
        // ç§»é™¤ URL
        pattern = pattern.replace(/https?:\/\/[^\s]+/g, '[URL]');
        
        return pattern;
    }

    async generateDailyReport() {
        const report = {
            date: new Date().toISOString().split('T')[0],
            summary: {
                totalRequests: 0,
                errorCount: 0,
                errorRate: 0,
                avgResponseTime: 0,
                uniqueUsers: new Set(),
                topEndpoints: new Map()
            },
            errors: [],
            performance: [],
            alerts: []
        };

        // åˆ†ææ—¥èªŒ
        const logs = await this.getTodayLogs();
        
        logs.forEach(log => {
            if (log.type === 'request') {
                report.summary.totalRequests++;
                report.summary.uniqueUsers.add(log.userId);
                
                const endpoint = `${log.method} ${log.path}`;
                const count = report.summary.topEndpoints.get(endpoint) || 0;
                report.summary.topEndpoints.set(endpoint, count + 1);
            }
            
            if (log.level === 'error') {
                report.summary.errorCount++;
                report.errors.push(log);
            }
        });

        report.summary.errorRate = 
            (report.summary.errorCount / report.summary.totalRequests) * 100;

        return report;
    }
}
```

## 12.4 å‚™ä»½èˆ‡æ¢å¾©

### 12.4.1 è‡ªå‹•å‚™ä»½ç­–ç•¥

```javascript
// å‚™ä»½ç®¡ç†å™¨
class BackupManager {
    constructor() {
        this.scheduleBackups();
    }

    scheduleBackups() {
        // æ¯æ—¥å‚™ä»½
        cron.schedule('0 2 * * *', async () => {
            console.log('Starting daily backup...');
            await this.performBackup('daily');
        });

        // æ¯é€±å‚™ä»½
        cron.schedule('0 3 * * 0', async () => {
            console.log('Starting weekly backup...');
            await this.performBackup('weekly');
        });

        // æ¯æœˆå‚™ä»½
        cron.schedule('0 4 1 * *', async () => {
            console.log('Starting monthly backup...');
            await this.performBackup('monthly');
        });
    }

    async performBackup(type) {
        const timestamp = new Date().toISOString().replace(/[:]/g, '-');
        const backupDir = `backups/${type}/${timestamp}`;

        try {
            // å»ºç«‹å‚™ä»½ç›®éŒ„
            await fs.mkdir(backupDir, { recursive: true });

            // å‚™ä»½è³‡æ–™åº«
            await this.backupDatabase(backupDir);

            // å‚™ä»½è¨­å®šæª”
            await this.backupConfigs(backupDir);

            // å‚™ä»½æ—¥èªŒ
            await this.backupLogs(backupDir);

            // å£“ç¸®å‚™ä»½
            await this.compressBackup(backupDir);

            // ä¸Šå‚³åˆ°é›²ç«¯
            await this.uploadBackup(`${backupDir}.tar.gz`);

            // æ¸…ç†èˆŠå‚™ä»½
            await this.cleanupOldBackups(type);

            console.log(`Backup completed: ${backupDir}`);
        } catch (error) {
            console.error('Backup failed:', error);
            await this.notifyBackupFailure(error);
        }
    }

    async backupDatabase(backupDir) {
        const command = `pg_dump ${process.env.DATABASE_URL} > ${backupDir}/database.sql`;
        await exec(command);
    }

    async backupConfigs(backupDir) {
        const configs = [
            '.env',
            'config/',
            'package.json',
            'package-lock.json'
        ];

        for (const config of configs) {
            await fs.cp(config, `${backupDir}/${config}`, { recursive: true });
        }
    }

    async backupLogs(backupDir) {
        await fs.cp('logs/', `${backupDir}/logs/`, { recursive: true });
    }

    async compressBackup(backupDir) {
        const command = `tar -czf ${backupDir}.tar.gz -C ${path.dirname(backupDir)} ${path.basename(backupDir)}`;
        await exec(command);
        
        // åˆªé™¤æœªå£“ç¸®çš„å‚™ä»½
        await fs.rm(backupDir, { recursive: true });
    }

    async uploadBackup(filePath) {
        // ä¸Šå‚³åˆ° S3
        const s3 = new AWS.S3();
        const fileStream = fs.createReadStream(filePath);
        const key = `make-bridge-backups/${filePath}`;

        await s3.upload({
            Bucket: process.env.BACKUP_BUCKET,
            Key: key,
            Body: fileStream,
            ServerSideEncryption: 'AES256'
        }).promise();
    }

    async cleanupOldBackups(type) {
        const retentionDays = {
            daily: 7,
            weekly: 30,
            monthly: 365
        };

        const cutoffDate = new Date();
        cutoffDate.setDate(cutoffDate.getDate() - retentionDays[type]);

        const backups = await fs.readdir(`backups/${type}/`);
        
        for (const backup of backups) {
            const backupDate = new Date(backup.split('.')[0]);
            if (backupDate < cutoffDate) {
                await fs.rm(`backups/${type}/${backup}`);
            }
        }
    }
}
```

### 12.4.2 ç½é›£æ¢å¾©ç¨‹åº

```javascript
// æ¢å¾©ç®¡ç†å™¨
class RecoveryManager {
    async restoreFromBackup(backupPath) {
        console.log(`Starting recovery from ${backupPath}`);
        
        try {
            // 1. è§£å£“å‚™ä»½
            const tempDir = await this.extractBackup(backupPath);
            
            // 2. åœæ­¢æœå‹™
            await this.stopServices();
            
            // 3. æ¢å¾©è³‡æ–™åº«
            await this.restoreDatabase(`${tempDir}/database.sql`);
            
            // 4. æ¢å¾©è¨­å®š
            await this.restoreConfigs(tempDir);
            
            // 5. é©—è­‰æ¢å¾©
            await this.verifyRecovery();
            
            // 6. é‡æ–°å•Ÿå‹•æœå‹™
            await this.startServices();
            
            console.log('Recovery completed successfully');
        } catch (error) {
            console.error('Recovery failed:', error);
            await this.rollback();
            throw error;
        }
    }

    async extractBackup(backupPath) {
        const tempDir = `/tmp/recovery-${Date.now()}`;
        await fs.mkdir(tempDir);
        
        const command = `tar -xzf ${backupPath} -C ${tempDir}`;
        await exec(command);
        
        return tempDir;
    }

    async stopServices() {
        console.log('Stopping services...');
        await exec('pm2 stop all');
    }

    async restoreDatabase(sqlPath) {
        console.log('Restoring database...');
        
        // å»ºç«‹å‚™ä»½
        await exec(`pg_dump ${process.env.DATABASE_URL} > /tmp/pre-recovery-backup.sql`);
        
        // æ¢å¾©è³‡æ–™åº«
        await exec(`psql ${process.env.DATABASE_URL} < ${sqlPath}`);
    }

    async restoreConfigs(tempDir) {
        console.log('Restoring configurations...');
        
        // å‚™ä»½ç•¶å‰è¨­å®š
        await fs.cp('.env', '.env.pre-recovery');
        
        // æ¢å¾©è¨­å®š
        await fs.cp(`${tempDir}/.env`, '.env');
        await fs.cp(`${tempDir}/config/`, 'config/', { recursive: true });
    }

    async verifyRecovery() {
        console.log('Verifying recovery...');
        
        const checks = [
            this.checkDatabaseConnection(),
            this.checkAPIEndpoints(),
            this.checkDataIntegrity()
        ];

        const results = await Promise.all(checks);
        
        if (results.some(r => !r.success)) {
            throw new Error('Recovery verification failed');
        }
    }

    async rollback() {
        console.log('Rolling back...');
        
        try {
            // æ¢å¾©åŸå§‹è³‡æ–™åº«
            await exec(`psql ${process.env.DATABASE_URL} < /tmp/pre-recovery-backup.sql`);
            
            // æ¢å¾©åŸå§‹è¨­å®š
            await fs.cp('.env.pre-recovery', '.env');
            
            // é‡æ–°å•Ÿå‹•æœå‹™
            await this.startServices();
        } catch (error) {
            console.error('Rollback failed:', error);
        }
    }
}
```

## 12.5 å®‰å…¨æ€§ç¶­è­·

### 12.5.1 å®‰å…¨æ›´æ–°æµç¨‹

```javascript
// å®‰å…¨æƒæå™¨
class SecurityScanner {
    async scanDependencies() {
        console.log('Scanning dependencies for vulnerabilities...');
        
        // npm audit
        const npmAudit = await exec('npm audit --json');
        const auditResult = JSON.parse(npmAudit);
        
        if (auditResult.vulnerabilities) {
            console.log('Vulnerabilities found:', auditResult.metadata.vulnerabilities);
            
            // å˜—è©¦è‡ªå‹•ä¿®å¾©
            if (auditResult.metadata.vulnerabilities.total > 0) {
                console.log('Attempting automatic fix...');
                await exec('npm audit fix');
            }
        }

        return auditResult;
    }

    async scanCode() {
        console.log('Scanning code for security issues...');
        
        // ä½¿ç”¨ ESLint security plugin
        const eslintResult = await exec('eslint . --plugin security --format json');
        
        return JSON.parse(eslintResult);
    }

    async scanSecrets() {
        console.log('Scanning for exposed secrets...');
        
        // ä½¿ç”¨ git-secrets æˆ–é¡ä¼¼å·¥å…·
        const patterns = [
            /api[_-]?key/i,
            /secret[_-]?key/i,
            /password/i,
            /token/i,
            /private[_-]?key/i
        ];

        const files = await this.getAllFiles();
        const issues = [];

        for (const file of files) {
            const content = await fs.readFile(file, 'utf-8');
            
            patterns.forEach(pattern => {
                if (pattern.test(content)) {
                    const lines = content.split('\n');
                    lines.forEach((line, index) => {
                        if (pattern.test(line)) {
                            issues.push({
                                file,
                                line: index + 1,
                                pattern: pattern.toString(),
                                content: line.substring(0, 100)
                            });
                        }
                    });
                }
            });
        }

        return issues;
    }
}

// å®‰å…¨æ›´æ–°ç®¡ç†
class SecurityUpdateManager {
    async checkUpdates() {
        const updates = {
            system: await this.checkSystemUpdates(),
            node: await this.checkNodeUpdates(),
            dependencies: await this.checkDependencyUpdates()
        };

        return updates;
    }

    async applySecurityPatches() {
        console.log('Applying security patches...');
        
        // 1. å‚™ä»½ç•¶å‰ç‹€æ…‹
        await this.createBackup();
        
        // 2. æ›´æ–°ç³»çµ±å¥—ä»¶
        await exec('apt-get update && apt-get upgrade -y');
        
        // 3. æ›´æ–° Node.js
        await this.updateNode();
        
        // 4. æ›´æ–°ä¾è³´
        await exec('npm update');
        
        // 5. é‡æ–°æ¸¬è©¦
        await exec('npm test');
        
        // 6. é‡æ–°éƒ¨ç½²
        await this.redeploy();
    }
}
```

### 12.5.2 å­˜å–æ§åˆ¶å¯©è¨ˆ

```javascript
// å­˜å–å¯©è¨ˆå™¨
class AccessAuditor {
    async auditPermissions() {
        const report = {
            timestamp: new Date(),
            users: await this.auditUserPermissions(),
            apiKeys: await this.auditAPIKeys(),
            tokens: await this.auditTokens(),
            recommendations: []
        };

        // åˆ†æä¸¦ç”¢ç”Ÿå»ºè­°
        this.analyzeAndRecommend(report);
        
        return report;
    }

    async auditUserPermissions() {
        const users = await db.query('SELECT * FROM users');
        const issues = [];

        for (const user of users) {
            // æª¢æŸ¥éåº¦æ¬Šé™
            if (user.role === 'admin' && !user.admin_approved) {
                issues.push({
                    userId: user.id,
                    issue: 'Unapproved admin access',
                    severity: 'high'
                });
            }

            // æª¢æŸ¥ä¼‘çœ å¸³æˆ¶
            const lastActivity = new Date(user.last_activity);
            const daysSinceActivity = (Date.now() - lastActivity) / (1000 * 60 * 60 * 24);
            
            if (daysSinceActivity > 90) {
                issues.push({
                    userId: user.id,
                    issue: 'Dormant account',
                    severity: 'medium',
                    lastActivity: user.last_activity
                });
            }
        }

        return issues;
    }

    async auditAPIKeys() {
        const apiKeys = await db.query('SELECT * FROM api_keys');
        const issues = [];

        for (const key of apiKeys) {
            // æª¢æŸ¥éæœŸé‡‘é‘°
            if (new Date(key.expires_at) < new Date()) {
                issues.push({
                    keyId: key.id,
                    issue: 'Expired API key still active',
                    severity: 'high'
                });
            }

            // æª¢æŸ¥æœªä½¿ç”¨çš„é‡‘é‘°
            if (!key.last_used) {
                issues.push({
                    keyId: key.id,
                    issue: 'API key never used',
                    severity: 'low'
                });
            }
        }

        return issues;
    }
}
```

## 12.6 æ•ˆèƒ½èª¿å„ª

### 12.6.1 è³‡æ–™åº«å„ªåŒ–

```sql
-- å»ºç«‹å¿…è¦çš„ç´¢å¼•
CREATE INDEX idx_scenarios_user_id ON scenarios(user_id);
CREATE INDEX idx_scenarios_status ON scenarios(status);
CREATE INDEX idx_scenarios_created_at ON scenarios(created_at DESC);
CREATE INDEX idx_executions_scenario_id ON executions(scenario_id);
CREATE INDEX idx_executions_status ON executions(status);

-- è¤‡åˆç´¢å¼•
CREATE INDEX idx_scenarios_user_status ON scenarios(user_id, status);
CREATE INDEX idx_executions_scenario_status ON executions(scenario_id, status);

-- åˆ†ææŸ¥è©¢æ•ˆèƒ½
EXPLAIN ANALYZE 
SELECT s.*, COUNT(e.id) as execution_count
FROM scenarios s
LEFT JOIN executions e ON s.id = e.scenario_id
WHERE s.user_id = 'user_123'
  AND s.status = 'active'
GROUP BY s.id
ORDER BY s.created_at DESC
LIMIT 20;
```

### 12.6.2 å¿«å–å„ªåŒ–

```javascript
// æ™ºæ…§å¿«å–ç­–ç•¥
class SmartCache {
    constructor() {
        this.cache = new NodeCache({
            stdTTL: 600, // 10åˆ†é˜é è¨­ TTL
            checkperiod: 120, // æ¯2åˆ†é˜æª¢æŸ¥éæœŸ
            useClones: false // æ•ˆèƒ½å„ªåŒ–
        });
        
        this.hitRate = 0;
        this.missRate = 0;
    }

    async get(key, fetchFn, options = {}) {
        const cached = this.cache.get(key);
        
        if (cached !== undefined) {
            this.hitRate++;
            return cached;
        }

        this.missRate++;
        
        // é˜²æ­¢å¿«å–æ“Šç©¿
        const lock = await this.acquireLock(key);
        if (!lock) {
            // ç­‰å¾…å…¶ä»–è«‹æ±‚å®Œæˆ
            await this.waitForLock(key);
            return this.cache.get(key);
        }

        try {
            const data = await fetchFn();
            
            // æ ¹æ“šè³‡æ–™ç‰¹æ€§èª¿æ•´ TTL
            const ttl = this.calculateTTL(key, data, options);
            this.cache.set(key, data, ttl);
            
            return data;
        } finally {
            await this.releaseLock(key);
        }
    }

    calculateTTL(key, data, options) {
        // æ ¹æ“šä¸åŒé¡å‹çš„è³‡æ–™ä½¿ç”¨ä¸åŒçš„ TTL
        if (key.startsWith('user:')) {
            return 300; // ä½¿ç”¨è€…è³‡æ–™ 5åˆ†é˜
        } else if (key.startsWith('scenario:')) {
            return 600; // å ´æ™¯è³‡æ–™ 10åˆ†é˜
        } else if (key.startsWith('stats:')) {
            return 60; // çµ±è¨ˆè³‡æ–™ 1åˆ†é˜
        }
        
        return options.ttl || 600;
    }

    getStats() {
        const total = this.hitRate + this.missRate;
        return {
            hitRate: this.hitRate,
            missRate: this.missRate,
            hitRatio: total > 0 ? (this.hitRate / total) * 100 : 0,
            keys: this.cache.keys().length,
            size: this.cache.getStats()
        };
    }
}
```

## ç¸½çµ

æœ¬ç« æä¾›äº†å®Œæ•´çš„ç–‘é›£æ’è§£å’Œç¶­è­·æŒ‡å—ï¼Œæ¶µè“‹ï¼š

1. **å¸¸è¦‹å•é¡Œè§£æ±º**ï¼šåˆå§‹åŒ–ã€åŸ·è¡Œã€æ•ˆèƒ½å’Œè¨˜æ†¶é«”å•é¡Œ
2. **ç›£æ§å‘Šè­¦**ï¼šå¥åº·æª¢æŸ¥ã€å‘Šè­¦è¦å‰‡ã€é€šçŸ¥ç®¡é“
3. **æ—¥èªŒç®¡ç†**ï¼šçµæ§‹åŒ–æ—¥èªŒã€æ—¥èªŒåˆ†æã€æœå°‹å·¥å…·
4. **å‚™ä»½æ¢å¾©**ï¼šè‡ªå‹•å‚™ä»½ã€ç½é›£æ¢å¾©ã€è³‡æ–™å®Œæ•´æ€§
5. **å®‰å…¨ç¶­è­·**ï¼šæ¼æ´æƒæã€å®‰å…¨æ›´æ–°ã€å­˜å–å¯©è¨ˆ
6. **æ•ˆèƒ½èª¿å„ª**ï¼šè³‡æ–™åº«å„ªåŒ–ã€å¿«å–ç­–ç•¥ã€è³‡æºç®¡ç†

éµå¾ªé€™äº›æœ€ä½³å¯¦è¸ï¼Œå¯ä»¥ç¢ºä¿ Make Bridge æ•´åˆçš„ç©©å®šæ€§å’Œå¯é æ€§ã€‚

## ğŸ¯ å®Œæˆå­¸ç¿’æ—…ç¨‹

æ­å–œæ‚¨å®Œæˆäº† Make Bridge çš„å®Œæ•´å­¸ç¿’ï¼ç¶“éé€™ 13 å€‹ç« ç¯€çš„æ·±å…¥æ¢ç´¢ï¼Œæ‚¨å·²ç¶“æŒæ¡äº†ï¼š

âœ… **æ ¸å¿ƒæ¦‚å¿µ**ï¼šæ·±å…¥ç†è§£ Make Bridge çš„æ¶æ§‹å’Œé‹ä½œåŸç†  
âœ… **å¯¦ä½œæŠ€èƒ½**ï¼šèƒ½å¤ ç¨ç«‹é–‹ç™¼å’Œéƒ¨ç½² Make Bridge æ•´åˆ  
âœ… **é€²éšæ‡‰ç”¨**ï¼šæŒæ¡ä¼æ¥­ç´šçš„æ¶æ§‹è¨­è¨ˆå’Œæœ€ä½³å¯¦è¸  
âœ… **ç¶­è­·èƒ½åŠ›**ï¼šå…·å‚™ç›£æ§ã€é™¤éŒ¯å’Œå„ªåŒ–çš„å°ˆæ¥­æŠ€èƒ½  

### ğŸ“š æŒçºŒå­¸ç¿’è³‡æº

- **å®˜æ–¹æ–‡æª”**ï¼šæŒçºŒé—œæ³¨ Make.com çš„æ›´æ–°å’Œæ–°åŠŸèƒ½
- **ç¤¾ç¾¤è«–å£‡**ï¼šåƒèˆ‡è¨è«–ï¼Œåˆ†äº«ç¶“é©—ï¼Œå­¸ç¿’ä»–äººçš„æœ€ä½³å¯¦è¸
- **GitHub å°ˆæ¡ˆ**ï¼šæŸ¥çœ‹é–‹æºå°ˆæ¡ˆï¼Œè²¢ç»æ‚¨çš„ç¨‹å¼ç¢¼
- **æŠ€è¡“éƒ¨è½æ ¼**ï¼šæ’°å¯«å’Œåˆ†äº«æ‚¨çš„ Make Bridge é–‹ç™¼ç¶“é©—

### ğŸš€ ä¸‹ä¸€æ­¥å»ºè­°

1. **å¯¦æˆ°å°ˆæ¡ˆ**ï¼šé¸æ“‡ä¸€å€‹çœŸå¯¦çš„æ¥­å‹™å ´æ™¯ï¼Œå¯¦ä½œå®Œæ•´çš„è§£æ±ºæ–¹æ¡ˆ
2. **å„ªåŒ–ç¾æœ‰ç³»çµ±**ï¼šä½¿ç”¨æœ¬æ›¸çš„çŸ¥è­˜æ”¹é€²æ‚¨ç¾æœ‰çš„æ•´åˆ
3. **åˆ†äº«çŸ¥è­˜**ï¼šå°‡æ‚¨çš„ç¶“é©—åˆ†äº«çµ¦åœ˜éšŠæˆ–ç¤¾ç¾¤
4. **æŒçºŒå‰µæ–°**ï¼šæ¢ç´¢ Make Bridge èˆ‡æ–°æŠ€è¡“çš„çµåˆå¯èƒ½

æ„Ÿè¬æ‚¨é¸æ“‡æœ¬æ•™ç¨‹ä½œç‚ºå­¸ç¿’ Make Bridge çš„æŒ‡å—ã€‚ç¥æ‚¨åœ¨è‡ªå‹•åŒ–æ•´åˆçš„é“è·¯ä¸Šå–å¾—æˆåŠŸï¼

å¦‚éœ€æ›´å¤šåƒè€ƒè³‡è¨Šï¼Œè«‹æŸ¥é–±**é™„éŒ„ï¼šè©å½™è¡¨èˆ‡åƒè€ƒè³‡æº**ã€‚