# ç¬¬4ç« ï¼šåŸºç¤æ•´åˆå¯¦ä½œ

å®Œæˆæ¨¡æ¿é–‹ç™¼å¾Œï¼Œæ¥ä¸‹ä¾†å°‡ Make Bridge æ•´åˆåˆ°æ‚¨çš„ç”¢å“ä¸­ï¼Œè®“ä½¿ç”¨è€…èƒ½å¤ åœ¨æ‚¨çš„æ‡‰ç”¨ç¨‹å¼å…§å»ºç«‹å’Œç®¡ç†è‡ªå‹•åŒ–æµç¨‹ã€‚æœ¬ç« å°‡è©³ç´°æŒ‡å°æ‚¨å®ŒæˆåŸºç¤æ•´åˆçš„å®Œæ•´å¯¦ä½œã€‚

> ğŸ”— **ç›¸é—œç« ç¯€åƒè€ƒ**
> 
> - **å‰ç½®ç« ç¯€**ï¼šç¬¬3ç« _æ¨¡æ¿é–‹ç™¼æŒ‡å—.md - å­¸ç¿’å¦‚ä½•å»ºç«‹ Bridge æ¨¡æ¿
> - **å¾ŒçºŒç« ç¯€**ï¼šç¬¬5ç« _å®Œæ•´å°ˆæ¡ˆå¯¦ä½œ_åˆç´š.md - æ‡‰ç”¨æœ¬ç« æŠ€èƒ½å»ºç«‹ç¬¬ä¸€å€‹å®Œæ•´å°ˆæ¡ˆ
> - **é€²éšåƒè€ƒ**ï¼šç¬¬9ç« _Make_API_é€²éšæ‡‰ç”¨.md - æ·±å…¥å­¸ç¿’ API å®¢è£½åŒ–
> - **æœ€ä½³å¯¦è¸**ï¼šç¬¬10ç« _æ¶æ§‹è¨­è¨ˆèˆ‡æœ€ä½³å¯¦è¸.md - ä¼æ¥­ç´šæ¶æ§‹è¨­è¨ˆ
> - **åƒè€ƒè³‡æ–™**ï¼šç¬¬11ç« _å®Œæ•´APIåƒè€ƒ.md - æ‰€æœ‰ API çš„è©³ç´°èªªæ˜

## 4.0 æ ¸å¿ƒç¨‹å¼ç¢¼æ¨¡å¼åº« ğŸ› ï¸

ç‚ºäº†é¿å…é‡è¤‡å’Œæé«˜ç¨‹å¼ç¢¼é‡ç”¨æ€§ï¼Œæœ¬ç¯€æä¾›æ‰€æœ‰å¾ŒçºŒç« ç¯€æœƒä½¿ç”¨çš„æ ¸å¿ƒç¨‹å¼ç¢¼æ¨¡å¼ã€‚

> ğŸ”„ **ä»£ç¢¼åƒè€ƒæŒ‡å—**
> 
> åœ¨å…¶ä»–ç« ç¯€ä¸­çœ‹åˆ° `// è©³è¦‹ç¬¬4ç« æ ¸å¿ƒæ¨¡å¼` æ™‚ï¼Œè«‹å›åˆ°æ­¤è™•æŸ¥çœ‹å®Œæ•´å¯¦ä½œã€‚
> 
> **ä½¿ç”¨æ­¤æ¨¡å¼åº«çš„ç« ç¯€ï¼š**
> - ç¬¬5ç« ï¼šåˆç´šå°ˆæ¡ˆå¯¦ä½œä¸­çš„èº«åˆ†é©—è­‰å’Œ API èª¿ç”¨
> - ç¬¬6ç« ï¼šä¸­ç´šå°ˆæ¡ˆå¯¦ä½œä¸­çš„é€²éšèªè­‰æ©Ÿåˆ¶
> - ç¬¬7ç« ï¼šé«˜ç´šå°ˆæ¡ˆå¯¦ä½œä¸­çš„ä¼æ¥­ç´šå®‰å…¨æ§åˆ¶
> - ç¬¬9ç« ï¼šç›´æ¥ä½¿ç”¨ Make API çš„é€²éšæ•´åˆ

### 4.0.1 JWT ç”Ÿæˆæ¨™æº–æ¨¡å¼

```javascript
// core/auth.js - JWT èªè­‰æ ¸å¿ƒæ¨¡çµ„
const jwt = require('jsonwebtoken');
const crypto = require('crypto');

/**
 * Make Bridge JWT ç”Ÿæˆå™¨
 * ğŸ“ åŸºæ–¼å®˜æ–¹æ–‡æª”ï¼šJWT å¿…é ˆ2åˆ†é˜éæœŸï¼Œä½¿ç”¨ HS256 æ¼”ç®—æ³•
 */
class MakeBridgeAuth {
    constructor(secret, keyId) {
        if (!secret || !keyId) {
            throw new Error('Make Bridge Secret å’Œ Key ID ç‚ºå¿…è¦åƒæ•¸');
        }
        this.secret = secret;
        this.keyId = keyId;
    }

    /**
     * ç”Ÿæˆ Make Bridge JWT Token
     * @param {string} userId - ä½¿ç”¨è€…è­˜åˆ¥ç¢¼
     * @returns {string} JWT Token
     */
    generateJWT(userId) {
        if (!userId) {
            throw new Error('userId ç‚ºå¿…è¦åƒæ•¸');
        }

        const payload = {
            sub: userId,                    // Subject (user identifier)
            jti: crypto.randomUUID(),       // JWT ID (unique token ID)
            iat: Math.floor(Date.now() / 1000), // Issued at
            exp: Math.floor(Date.now() / 1000) + 120 // Expires in 2 minutes
        };

        return jwt.sign(payload, this.secret, {
            algorithm: 'HS256',
            keyid: this.keyId,
            expiresIn: '2m'
        });
    }

    /**
     * é©—è­‰ JWT Token
     * @param {string} token - JWT Token
     * @returns {object} è§£ç¢¼å¾Œçš„ payload
     */
    verifyJWT(token) {
        try {
            return jwt.verify(token, this.secret, {
                algorithms: ['HS256']
            });
        } catch (error) {
            throw new Error(`JWT é©—è­‰å¤±æ•—: ${error.message}`);
        }
    }
}

module.exports = MakeBridgeAuth;
```

### 4.0.2 CORS é…ç½®æ¨™æº–æ¨¡å¼

```javascript
// core/cors.js - CORS é…ç½®æ ¸å¿ƒæ¨¡çµ„
const cors = require('cors');

/**
 * Make Bridge CORS é…ç½®
 * ğŸ“ åŸºæ–¼å®˜æ–¹æ–‡æª”ï¼šå¿…é ˆå…è¨± Make çš„åŸŸåé€²è¡Œè·¨åŸŸè«‹æ±‚
 */
function createCorsConfig(additionalOrigins = []) {
    const makeOrigins = [
        'https://integrations.make.com',
        'https://eu1.make.com',
        'https://eu2.make.com', 
        'https://us1.make.com',
        'https://us2.make.com'
    ];

    const allowedOrigins = [
        ...makeOrigins,
        ...additionalOrigins,
        'http://localhost:3000', // é–‹ç™¼ç’°å¢ƒ
        'http://127.0.0.1:3000'  // é–‹ç™¼ç’°å¢ƒ
    ];

    return cors({
        origin: function (origin, callback) {
            // å…è¨±æ²’æœ‰ origin çš„è«‹æ±‚ï¼ˆå¦‚ mobile apps, postmanï¼‰
            if (!origin) return callback(null, true);
            
            if (allowedOrigins.indexOf(origin) !== -1) {
                callback(null, true);
            } else {
                callback(new Error(`ä¸å…è¨±çš„ CORS ä¾†æº: ${origin}`));
            }
        },
        credentials: true,
        methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
        allowedHeaders: [
            'Content-Type', 
            'Authorization', 
            'X-API-Key',
            'X-Requested-With'
        ],
        maxAge: 86400 // 24å°æ™‚
    });
}

module.exports = createCorsConfig;
```

### 4.0.3 éŒ¯èª¤è™•ç†æ¨™æº–æ¨¡å¼

```javascript
// core/errorHandler.js - éŒ¯èª¤è™•ç†æ ¸å¿ƒæ¨¡çµ„

/**
 * Make Bridge éŒ¯èª¤é¡å‹
 */
class MakeBridgeError extends Error {
    constructor(message, code, statusCode = 500, details = {}) {
        super(message);
        this.name = 'MakeBridgeError';
        this.code = code;
        this.statusCode = statusCode;
        this.details = details;
    }
}

/**
 * çµ±ä¸€éŒ¯èª¤è™•ç†ä¸­é–“ä»¶
 */
function errorHandler(err, req, res, next) {
    console.error('âŒ Make Bridge Error:', {
        message: err.message,
        code: err.code,
        stack: err.stack,
        requestId: req.headers['x-request-id'],
        timestamp: new Date().toISOString()
    });

    // Make Bridge ç‰¹å®šéŒ¯èª¤
    if (err instanceof MakeBridgeError) {
        return res.status(err.statusCode).json({
            success: false,
            error: {
                code: err.code,
                message: err.message,
                details: err.details
            },
            meta: {
                timestamp: new Date().toISOString(),
                requestId: req.headers['x-request-id']
            }
        });
    }

    // JWT éŒ¯èª¤
    if (err.name === 'JsonWebTokenError') {
        return res.status(401).json({
            success: false,
            error: {
                code: 'INVALID_JWT',
                message: 'JWT Token ç„¡æ•ˆ',
                details: { reason: err.message }
            }
        });
    }

    // é è¨­éŒ¯èª¤
    res.status(500).json({
        success: false,
        error: {
            code: 'INTERNAL_SERVER_ERROR',
            message: 'å…§éƒ¨ä¼ºæœå™¨éŒ¯èª¤',
            details: {}
        }
    });
}

/**
 * éåŒæ­¥éŒ¯èª¤åŒ…è£å™¨
 */
function asyncHandler(fn) {
    return (req, res, next) => {
        Promise.resolve(fn(req, res, next)).catch(next);
    };
}

module.exports = {
    MakeBridgeError,
    errorHandler,
    asyncHandler
};
```

### 4.0.4 API å®¢æˆ¶ç«¯æ¨™æº–æ¨¡å¼

```javascript
// core/apiClient.js - API å®¢æˆ¶ç«¯æ ¸å¿ƒæ¨¡çµ„
const axios = require('axios');

/**
 * Make Bridge API å®¢æˆ¶ç«¯
 */
class MakeBridgeAPIClient {
    constructor(auth, baseURL = 'https://api.make.com') {
        this.auth = auth;
        this.baseURL = baseURL;
        this.client = axios.create({
            baseURL,
            timeout: 10000,
            headers: {
                'Content-Type': 'application/json',
                'User-Agent': 'MakeBridge-Client/1.0'
            }
        });

        this.setupInterceptors();
    }

    setupInterceptors() {
        // è«‹æ±‚æ””æˆªå™¨ - è‡ªå‹•æ·»åŠ èªè­‰
        this.client.interceptors.request.use(
            (config) => {
                // é‡æ–°ç”Ÿæˆ JWTï¼ˆæ¯æ¬¡è«‹æ±‚éƒ½è¦æ–°çš„ï¼‰
                const token = this.auth.generateJWT(config.userId || 'default');
                config.headers.Authorization = `Bearer ${token}`;
                return config;
            },
            (error) => Promise.reject(error)
        );

        // å›æ‡‰æ””æˆªå™¨ - çµ±ä¸€éŒ¯èª¤è™•ç†
        this.client.interceptors.response.use(
            (response) => response.data,
            (error) => {
                const errorDetails = {
                    status: error.response?.status,
                    data: error.response?.data,
                    message: error.message
                };
                
                throw new MakeBridgeError(
                    error.response?.data?.message || 'è«‹æ±‚å¤±æ•—',
                    error.response?.data?.code || 'API_ERROR',
                    error.response?.status || 500,
                    errorDetails
                );
            }
        );
    }

    /**
     * åˆå§‹åŒ– Bridge
     */
    async initBridge(userId, config = {}) {
        return this.client.post('/v1/bridge/init', {
            app_id: process.env.MAKE_APP_ID,
            user_id: userId,
            config
        }, { userId });
    }

    /**
     * å»ºç«‹å ´æ™¯
     */
    async createScenario(userId, templateId, config) {
        return this.client.post('/v1/scenarios', {
            template_id: templateId,
            ...config
        }, { userId });
    }

    /**
     * åŸ·è¡Œå ´æ™¯
     */
    async runScenario(userId, scenarioId, data = {}) {
        return this.client.post(`/v1/scenarios/${scenarioId}/run`, {
            data
        }, { userId });
    }
}

module.exports = MakeBridgeAPIClient;
```

### 4.0.5 ä½¿ç”¨æ–¹å¼

åœ¨å…¶ä»–ç« ç¯€ä¸­ï¼Œæ‚¨æœƒçœ‹åˆ°å¦‚ä¸‹å¼•ç”¨ï¼š

```javascript
// å¼•ç”¨æ ¸å¿ƒæ¨¡å¼ - è©³è¦‹ç¬¬4ç«  4.0.1
const MakeBridgeAuth = require('./core/auth');
const createCorsConfig = require('./core/cors');
const { errorHandler, asyncHandler } = require('./core/errorHandler');
const MakeBridgeAPIClient = require('./core/apiClient');

// å®Œæ•´çš„å¯¦ä½œç¯„ä¾‹è«‹åƒè€ƒå„è‡ªç« ç¯€
```

**ğŸ’¡ é‡è¦æç¤ºï¼š** æ‰€æœ‰å¾ŒçºŒç« ç¯€çš„ç¨‹å¼ç¢¼éƒ½å»ºç«‹åœ¨é€™äº›æ ¸å¿ƒæ¨¡å¼ä¹‹ä¸Šã€‚å»ºè­°æ‚¨å…ˆå®Œæ•´äº†è§£æœ¬ç¯€å…§å®¹ï¼Œå†é€²è¡Œå¾ŒçºŒç« ç¯€çš„å­¸ç¿’ã€‚

## 4.1 æ•´åˆæ–¹å¼æ¦‚è¦½

### ğŸ¯ Make Bridge API æ–¹æ³•ï¼ˆæ¨è–¦ï¼‰

**ğŸ“ åŸºæ–¼åŸæ–‡æª”é 23-24ï¼š**Make Bridge API å¯¦ä½œæ–¹æ³•æä¾›å…©ç¨®é¸é …ï¼Œè®“æ‚¨ä½¿ç”¨ Make Bridge API ä½œç‚ºæ•´åˆä»‹é¢ã€‚

#### å…©ç¨®æ•´åˆé¸é …

**é¸é … 1ï¼šé å»ºå…ƒä»¶æ•´åˆï¼ˆåŸºç¤æ•´åˆï¼‰**
- ä½¿ç”¨ Make æä¾›çš„å‰ç«¯é å»ºå…ƒä»¶
- æœ€å¿«çš„æ•´åˆæ™‚é–“
- æœ€å°‘çš„ç·¨ç¢¼éœ€æ±‚
- é©åˆå¿«é€ŸåŸå‹å’Œæ¨™æº–éœ€æ±‚

**é¸é … 2ï¼šç›´æ¥ Make Bridge API æ•´åˆï¼ˆå®¢è£½åŒ–é«”é©—ï¼‰**
- ç›´æ¥å‘¼å« Make Bridge API
- å®Œå…¨æ§åˆ¶ä½¿ç”¨è€…ä»‹é¢
- æ›´å¤šçš„å®¢è£½åŒ–å¯èƒ½æ€§
- é©åˆç‰¹æ®Šè¨­è¨ˆéœ€æ±‚

### ğŸ” èªè­‰éœ€æ±‚

**ğŸ“ åŸºæ–¼åŸæ–‡æª”é 24ï¼š**å®Œæˆæ•´åˆéœ€è¦ä»¥ä¸‹èªè­‰è³‡è¨Šï¼š

```javascript
// å¿…è¦çš„èªè­‰è³‡è¨Š
const authConfig = {
  secret: 'your_make_bridge_secret_key',     // Make Bridge Secret
  keyId: 'your_make_bridge_secret_id',       // Secret ID
  zoneUrl: 'https://eu2.make.com'            // Make Zone URL
};
```

**ğŸ“ åŸºæ–¼åŸæ–‡æª”é 24ï¼š**Make Bridge ä½¿ç”¨ JWT é€²è¡Œèªè­‰å’Œæˆæ¬Šã€‚æ‚¨éœ€è¦å°‡ Secret åŠ å…¥åˆ° JWT token ä¸­ï¼Œé€™å°æ–¼èˆ‡ Make Bridge API çš„æ‰€æœ‰é€šè¨Šéƒ½æ˜¯å¿…è¦çš„ã€‚

## 4.2 é¸é … 1ï¼šé å»ºå…ƒä»¶æ•´åˆ

### ğŸš€ å¿«é€Ÿæ•´åˆå¯¦ä½œ

**ğŸ“ åŸºæ–¼åŸæ–‡æª”é 24-26ï¼š**ç‚ºäº†ç¸®çŸ­æ•´åˆæ™‚é–“ï¼ŒMake å‰µå»ºäº†é å»ºçš„å‰ç«¯å…ƒä»¶ã€‚

#### HTML åŸºç¤çµæ§‹

```html
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Make Bridge æ•´åˆç¤ºç¯„</title>
    
    <!-- ğŸ“ åŸºæ–¼åŸæ–‡æª”é 26ï¼šContent Security Policy è¨­å®š -->
    <meta http-equiv="Content-Security-Policy" 
          content="frame-src 'self' https://*.make.com; script-src 'self' https://*.make.com; object-src 'none';">
</head>
<body>
    <div id="app">
        <h1>è‡ªå‹•åŒ–è¨­å®š</h1>
        <p>é»æ“Šä¸‹æ–¹æŒ‰éˆ•è¨­å®šæ‚¨çš„è‡ªå‹•åŒ–æµç¨‹</p>
        
        <!-- æ•´åˆç²¾éˆå®¹å™¨ -->
        <div id="integration-container"></div>
        
        <!-- è§¸ç™¼æŒ‰éˆ• -->
        <button id="start-integration" onclick="initializeBridge()">
            é–‹å§‹è¨­å®šè‡ªå‹•åŒ–
        </button>
        
        <!-- ç‹€æ…‹é¡¯ç¤º -->
        <div id="status"></div>
    </div>

    <!-- Make Bridge æ•´åˆè…³æœ¬ -->
    <script src="https://portal-integrations.make.com/js/portal-integrations.js"></script>
    <script src="app.js"></script>
</body>
</html>
```

#### JavaScript æ•´åˆé‚è¼¯

```javascript
// app.js - Make Bridge æ•´åˆé‚è¼¯

class MakeBridgeIntegration {
    constructor(config) {
        this.config = config;
        this.isInitialized = false;
    }

    /**
     * åˆå§‹åŒ– Make Bridge æ•´åˆ
     * ğŸ“ åŸºæ–¼åŸæ–‡æª”é 25-26 çš„æ•´åˆç¯„ä¾‹
     */
    async initialize() {
        try {
            // ç¢ºä¿ portal-integrations.js å·²è¼‰å…¥
            if (typeof window.PortalIntegrations === 'undefined') {
                throw new Error('Portal Integrations è…³æœ¬æœªè¼‰å…¥');
            }

            // å–å¾— JWT Token
            const token = await this.getAuthToken();
            
            // åˆå§‹åŒ– Portal Integrations
            window.PortalIntegrations.init({
                token: token,
                zoneUrl: this.config.zoneUrl,
                container: this.config.container,
                onSuccess: this.handleSuccess.bind(this),
                onError: this.handleError.bind(this),
                onClose: this.handleClose.bind(this)
            });

            this.isInitialized = true;
            this.updateStatus('æ•´åˆå·²åˆå§‹åŒ–', 'success');
            
        } catch (error) {
            console.error('åˆå§‹åŒ–å¤±æ•—:', error);
            this.updateStatus(`åˆå§‹åŒ–å¤±æ•—: ${error.message}`, 'error');
        }
    }

    /**
     * å•Ÿå‹•æ•´åˆç²¾éˆ
     * @param {string} templateId - Bridge æ¨¡æ¿çš„ Public Version ID
     */
    async startIntegration(templateId) {
        try {
            if (!this.isInitialized) {
                await this.initialize();
            }

            // ğŸ“ åŸºæ–¼åŸæ–‡æª”é 25 çš„ç²¾éˆå•Ÿå‹•æµç¨‹
            const result = await window.PortalIntegrations.startWizard({
                templateId: templateId,
                userId: this.config.userId,
                autoActivate: true,  // è‡ªå‹•å•Ÿç”¨å»ºç«‹çš„ Scenario
                redirectUri: this.config.redirectUri
            });

            this.updateStatus('æ•´åˆç²¾éˆå·²å•Ÿå‹•', 'info');
            return result;
            
        } catch (error) {
            console.error('å•Ÿå‹•æ•´åˆç²¾éˆå¤±æ•—:', error);
            this.updateStatus(`å•Ÿå‹•å¤±æ•—: ${error.message}`, 'error');
            throw error;
        }
    }

    /**
     * å¾å¾Œç«¯å–å¾— JWT Token
     */
    async getAuthToken() {
        try {
            const response = await fetch('/api/auth/token', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    userId: this.config.userId
                })
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const data = await response.json();
            return data.token;
            
        } catch (error) {
            console.error('å–å¾—èªè­‰ Token å¤±æ•—:', error);
            throw new Error('ç„¡æ³•å–å¾—èªè­‰ Token');
        }
    }

    /**
     * æ•´åˆæˆåŠŸçš„è™•ç†å‡½æ•¸
     */
    handleSuccess(result) {
        console.log('æ•´åˆæˆåŠŸ:', result);
        this.updateStatus('è‡ªå‹•åŒ–è¨­å®šå®Œæˆï¼', 'success');
        
        // å¯ä»¥åœ¨é€™è£¡è™•ç†æˆåŠŸå¾Œçš„é‚è¼¯
        if (this.config.onSuccess) {
            this.config.onSuccess(result);
        }
    }

    /**
     * æ•´åˆéŒ¯èª¤çš„è™•ç†å‡½æ•¸
     */
    handleError(error) {
        console.error('æ•´åˆéŒ¯èª¤:', error);
        this.updateStatus(`è¨­å®šéç¨‹ä¸­ç™¼ç”ŸéŒ¯èª¤: ${error.message}`, 'error');
        
        if (this.config.onError) {
            this.config.onError(error);
        }
    }

    /**
     * ç²¾éˆé—œé–‰çš„è™•ç†å‡½æ•¸
     */
    handleClose() {
        console.log('æ•´åˆç²¾éˆå·²é—œé–‰');
        this.updateStatus('è¨­å®šå·²å–æ¶ˆ', 'info');
        
        if (this.config.onClose) {
            this.config.onClose();
        }
    }

    /**
     * æ›´æ–°ç‹€æ…‹é¡¯ç¤º
     */
    updateStatus(message, type = 'info') {
        const statusElement = document.getElementById('status');
        if (statusElement) {
            statusElement.textContent = message;
            statusElement.className = `status ${type}`;
        }
    }
}

// åˆå§‹åŒ–é…ç½®
const bridgeConfig = {
    userId: 'user@example.com',  // æ›¿æ›ç‚ºå¯¦éš›çš„ä½¿ç”¨è€… ID
    zoneUrl: 'https://eu2.make.com',
    container: '#integration-container',
    redirectUri: window.location.origin + '/integration-complete',
    onSuccess: (result) => {
        // è‡ªè¨‚æˆåŠŸè™•ç†é‚è¼¯
        console.log('è‡ªå‹•åŒ–å»ºç«‹æˆåŠŸ:', result);
    },
    onError: (error) => {
        // è‡ªè¨‚éŒ¯èª¤è™•ç†é‚è¼¯
        console.error('æ•´åˆéç¨‹ç™¼ç”ŸéŒ¯èª¤:', error);
    },
    onClose: () => {
        // è‡ªè¨‚é—œé–‰è™•ç†é‚è¼¯
        console.log('ä½¿ç”¨è€…å–æ¶ˆäº†è¨­å®š');
    }
};

// å»ºç«‹æ•´åˆå¯¦ä¾‹
const makeBridge = new MakeBridgeIntegration(bridgeConfig);

/**
 * åˆå§‹åŒ– Bridgeï¼ˆé é¢è¼‰å…¥æ™‚å‘¼å«ï¼‰
 */
async function initializeBridge() {
    const templateId = 'tpl_your_template_id'; // æ›¿æ›ç‚ºæ‚¨çš„æ¨¡æ¿ Public Version ID
    
    try {
        await makeBridge.startIntegration(templateId);
    } catch (error) {
        console.error('ç„¡æ³•å•Ÿå‹• Make Bridge:', error);
    }
}

// é é¢è¼‰å…¥å®Œæˆå¾Œé è¼‰ Bridge
document.addEventListener('DOMContentLoaded', () => {
    makeBridge.initialize();
});
```

#### CSS æ¨£å¼è¨­è¨ˆ

```css
/* styles.css - Make Bridge æ•´åˆæ¨£å¼ */

/* åŸºç¤ä½ˆå±€ */
#app {
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}

/* æ•´åˆå®¹å™¨ */
#integration-container {
    margin: 20px 0;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    min-height: 400px;
    background-color: #fafafa;
}

/* è§¸ç™¼æŒ‰éˆ• */
#start-integration {
    background-color: #1976d2;
    color: white;
    border: none;
    padding: 12px 24px;
    border-radius: 6px;
    font-size: 16px;
    cursor: pointer;
    transition: background-color 0.3s;
}

#start-integration:hover {
    background-color: #1565c0;
}

#start-integration:disabled {
    background-color: #ccc;
    cursor: not-allowed;
}

/* ç‹€æ…‹é¡¯ç¤º */
#status {
    margin-top: 16px;
    padding: 12px;
    border-radius: 4px;
    font-weight: 500;
}

.status.success {
    background-color: #e8f5e8;
    color: #2e7d32;
    border: 1px solid #c8e6c9;
}

.status.error {
    background-color: #ffebee;
    color: #c62828;
    border: 1px solid #ffcdd2;
}

.status.info {
    background-color: #e3f2fd;
    color: #1565c0;
    border: 1px solid #bbdefb;
}

/* è¼‰å…¥å‹•ç•« */
.loading {
    display: inline-block;
    width: 20px;
    height: 20px;
    border: 3px solid #f3f3f3;
    border-top: 3px solid #1976d2;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* éŸ¿æ‡‰å¼è¨­è¨ˆ */
@media (max-width: 600px) {
    #app {
        padding: 10px;
    }
    
    #start-integration {
        width: 100%;
        padding: 16px;
    }
}
```

## 4.3 å¾Œç«¯ä»£ç†æœå‹™å™¨

### ğŸ”’ Node.js ä»£ç†å¯¦ä½œ

**ğŸ“ åŸºæ–¼åŸæ–‡æª”é 27-30ï¼š**ç‚ºäº†å®‰å…¨åœ°è™•ç† JWT èªè­‰å’Œ API å‘¼å«ï¼Œéœ€è¦å»ºç«‹å¾Œç«¯ä»£ç†æœå‹™å™¨ã€‚

#### åŸºç¤æœå‹™å™¨è¨­å®š

```javascript
// server.js - Make Bridge å¾Œç«¯ä»£ç†
const express = require('express');
const jwt = require('jsonwebtoken');
const crypto = require('crypto');
const proxy = require('express-http-proxy');
const cors = require('cors');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3000;

// ä¸­é–“ä»¶è¨­å®š
app.use(cors({
    origin: process.env.FRONTEND_URL || 'http://localhost:3000',
    credentials: true
}));
app.use(express.json());
app.use(express.static('public')); // éœæ…‹æª”æ¡ˆç›®éŒ„

// Make Bridge è¨­å®š
const MAKE_CONFIG = {
    secret: process.env.MAKE_BRIDGE_SECRET,
    keyId: process.env.MAKE_BRIDGE_KEY_ID,
    zoneUrl: process.env.MAKE_ZONE_URL || 'https://eu2.make.com'
};

/**
 * JWT Token ç”Ÿæˆå™¨é¡åˆ¥
 */
class MakeBridgeAuth {
    constructor(config) {
        this.secret = config.secret;
        this.keyId = config.keyId;
        this.zoneUrl = config.zoneUrl;
        
        if (!this.secret || !this.keyId) {
            throw new Error('Make Bridge Secret å’Œ Key ID æ˜¯å¿…è¦çš„');
        }
    }

    /**
     * ç”Ÿæˆ JWT Token
     * ğŸ“ åŸºæ–¼åŸæ–‡æª”é 8-11 çš„ JWT çµæ§‹
     */
    generateToken(userId) {
        const payload = {
            sub: userId,
            jti: crypto.randomUUID(),
        };

        const options = {
            expiresIn: '2m',  // 2åˆ†é˜éæœŸ
            keyid: this.keyId,
        };

        return jwt.sign(payload, this.secret, options);
    }

    /**
     * é©—è­‰ Token æ˜¯å¦æœ‰æ•ˆ
     */
    isTokenValid(token) {
        try {
            const decoded = jwt.decode(token);
            const now = Math.floor(Date.now() / 1000);
            return decoded && decoded.exp > now;
        } catch (error) {
            return false;
        }
    }
}

// åˆå§‹åŒ–èªè­‰ç®¡ç†å™¨
const authManager = new MakeBridgeAuth(MAKE_CONFIG);

/**
 * API è·¯ç”±ï¼šç”Ÿæˆèªè­‰ Token
 */
app.post('/api/auth/token', (req, res) => {
    try {
        const { userId } = req.body;
        
        if (!userId) {
            return res.status(400).json({
                error: 'userId åƒæ•¸æ˜¯å¿…è¦çš„'
            });
        }

        const token = authManager.generateToken(userId);
        
        res.json({
            token: token,
            expiresIn: 120, // 2åˆ†é˜
            tokenType: 'Bearer'
        });
        
    } catch (error) {
        console.error('Token ç”Ÿæˆå¤±æ•—:', error);
        res.status(500).json({
            error: 'Token ç”Ÿæˆå¤±æ•—',
            message: error.message
        });
    }
});

/**
 * API è·¯ç”±ï¼šä»£ç† Make Bridge API å‘¼å«
 */
app.use('/api/bridge/*', proxy(MAKE_CONFIG.zoneUrl, {
    proxyReqPathResolver: (req) => {
        // å°‡ /api/bridge/* è½‰æ›ç‚º Make Bridge API è·¯å¾‘
        const originalPath = req.originalUrl.replace('/api/bridge', '/portal/api/bridge');
        console.log('ä»£ç†è«‹æ±‚:', originalPath);
        return originalPath;
    },
    
    proxyReqOptDecorator: (proxyReqOpts, srcReq) => {
        // æ·»åŠ å¿…è¦çš„èªè­‰æ¨™é ­
        const authHeader = srcReq.headers.authorization;
        if (authHeader) {
            proxyReqOpts.headers['Authorization'] = authHeader;
        }
        
        proxyReqOpts.headers['Content-Type'] = 'application/json';
        return proxyReqOpts;
    },
    
    userResDecorator: (proxyRes, proxyResData, userReq, userRes) => {
        // è¨˜éŒ„å›æ‡‰
        console.log('ä»£ç†å›æ‡‰ç‹€æ…‹:', proxyRes.statusCode);
        
        // è™•ç†éŒ¯èª¤å›æ‡‰
        if (proxyRes.statusCode >= 400) {
            console.error('Make Bridge API éŒ¯èª¤:', proxyResData.toString());
        }
        
        return proxyResData;
    }
}));

/**
 * API è·¯ç”±ï¼šå–å¾—æ•´åˆåˆ—è¡¨
 */
app.get('/api/integrations', async (req, res) => {
    try {
        const userId = req.query.userId || req.headers['x-user-id'];
        
        if (!userId) {
            return res.status(400).json({
                error: 'userId åƒæ•¸æ˜¯å¿…è¦çš„'
            });
        }

        const token = authManager.generateToken(userId);
        const url = `${MAKE_CONFIG.zoneUrl}/portal/api/bridge/integrations`;
        
        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const data = await response.json();
        res.json(data);
        
    } catch (error) {
        console.error('å–å¾—æ•´åˆåˆ—è¡¨å¤±æ•—:', error);
        res.status(500).json({
            error: 'å–å¾—æ•´åˆåˆ—è¡¨å¤±æ•—',
            message: error.message
        });
    }
});

/**
 * API è·¯ç”±ï¼šå»ºç«‹æ–°æ•´åˆ
 */
app.post('/api/integrations/create', async (req, res) => {
    try {
        const { userId, templateId, autoActivate = true } = req.body;
        
        if (!userId || !templateId) {
            return res.status(400).json({
                error: 'userId å’Œ templateId åƒæ•¸æ˜¯å¿…è¦çš„'
            });
        }

        const token = authManager.generateToken(userId);
        const url = `${MAKE_CONFIG.zoneUrl}/portal/api/bridge/integrations/init/${templateId}`;
        
        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                autoActivate: autoActivate
            })
        });

        if (!response.ok) {
            const errorData = await response.text();
            throw new Error(`HTTP ${response.status}: ${errorData}`);
        }

        const data = await response.json();
        res.json(data);
        
    } catch (error) {
        console.error('å»ºç«‹æ•´åˆå¤±æ•—:', error);
        res.status(500).json({
            error: 'å»ºç«‹æ•´åˆå¤±æ•—',
            message: error.message
        });
    }
});

/**
 * éŒ¯èª¤è™•ç†ä¸­é–“ä»¶
 */
app.use((error, req, res, next) => {
    console.error('ä¼ºæœå™¨éŒ¯èª¤:', error);
    res.status(500).json({
        error: 'å…§éƒ¨ä¼ºæœå™¨éŒ¯èª¤',
        message: process.env.NODE_ENV === 'development' ? error.message : 'è«‹ç¨å¾Œå†è©¦'
    });
});

/**
 * 404 è™•ç†
 */
app.use((req, res) => {
    res.status(404).json({
        error: 'æ‰¾ä¸åˆ°è«‹æ±‚çš„è³‡æº',
        path: req.originalUrl
    });
});

/**
 * å•Ÿå‹•ä¼ºæœå™¨
 */
app.listen(PORT, () => {
    console.log(`Make Bridge ä»£ç†ä¼ºæœå™¨å·²å•Ÿå‹•ï¼šhttp://localhost:${PORT}`);
    console.log('ç’°å¢ƒè¨­å®š:');
    console.log(`- Zone URL: ${MAKE_CONFIG.zoneUrl}`);
    console.log(`- Key ID: ${MAKE_CONFIG.keyId ? 'å·²è¨­å®š' : 'æœªè¨­å®š'}`);
    console.log(`- Secret: ${MAKE_CONFIG.secret ? 'å·²è¨­å®š' : 'æœªè¨­å®š'}`);
});

module.exports = app;
```

#### ç’°å¢ƒè®Šæ•¸è¨­å®š

```bash
# .env - ç’°å¢ƒè®Šæ•¸è¨­å®šæª”
# Make Bridge èªè­‰è¨­å®š
MAKE_BRIDGE_SECRET=your_secret_here
MAKE_BRIDGE_KEY_ID=your_key_id_here
MAKE_ZONE_URL=https://eu2.make.com

# ä¼ºæœå™¨è¨­å®š
PORT=3000
NODE_ENV=development
FRONTEND_URL=http://localhost:3000

# å®‰å…¨æ€§è¨­å®š
JWT_EXPIRY=2m
CORS_ORIGIN=http://localhost:3000
```

#### Package.json ä¾è³´è¨­å®š

```json
{
  "name": "make-bridge-integration",
  "version": "1.0.0",
  "description": "Make Bridge åŸºç¤æ•´åˆç¯„ä¾‹",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "jest"
  },
  "dependencies": {
    "express": "^4.18.2",
    "jsonwebtoken": "^9.0.0",
    "express-http-proxy": "^1.6.3",
    "cors": "^2.8.5",
    "dotenv": "^16.0.3"
  },
  "devDependencies": {
    "nodemon": "^2.0.22",
    "jest": "^29.5.0"
  },
  "keywords": ["make", "bridge", "automation", "integration"],
  "author": "Rush",
  "license": "MIT"
}
```

## 4.4 å®‰å…¨æ€§è¨­å®š

### ğŸ›¡ï¸ Content Security Policy (CSP)

**ğŸ“ åŸºæ–¼åŸæ–‡æª”é 26ï¼š**æ­£ç¢ºçš„ CSP è¨­å®šå°æ–¼å®‰å…¨æ€§è‡³é—œé‡è¦ã€‚

```html
<!-- åŸºç¤ CSP è¨­å®š -->
<meta http-equiv="Content-Security-Policy" 
      content="frame-src 'self' https://*.make.com; 
               script-src 'self' https://*.make.com; 
               object-src 'none';">

<!-- é€²éš CSP è¨­å®šï¼ˆç”Ÿç”¢ç’°å¢ƒå»ºè­°ï¼‰ -->
<meta http-equiv="Content-Security-Policy" 
      content="default-src 'self'; 
               script-src 'self' https://portal-integrations.make.com; 
               frame-src 'self' https://*.make.com; 
               connect-src 'self' https://*.make.com; 
               style-src 'self' 'unsafe-inline'; 
               img-src 'self' data: https:; 
               object-src 'none'; 
               base-uri 'self';">
```

### ğŸ” ç’°å¢ƒè®Šæ•¸å®‰å…¨ç®¡ç†

```javascript
// config/security.js - å®‰å…¨æ€§é…ç½®
class SecurityConfig {
    constructor() {
        this.validateEnvironment();
    }

    validateEnvironment() {
        const requiredVars = [
            'MAKE_BRIDGE_SECRET',
            'MAKE_BRIDGE_KEY_ID',
            'MAKE_ZONE_URL'
        ];

        const missing = requiredVars.filter(varName => !process.env[varName]);
        
        if (missing.length > 0) {
            throw new Error(`ç¼ºå°‘å¿…è¦çš„ç’°å¢ƒè®Šæ•¸: ${missing.join(', ')}`);
        }
    }

    getSecureConfig() {
        return {
            secret: process.env.MAKE_BRIDGE_SECRET,
            keyId: process.env.MAKE_BRIDGE_KEY_ID,
            zoneUrl: process.env.MAKE_ZONE_URL,
            // ä¸è¦åœ¨å‰ç«¯æš´éœ²çš„è¨­å®š
            internal: {
                nodeEnv: process.env.NODE_ENV,
                port: process.env.PORT
            }
        };
    }
}

module.exports = new SecurityConfig();
```

### ğŸš« å¸¸è¦‹å®‰å…¨éŒ¯èª¤

```javascript
// âŒ éŒ¯èª¤ï¼šåœ¨å‰ç«¯æš´éœ² Secret
const badConfig = {
    secret: 'your_secret_here',  // çµ•å°ä¸è¦é€™æ¨£åšï¼
    keyId: 'your_key_id'
};

// âœ… æ­£ç¢ºï¼šé€šéå¾Œç«¯ API å–å¾— Token
async function getAuthToken() {
    const response = await fetch('/api/auth/token', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ userId: currentUserId })
    });
    
    const data = await response.json();
    return data.token;  // åªè¿”å› Tokenï¼Œä¸æš´éœ² Secret
}
```

## 4.5 ç–‘é›£æ’è§£

### ğŸ” å¸¸è¦‹å•é¡Œèˆ‡è§£æ±ºæ–¹æ¡ˆ

#### å•é¡Œ 1ï¼šPortal Integrations è…³æœ¬è¼‰å…¥å¤±æ•—

**ç—‡ç‹€ï¼š**
```
Uncaught ReferenceError: PortalIntegrations is not defined
```

**è§£æ±ºæ–¹æ¡ˆï¼š**
```javascript
// æª¢æŸ¥è…³æœ¬è¼‰å…¥ç‹€æ…‹
function checkPortalIntegrationsLoaded() {
    return new Promise((resolve, reject) => {
        if (typeof window.PortalIntegrations !== 'undefined') {
            resolve(true);
            return;
        }

        const script = document.createElement('script');
        script.src = 'https://portal-integrations.make.com/js/portal-integrations.js';
        script.onload = () => {
            setTimeout(() => {
                if (typeof window.PortalIntegrations !== 'undefined') {
                    resolve(true);
                } else {
                    reject(new Error('Portal Integrations è¼‰å…¥å¾Œä»ç„¡æ³•ä½¿ç”¨'));
                }
            }, 500);
        };
        script.onerror = () => reject(new Error('ç„¡æ³•è¼‰å…¥ Portal Integrations è…³æœ¬'));
        document.head.appendChild(script);
    });
}
```

#### å•é¡Œ 2ï¼šJWT Token éæœŸ

**ç—‡ç‹€ï¼š**
```
HTTP 401: Unauthorized
```

**è§£æ±ºæ–¹æ¡ˆï¼š**
```javascript
// è‡ªå‹•é‡æ–°ç”¢ç”Ÿ Token æ©Ÿåˆ¶
class TokenManager {
    constructor() {
        this.token = null;
        this.expiryTime = null;
    }

    async getValidToken(userId) {
        if (this.token && this.isTokenValid()) {
            return this.token;
        }

        return await this.refreshToken(userId);
    }

    isTokenValid() {
        if (!this.expiryTime) return false;
        return Date.now() < this.expiryTime - 10000; // 10ç§’ç·©è¡
    }

    async refreshToken(userId) {
        const response = await fetch('/api/auth/token', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ userId })
        });

        const data = await response.json();
        this.token = data.token;
        this.expiryTime = Date.now() + (data.expiresIn * 1000);
        
        return this.token;
    }
}
```

#### å•é¡Œ 3ï¼šCORS æ”¿ç­–éŒ¯èª¤

**ç—‡ç‹€ï¼š**
```
CORS policy: No 'Access-Control-Allow-Origin' header
```

**è§£æ±ºæ–¹æ¡ˆï¼š**
```javascript
// æ­£ç¢ºçš„ CORS è¨­å®š
app.use(cors({
    origin: function (origin, callback) {
        // å…è¨±çš„ä¾†æºåˆ—è¡¨
        const allowedOrigins = [
            'http://localhost:3000',
            'https://yourdomain.com',
            'https://portal-integrations.make.com'
        ];
        
        if (!origin || allowedOrigins.includes(origin)) {
            callback(null, true);
        } else {
            callback(new Error('Not allowed by CORS'));
        }
    },
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE'],
    allowedHeaders: ['Content-Type', 'Authorization', 'x-user-id']
}));
```

### ğŸ“Š é™¤éŒ¯å·¥å…·

```javascript
// debug.js - é™¤éŒ¯è¼”åŠ©å·¥å…·
class MakeBridgeDebugger {
    constructor() {
        this.logs = [];
        this.isDebugMode = process.env.NODE_ENV === 'development';
    }

    log(level, message, data = null) {
        const logEntry = {
            timestamp: new Date().toISOString(),
            level,
            message,
            data
        };

        this.logs.push(logEntry);
        
        if (this.isDebugMode) {
            console.log(`[${level.toUpperCase()}] ${message}`, data);
        }
    }

    getLogs() {
        return this.logs;
    }

    exportLogs() {
        return JSON.stringify(this.logs, null, 2);
    }
}

// ä½¿ç”¨ç¯„ä¾‹
const debugger = new MakeBridgeDebugger();
debugger.log('info', 'Make Bridge åˆå§‹åŒ–é–‹å§‹');
debugger.log('error', 'JWT ç”Ÿæˆå¤±æ•—', { userId: 'user123', error: 'Invalid secret' });
```

## 4.6 æœ¬ç« ç¸½çµ

å®Œæˆæœ¬ç« å¾Œï¼Œæ‚¨æ‡‰è©²èƒ½å¤ ï¼š

âœ… **ç†è§£ Make Bridge çš„å…©ç¨®æ•´åˆé¸é …**  
âœ… **å¯¦ä½œé å»ºå…ƒä»¶çš„åŸºç¤æ•´åˆ**  
âœ… **å»ºç«‹å®‰å…¨çš„å¾Œç«¯ä»£ç†æœå‹™å™¨**  
âœ… **æ­£ç¢ºè¨­å®šèªè­‰å’Œå®‰å…¨æ€§**  
âœ… **è™•ç†å¸¸è¦‹çš„æ•´åˆå•é¡Œ**  

### ğŸ“ æ•´åˆæª¢æŸ¥æ¸…å–®

- [ ] HTML é é¢çµæ§‹å·²å»ºç«‹
- [ ] Portal Integrations è…³æœ¬å·²è¼‰å…¥
- [ ] å¾Œç«¯ä»£ç†æœå‹™å™¨å·²è¨­å®š
- [ ] JWT èªè­‰æ©Ÿåˆ¶å·²å¯¦ä½œ
- [ ] CSP å®‰å…¨æ”¿ç­–å·²é…ç½®
- [ ] éŒ¯èª¤è™•ç†æ©Ÿåˆ¶å·²å»ºç«‹
- [ ] é™¤éŒ¯å·¥å…·å·²æº–å‚™
- [ ] åŸºç¤æ•´åˆæ¸¬è©¦å·²é€šé

## 4.7 å¿«é€Ÿåƒè€ƒå¡ç‰‡ ğŸ“‹

ä»¥ä¸‹åƒè€ƒå¡ç‰‡å¯ä¾›åˆ—å°æˆ–æ›¸ç±¤ï¼Œæ–¹ä¾¿åœ¨é–‹ç™¼éç¨‹ä¸­å¿«é€ŸæŸ¥é–±ã€‚

### ğŸ  JWT èªè­‰å¿«é€Ÿåƒè€ƒ

```javascript
// å¿«é€Ÿ JWT ç”Ÿæˆ
 const jwt = require('jsonwebtoken');
 
 function generateMakeJWT(userId, secret, keyId) {
   const payload = {
     sub: userId,
     jti: crypto.randomUUID(),
     iat: Math.floor(Date.now() / 1000),
     exp: Math.floor(Date.now() / 1000) + 120  // 2åˆ†é˜å¾ŒéæœŸ
   };
   
   return jwt.sign(payload, secret, {
     algorithm: 'HS256',
     keyid: keyId
   });
 }
 
 // ä½¿ç”¨ç¯„ä¾‹
 const token = generateMakeJWT('user123', process.env.MAKE_SECRET, process.env.MAKE_KEY_ID);
```

### ğŸ”— CORS è¨­å®šå¿«é€Ÿåƒè€ƒ

```javascript
// Express CORS è¨­å®š
const corsOptions = {
  origin: [
    'https://eu1.make.com',
    'https://eu2.make.com',
    'https://us1.make.com',
    'https://us2.make.com',
    'http://localhost:3000'  // é–‹ç™¼ç’°å¢ƒ
  ],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
};

app.use(cors(corsOptions));
```

### ğŸš€ API ä»£ç†å¿«é€Ÿåƒè€ƒ

```javascript
// Make Bridge API ä»£ç†
app.use('/api/bridge', async (req, res) => {
  const token = generateMakeJWT(req.user.id);
  
  const response = await fetch(`${MAKE_ZONE_URL}/api/bridge${req.path}`, {
    method: req.method,
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    },
    body: req.method !== 'GET' ? JSON.stringify(req.body) : undefined
  });
  
  const data = await response.json();
  res.json(data);
});
```

### ğŸ“ å¸¸ç”¨ API ç«¯é»å¿«é€Ÿåƒè€ƒ

| åŠŸèƒ½ | æ–¹æ³• | ç«¯é» | èªªæ˜ |
|------|------|------|------|
| **ç²å–æ¨¡æ¿** | GET | `/api/bridge/integrations/{publicVersionId}` | ç²å–æ¨¡æ¿è¨­å®š |
| **åˆå§‹åŒ–æ•´åˆ** | POST | `/api/bridge/integrations/init/{publicVersionId}` | é–‹å§‹æ•´åˆè¨­å®š |
| **å®Œæˆæ•´åˆ** | POST | `/api/bridge/integrations/finalize` | å®Œæˆä¸¦å•“ç”¨å ´æ™¯ |
| **ç²å–å ´æ™¯** | GET | `/api/bridge/scenarios/{scenarioId}` | æŸ¥çœ‹å ´æ™¯è³‡è¨Š |
| **åŸ·è¡Œå ´æ™¯** | POST | `/api/bridge/scenarios/{scenarioId}/run` | æ‰‹å‹•è§¸ç™¼åŸ·è¡Œ |

### ğŸ” é™¤éŒ¯æª¢æŸ¥æ¸…å–®

**JWT å•é¡Œæ’è§£ï¼š**
- â˜‘ï¸ ç¢ºèª secret å’Œ keyId æ­£ç¢º
- â˜‘ï¸ æª¢æŸ¥ token æœªéæœŸï¼ˆ2åˆ†é˜ï¼‰
- â˜‘ï¸ é©—è­‰æ¼”ç®—æ³•ç‚º HS256
- â˜‘ï¸ ç¢ºèª payload æ ¼å¼æ­£ç¢º

**CORS å•é¡Œæ’è§£ï¼š**
- â˜‘ï¸ æ‰€æœ‰ Make åŸŸåå·²åŒ…å«
- â˜‘ï¸ credentials: true å·²è¨­å®š
- â˜‘ï¸ allowedHeaders åŒ…å« Authorization
- â˜‘ï¸ preflight è«‹æ±‚è™•ç†æ­£å¸¸

**API å•é¡Œæ’è§£ï¼š**
- â˜‘ï¸ æª¢æŸ¥ MAKE_ZONE_URL è¨­å®š
- â˜‘ï¸ HTTP ç‹€æ…‹ç¢¼æª¢æŸ¥
- â˜‘ï¸ éŒ¯èª¤å›æ‡‰è™•ç†
- â˜‘ï¸ é€£æ¥è¶…æ™‚è¨­å®š

### ğŸ“Š æ€§èƒ½å„ªåŒ–æé†’

**JWT ç·©å­˜ï¼š**
```javascript
// ç·©å­˜ JWT æå‡æ€§èƒ½ï¼ˆ1åˆ†åŠç·©å­˜ï¼‰
const tokenCache = new Map();
const cacheKey = `${userId}_${Math.floor(Date.now() / 90000)}`;  // 90ç§’å€é–“

if (tokenCache.has(cacheKey)) {
  return tokenCache.get(cacheKey);
}

const token = generateJWT(userId);
tokenCache.set(cacheKey, token);
return token;
```

**API é€£æ¥æ± ï¼š**
```javascript
// é‡ç”¨ HTTP é€£æ¥æå‡æ€§èƒ½
const keepAliveAgent = new https.Agent({
  keepAlive: true,
  maxSockets: 10,
  timeout: 60000
});

fetch(url, {
  agent: keepAliveAgent,
  timeout: 30000
});
```

### ğŸ›¡ï¸ å®‰å…¨æ€§æª¢æŸ¥æ¸…å–®

- â˜‘ï¸ **ä¸åœ¨å‰ç«¯æš´éœ² Secret**
- â˜‘ï¸ **ä½¿ç”¨ HTTPS æ–¼ç”Ÿç”¢ç’°å¢ƒ**
- â˜‘ï¸ **é©—è­‰æ‰€æœ‰ç”¨æˆ¶è¼¸å…¥**
- â˜‘ï¸ **å¯¦ä½œé€Ÿç‡é™åˆ¶**
- â˜‘ï¸ **è¨˜éŒ„å®‰å…¨äº‹ä»¶**
- â˜‘ï¸ **å®šæœŸè¼ªæ› Secret**

### ğŸ“ˆ ç›£æ§æŒ‡æ¨™

**é—œéµæŒ‡æ¨™ï¼š**
- JWT ç”Ÿæˆæ™‚é–“ < 10ms
- API å›æ‡‰æ™‚é–“ < 2ç§’
- éŒ¯èª¤ç‡ < 1%
- æˆåŠŸç‡ > 99.5%

**å‘Šè­¦é—¾å€¼ï¼š**
- API å›æ‡‰æ™‚é–“ > 5ç§’
- éŒ¯èª¤ç‡ > 5%
- JWT é©—è­‰å¤±æ•— > 10/åˆ†é˜
- è¨˜æ†¶é«”ä½¿ç”¨ > 80%

### ğŸ“ ç·Šæ€¥è¯çµ¡è³‡è¨Š

**Make æ”¯æ´ï¼š**
- æ–‡æª”ï¼šhttps://docs.make.com
- ç¤¾å€ï¼šhttps://community.make.com
- ç·Šæ€¥æ”¯æ´ï¼šsupport@make.com

**ç³»çµ±ç‹€æ…‹ï¼š**
- ç‹€æ…‹é ï¼šhttps://status.make.com
- ç·šä¸Šæ–‡æª”ï¼šhttps://docs.make.com/bridge

### ğŸš€ ä¸‹ä¸€æ­¥

åŸºç¤æ•´åˆå®Œæˆå¾Œï¼Œæ¥ä¸‹ä¾†å°‡å­¸ç¿’å¦‚ä½•å»ºç«‹å®Œæ•´çš„å°ˆæ¡ˆå¯¦ä½œã€‚ç¬¬5ç« å°‡æŒ‡å°æ‚¨å®Œæˆåˆç´šå°ˆæ¡ˆçš„ç«¯åˆ°ç«¯é–‹ç™¼ã€‚