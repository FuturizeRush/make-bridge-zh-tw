# 第十章：架構設計與最佳實踐

## 本章概述

本章深入探討 Make Bridge 的企業級架構設計模式，涵蓋安全性、擴展性、效能優化等關鍵面向。我們將從實際案例出發，提供經過驗證的最佳實踐指南。

> 🏢 **企業級開發提示**
> 
> 本章專為需要建立穩定、可擴展產品級系統的開發者而設計。如果您正在尋找快速原型或小型專案的解決方案，建議先參考第4-6章的內容。

## 10.1 企業級架構模式

### 10.1.1 微服務架構設計

> 🏭 **企業級架構概念**
> 
> - **微服務架構**：將一個大型系統拆分成多個獨立的小服務，每個服務負責特定功能
> - **API 閘道 (Gateway)**：統一的入口點，負責路由請求到正確的微服務
> - **速率限制 (Rate Limiting)**：防止惡意攻擊，限制單位時間內的請求數量
> - **負載均衡**：將請求分散到多個伺服器，提升系統整體效能

```javascript
// services/bridge-gateway/index.js
const express = require('express');
const httpProxy = require('http-proxy-middleware');
const jwt = require('jsonwebtoken');
const rateLimit = require('express-rate-limit');

class BridgeGateway {
    constructor() {
        this.app = express();
        this.setupMiddleware();
        this.setupRoutes();
    }

    setupMiddleware() {
        // 速率限制
        const limiter = rateLimit({
            windowMs: 15 * 60 * 1000,
            max: 100,
            message: 'Too many requests'
        });

        this.app.use('/api/', limiter);
        this.app.use(express.json());
        this.app.use(this.authMiddleware);
    }

    authMiddleware(req, res, next) {
        const token = req.headers.authorization?.split(' ')[1];
        
        if (!token) {
            return res.status(401).json({ error: 'No token provided' });
        }

        try {
            const decoded = jwt.verify(token, process.env.JWT_SECRET);
            req.user = decoded;
            next();
        } catch (error) {
            return res.status(403).json({ error: 'Invalid token' });
        }
    }

    setupRoutes() {
        // 路由到不同的微服務
        this.app.use('/api/bridge', httpProxy({
            target: process.env.BRIDGE_SERVICE_URL,
            changeOrigin: true
        }));

        this.app.use('/api/templates', httpProxy({
            target: process.env.TEMPLATE_SERVICE_URL,
            changeOrigin: true
        }));

        this.app.use('/api/scenarios', httpProxy({
            target: process.env.SCENARIO_SERVICE_URL,
            changeOrigin: true
        }));
    }

    start(port = 3000) {
        this.app.listen(port, () => {
            console.log(`Gateway running on port ${port}`);
        });
    }
}

module.exports = BridgeGateway;
```

### 10.1.2 事件驅動架構

```javascript
// services/event-bus/index.js
const EventEmitter = require('events');
const Redis = require('ioredis');

class DistributedEventBus extends EventEmitter {
    constructor() {
        super();
        this.publisher = new Redis();
        this.subscriber = new Redis();
        this.setupSubscriptions();
    }

    setupSubscriptions() {
        this.subscriber.on('message', (channel, message) => {
            const data = JSON.parse(message);
            this.emit(channel, data);
        });
    }

    async publish(event, data) {
        const message = JSON.stringify({
            event,
            data,
            timestamp: new Date().toISOString(),
            source: process.env.SERVICE_NAME
        });

        await this.publisher.publish(event, message);
        
        // 本地事件
        this.emit(event, data);
    }

    async subscribe(event, handler) {
        await this.subscriber.subscribe(event);
        this.on(event, handler);
    }
}

// 使用範例
const eventBus = new DistributedEventBus();

// 訂閱場景建立事件
eventBus.subscribe('scenario.created', async (data) => {
    console.log('New scenario created:', data);
    // 觸發相關處理
    await updateAnalytics(data);
    await notifyWebhooks(data);
});

// 發布事件
eventBus.publish('scenario.created', {
    scenarioId: 'scn_123',
    templateId: 'tpl_456',
    userId: 'usr_789'
});
```

### 10.1.3 CQRS 模式實作

```javascript
// services/cqrs/commands/index.js
class CreateScenarioCommand {
    constructor(data) {
        this.templateId = data.templateId;
        this.userId = data.userId;
        this.config = data.config;
        this.timestamp = new Date();
    }

    validate() {
        if (!this.templateId || !this.userId) {
            throw new Error('Missing required fields');
        }
    }
}

class CommandBus {
    constructor() {
        this.handlers = new Map();
    }

    register(commandType, handler) {
        this.handlers.set(commandType, handler);
    }

    async execute(command) {
        const handler = this.handlers.get(command.constructor);
        if (!handler) {
            throw new Error(`No handler for ${command.constructor.name}`);
        }

        command.validate();
        return await handler.handle(command);
    }
}

// services/cqrs/queries/index.js
class GetScenarioQuery {
    constructor(scenarioId, userId) {
        this.scenarioId = scenarioId;
        this.userId = userId;
    }
}

class QueryBus {
    constructor() {
        this.handlers = new Map();
    }

    register(queryType, handler) {
        this.handlers.set(queryType, handler);
    }

    async execute(query) {
        const handler = this.handlers.get(query.constructor);
        if (!handler) {
            throw new Error(`No handler for ${query.constructor.name}`);
        }

        return await handler.handle(query);
    }
}

// 使用範例
const commandBus = new CommandBus();
const queryBus = new QueryBus();

// 註冊處理器
commandBus.register(CreateScenarioCommand, createScenarioHandler);
queryBus.register(GetScenarioQuery, getScenarioHandler);

// 執行命令
const command = new CreateScenarioCommand({
    templateId: 'tpl_123',
    userId: 'usr_456',
    config: { webhookUrl: 'https://api.example.com' }
});

const result = await commandBus.execute(command);
```

## 10.2 安全性最佳實踐

### 10.2.1 完整的安全架構

```javascript
// security/authentication.js
const crypto = require('crypto');
const jwt = require('jsonwebtoken');

class SecurityManager {
    constructor() {
        this.initializeKeys();
    }

    initializeKeys() {
        // 金鑰輪換機制
        this.keys = {
            current: process.env.JWT_SECRET,
            previous: process.env.JWT_SECRET_PREVIOUS,
            rotation: new Date(process.env.KEY_ROTATION_DATE)
        };
    }

    generateSecureToken(userId, permissions = []) {
        const jti = crypto.randomUUID();
        
        const payload = {
            sub: userId,
            jti,
            permissions,
            iss: 'make-bridge',
            aud: 'make-bridge-api',
            iat: Math.floor(Date.now() / 1000),
            nbf: Math.floor(Date.now() / 1000) - 10 // 允許10秒時鐘偏差
        };

        return jwt.sign(payload, this.keys.current, {
            expiresIn: '2m',
            algorithm: 'HS256',
            keyid: process.env.KEY_ID
        });
    }

    validateToken(token) {
        try {
            // 嘗試使用當前金鑰
            return jwt.verify(token, this.keys.current, {
                algorithms: ['HS256'],
                issuer: 'make-bridge',
                audience: 'make-bridge-api'
            });
        } catch (error) {
            // 嘗試使用前一個金鑰（金鑰輪換期間）
            if (this.keys.previous) {
                return jwt.verify(token, this.keys.previous, {
                    algorithms: ['HS256'],
                    issuer: 'make-bridge',
                    audience: 'make-bridge-api'
                });
            }
            throw error;
        }
    }

    // 防止 JWT 重複使用
    async checkJTI(jti) {
        const used = await redis.get(`jti:${jti}`);
        if (used) {
            throw new Error('Token already used');
        }
        
        // 標記為已使用，設定過期時間比 JWT 稍長
        await redis.setex(`jti:${jti}`, 150, '1');
    }
}

// security/encryption.js
class EncryptionService {
    constructor() {
        this.algorithm = 'aes-256-gcm';
        this.key = Buffer.from(process.env.ENCRYPTION_KEY, 'hex');
    }

    encrypt(text) {
        const iv = crypto.randomBytes(16);
        const cipher = crypto.createCipheriv(this.algorithm, this.key, iv);
        
        let encrypted = cipher.update(text, 'utf8', 'hex');
        encrypted += cipher.final('hex');
        
        const authTag = cipher.getAuthTag();
        
        return {
            encrypted,
            iv: iv.toString('hex'),
            authTag: authTag.toString('hex')
        };
    }

    decrypt(encryptedData) {
        const decipher = crypto.createDecipheriv(
            this.algorithm,
            this.key,
            Buffer.from(encryptedData.iv, 'hex')
        );
        
        decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'hex'));
        
        let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
        decrypted += decipher.final('utf8');
        
        return decrypted;
    }
}
```

### 10.2.2 API 安全防護

```javascript
// security/api-protection.js
const helmet = require('helmet');
const cors = require('cors');
const { RateLimiterRedis } = require('rate-limiter-flexible');

class APIProtection {
    constructor(app, redis) {
        this.app = app;
        this.redis = redis;
        this.setupSecurityHeaders();
        this.setupRateLimiting();
        this.setupInputValidation();
    }

    setupSecurityHeaders() {
        // Helmet 安全標頭
        this.app.use(helmet({
            contentSecurityPolicy: {
                directives: {
                    defaultSrc: ["'self'"],
                    scriptSrc: ["'self'", "'unsafe-inline'", "https://integrations.make.com"],
                    styleSrc: ["'self'", "'unsafe-inline'"],
                    imgSrc: ["'self'", "data:", "https:"],
                    connectSrc: ["'self'", "https://api.make.com"],
                    frameSrc: ["'self'", "https://integrations.make.com"],
                    frameAncestors: ["'self'"]
                }
            },
            hsts: {
                maxAge: 31536000,
                includeSubDomains: true,
                preload: true
            }
        }));

        // CORS 設定
        const corsOptions = {
            origin: (origin, callback) => {
                const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',') || [];
                if (!origin || allowedOrigins.includes(origin)) {
                    callback(null, true);
                } else {
                    callback(new Error('Not allowed by CORS'));
                }
            },
            credentials: true,
            maxAge: 86400 // 24小時
        };

        this.app.use(cors(corsOptions));
    }

    setupRateLimiting() {
        // 不同端點的速率限制
        const rateLimiters = {
            general: new RateLimiterRedis({
                storeClient: this.redis,
                keyPrefix: 'rl:general',
                points: 100,
                duration: 900, // 15分鐘
                blockDuration: 900
            }),
            auth: new RateLimiterRedis({
                storeClient: this.redis,
                keyPrefix: 'rl:auth',
                points: 5,
                duration: 900,
                blockDuration: 3600 // 1小時
            }),
            api: new RateLimiterRedis({
                storeClient: this.redis,
                keyPrefix: 'rl:api',
                points: 1000,
                duration: 3600,
                blockDuration: 3600
            })
        };

        // 應用速率限制中間件
        this.app.use('/auth/*', this.createRateLimitMiddleware(rateLimiters.auth));
        this.app.use('/api/*', this.createRateLimitMiddleware(rateLimiters.api));
        this.app.use('*', this.createRateLimitMiddleware(rateLimiters.general));
    }

    createRateLimitMiddleware(rateLimiter) {
        return async (req, res, next) => {
            try {
                const key = req.ip || req.headers['x-forwarded-for'];
                await rateLimiter.consume(key);
                next();
            } catch (rejRes) {
                res.status(429).json({
                    error: 'Too many requests',
                    retryAfter: Math.round(rejRes.msBeforeNext / 1000) || 60
                });
            }
        };
    }

    setupInputValidation() {
        // SQL 注入防護
        this.app.use((req, res, next) => {
            const suspicious = /(\b(union|select|insert|update|delete|drop)\b)/gi;
            const checkValue = (value) => {
                if (typeof value === 'string' && suspicious.test(value)) {
                    return true;
                }
                return false;
            };

            const checkObject = (obj) => {
                for (const key in obj) {
                    if (typeof obj[key] === 'object') {
                        if (checkObject(obj[key])) return true;
                    } else if (checkValue(obj[key])) {
                        return true;
                    }
                }
                return false;
            };

            if (checkObject(req.body) || checkObject(req.query) || checkObject(req.params)) {
                return res.status(400).json({ error: 'Invalid input detected' });
            }

            next();
        });
    }
}
```

## 10.3 效能優化策略

### 10.3.1 快取架構設計

```javascript
// cache/multi-layer-cache.js
class MultiLayerCache {
    constructor() {
        this.memoryCache = new Map();
        this.redisCache = new Redis();
        this.cacheConfig = {
            memory: {
                maxSize: 1000,
                ttl: 60 // 1分鐘
            },
            redis: {
                ttl: 3600 // 1小時
            }
        };
    }

    async get(key) {
        // L1: 記憶體快取
        const memoryValue = this.getFromMemory(key);
        if (memoryValue) {
            return memoryValue;
        }

        // L2: Redis 快取
        const redisValue = await this.getFromRedis(key);
        if (redisValue) {
            // 回填記憶體快取
            this.setInMemory(key, redisValue);
            return redisValue;
        }

        return null;
    }

    async set(key, value, options = {}) {
        const serialized = JSON.stringify(value);
        
        // 同時寫入兩層快取
        this.setInMemory(key, value);
        await this.setInRedis(key, serialized, options.ttl);
    }

    getFromMemory(key) {
        const item = this.memoryCache.get(key);
        if (!item) return null;

        if (Date.now() > item.expiry) {
            this.memoryCache.delete(key);
            return null;
        }

        return item.value;
    }

    setInMemory(key, value) {
        // LRU 淘汰策略
        if (this.memoryCache.size >= this.cacheConfig.memory.maxSize) {
            const firstKey = this.memoryCache.keys().next().value;
            this.memoryCache.delete(firstKey);
        }

        this.memoryCache.set(key, {
            value,
            expiry: Date.now() + (this.cacheConfig.memory.ttl * 1000)
        });
    }

    async getFromRedis(key) {
        const value = await this.redisCache.get(key);
        return value ? JSON.parse(value) : null;
    }

    async setInRedis(key, value, ttl) {
        const finalTTL = ttl || this.cacheConfig.redis.ttl;
        await this.redisCache.setex(key, finalTTL, value);
    }

    // 快取預熱
    async warmup(keys) {
        const promises = keys.map(async (key) => {
            const value = await this.fetchFromSource(key);
            if (value) {
                await this.set(key, value);
            }
        });

        await Promise.all(promises);
    }

    // 快取失效策略
    async invalidate(pattern) {
        // 清除記憶體快取
        for (const [key] of this.memoryCache) {
            if (key.match(pattern)) {
                this.memoryCache.delete(key);
            }
        }

        // 清除 Redis 快取
        const keys = await this.redisCache.keys(pattern);
        if (keys.length > 0) {
            await this.redisCache.del(...keys);
        }
    }
}

// cache/cache-aside-pattern.js
class CacheAsideService {
    constructor(cache, database) {
        this.cache = cache;
        this.database = database;
    }

    async getScenario(scenarioId) {
        const cacheKey = `scenario:${scenarioId}`;
        
        // 嘗試從快取獲取
        let scenario = await this.cache.get(cacheKey);
        
        if (!scenario) {
            // 快取未命中，從資料庫獲取
            scenario = await this.database.findScenario(scenarioId);
            
            if (scenario) {
                // 寫入快取
                await this.cache.set(cacheKey, scenario, { ttl: 3600 });
            }
        }
        
        return scenario;
    }

    async updateScenario(scenarioId, data) {
        // 更新資料庫
        const updated = await this.database.updateScenario(scenarioId, data);
        
        // 使快取失效
        const cacheKey = `scenario:${scenarioId}`;
        await this.cache.invalidate(cacheKey);
        
        // 可選：立即重新載入快取
        await this.cache.set(cacheKey, updated, { ttl: 3600 });
        
        return updated;
    }
}
```

### 10.3.2 資料庫優化

```javascript
// database/connection-pool.js
const { Pool } = require('pg');

class DatabaseManager {
    constructor() {
        this.pool = new Pool({
            host: process.env.DB_HOST,
            port: process.env.DB_PORT,
            database: process.env.DB_NAME,
            user: process.env.DB_USER,
            password: process.env.DB_PASSWORD,
            max: 20, // 最大連線數
            idleTimeoutMillis: 30000,
            connectionTimeoutMillis: 2000,
        });

        this.setupPoolEvents();
    }

    setupPoolEvents() {
        this.pool.on('error', (err, client) => {
            console.error('Unexpected error on idle client', err);
        });

        this.pool.on('connect', (client) => {
            console.log('New client connected');
        });
    }

    async query(text, params) {
        const start = Date.now();
        const res = await this.pool.query(text, params);
        const duration = Date.now() - start;
        
        // 記錄慢查詢
        if (duration > 1000) {
            console.log('Slow query detected:', {
                text,
                duration,
                rows: res.rowCount
            });
        }
        
        return res;
    }

    // 批次操作優化
    async batchInsert(table, records) {
        if (records.length === 0) return;

        const columns = Object.keys(records[0]);
        const values = [];
        const placeholders = [];

        records.forEach((record, index) => {
            const rowPlaceholders = columns.map((col, colIndex) => {
                const paramIndex = index * columns.length + colIndex + 1;
                values.push(record[col]);
                return `$${paramIndex}`;
            });
            placeholders.push(`(${rowPlaceholders.join(', ')})`);
        });

        const query = `
            INSERT INTO ${table} (${columns.join(', ')})
            VALUES ${placeholders.join(', ')}
            ON CONFLICT DO NOTHING
            RETURNING *
        `;

        return await this.query(query, values);
    }

    // 讀寫分離
    async getReadReplica() {
        if (!this.readPool) {
            this.readPool = new Pool({
                host: process.env.DB_READ_HOST,
                // ... 其他設定
            });
        }
        return this.readPool;
    }

    async queryRead(text, params) {
        const pool = await this.getReadReplica();
        return await pool.query(text, params);
    }
}

// database/query-optimizer.js
class QueryOptimizer {
    // 查詢計劃快取
    constructor() {
        this.queryPlanCache = new Map();
    }

    async optimizeQuery(query, params) {
        const queryHash = this.hashQuery(query, params);
        
        // 檢查快取的查詢計劃
        if (this.queryPlanCache.has(queryHash)) {
            return this.queryPlanCache.get(queryHash);
        }

        // 分析查詢
        const analysis = await this.analyzeQuery(query);
        
        // 優化建議
        const optimized = this.applyOptimizations(query, analysis);
        
        // 快取結果
        this.queryPlanCache.set(queryHash, optimized);
        
        return optimized;
    }

    analyzeQuery(query) {
        // 使用 EXPLAIN ANALYZE
        return db.query(`EXPLAIN ANALYZE ${query}`);
    }

    applyOptimizations(query, analysis) {
        let optimized = query;

        // 加入必要的索引提示
        if (analysis.shouldUseIndex) {
            optimized = this.addIndexHint(optimized, analysis.recommendedIndex);
        }

        // 優化 JOIN 順序
        if (analysis.joinOptimization) {
            optimized = this.reorderJoins(optimized, analysis.joinOrder);
        }

        return optimized;
    }
}
```

### 10.3.3 非同步處理優化

```javascript
// async/job-queue.js
const Bull = require('bull');

class JobQueueManager {
    constructor() {
        this.queues = new Map();
        this.initializeQueues();
    }

    initializeQueues() {
        // 建立不同優先級的佇列
        this.createQueue('high-priority', {
            redis: {
                host: process.env.REDIS_HOST,
                port: process.env.REDIS_PORT
            },
            defaultJobOptions: {
                removeOnComplete: true,
                removeOnFail: false,
                attempts: 3,
                backoff: {
                    type: 'exponential',
                    delay: 2000
                }
            }
        });

        this.createQueue('default', {
            redis: {
                host: process.env.REDIS_HOST,
                port: process.env.REDIS_PORT
            }
        });

        this.createQueue('low-priority', {
            redis: {
                host: process.env.REDIS_HOST,
                port: process.env.REDIS_PORT
            },
            defaultJobOptions: {
                delay: 5000 // 延遲5秒執行
            }
        });
    }

    createQueue(name, options) {
        const queue = new Bull(name, options);
        
        // 設定並發處理
        queue.process(10, async (job) => {
            return await this.processJob(job);
        });

        // 事件監聽
        queue.on('completed', (job, result) => {
            console.log(`Job ${job.id} completed:`, result);
        });

        queue.on('failed', (job, err) => {
            console.error(`Job ${job.id} failed:`, err);
        });

        this.queues.set(name, queue);
    }

    async addJob(queueName, jobType, data, options = {}) {
        const queue = this.queues.get(queueName);
        if (!queue) {
            throw new Error(`Queue ${queueName} not found`);
        }

        return await queue.add(jobType, {
            type: jobType,
            data,
            timestamp: new Date().toISOString()
        }, options);
    }

    async processJob(job) {
        const { type, data } = job.data;

        switch (type) {
            case 'scenario.execute':
                return await this.executeScenario(data);
            case 'webhook.send':
                return await this.sendWebhook(data);
            case 'report.generate':
                return await this.generateReport(data);
            default:
                throw new Error(`Unknown job type: ${type}`);
        }
    }

    // 批次處理優化
    async processBatch(jobs) {
        const batchSize = 50;
        const results = [];

        for (let i = 0; i < jobs.length; i += batchSize) {
            const batch = jobs.slice(i, i + batchSize);
            const batchResults = await Promise.all(
                batch.map(job => this.processJob(job))
            );
            results.push(...batchResults);
        }

        return results;
    }
}

// async/circuit-breaker.js
class CircuitBreaker {
    constructor(options = {}) {
        this.failureThreshold = options.failureThreshold || 5;
        this.resetTimeout = options.resetTimeout || 60000;
        this.state = 'CLOSED';
        this.failures = 0;
        this.nextAttempt = Date.now();
    }

    async call(fn, ...args) {
        if (this.state === 'OPEN') {
            if (Date.now() < this.nextAttempt) {
                throw new Error('Circuit breaker is OPEN');
            }
            this.state = 'HALF_OPEN';
        }

        try {
            const result = await fn(...args);
            this.onSuccess();
            return result;
        } catch (error) {
            this.onFailure();
            throw error;
        }
    }

    onSuccess() {
        this.failures = 0;
        if (this.state === 'HALF_OPEN') {
            this.state = 'CLOSED';
        }
    }

    onFailure() {
        this.failures++;
        if (this.failures >= this.failureThreshold) {
            this.state = 'OPEN';
            this.nextAttempt = Date.now() + this.resetTimeout;
        }
    }
}
```

## 10.4 擴展性設計

### 10.4.1 水平擴展架構

```javascript
// scaling/load-balancer.js
class LoadBalancer {
    constructor() {
        this.servers = [];
        this.currentIndex = 0;
        this.healthChecker = new HealthChecker();
    }

    addServer(server) {
        this.servers.push({
            ...server,
            healthy: true,
            weight: server.weight || 1,
            activeConnections: 0
        });
    }

    // 輪詢演算法
    roundRobin() {
        const healthyServers = this.servers.filter(s => s.healthy);
        if (healthyServers.length === 0) {
            throw new Error('No healthy servers available');
        }

        const server = healthyServers[this.currentIndex % healthyServers.length];
        this.currentIndex++;
        
        return server;
    }

    // 最少連線演算法
    leastConnections() {
        const healthyServers = this.servers.filter(s => s.healthy);
        if (healthyServers.length === 0) {
            throw new Error('No healthy servers available');
        }

        return healthyServers.reduce((min, server) => 
            server.activeConnections < min.activeConnections ? server : min
        );
    }

    // 加權輪詢演算法
    weightedRoundRobin() {
        const healthyServers = this.servers.filter(s => s.healthy);
        if (healthyServers.length === 0) {
            throw new Error('No healthy servers available');
        }

        const totalWeight = healthyServers.reduce((sum, s) => sum + s.weight, 0);
        let random = Math.random() * totalWeight;

        for (const server of healthyServers) {
            random -= server.weight;
            if (random <= 0) {
                return server;
            }
        }

        return healthyServers[0];
    }

    async healthCheck() {
        const checks = this.servers.map(async (server) => {
            const isHealthy = await this.healthChecker.check(server.url);
            server.healthy = isHealthy;
        });

        await Promise.all(checks);
    }
}

// scaling/session-manager.js
class DistributedSessionManager {
    constructor(redis) {
        this.redis = redis;
        this.sessionTimeout = 3600; // 1小時
    }

    async createSession(userId, data) {
        const sessionId = crypto.randomUUID();
        const sessionData = {
            userId,
            data,
            createdAt: new Date().toISOString(),
            lastAccessed: new Date().toISOString()
        };

        await this.redis.setex(
            `session:${sessionId}`,
            this.sessionTimeout,
            JSON.stringify(sessionData)
        );

        return sessionId;
    }

    async getSession(sessionId) {
        const data = await this.redis.get(`session:${sessionId}`);
        if (!data) return null;

        const session = JSON.parse(data);
        
        // 更新最後存取時間
        session.lastAccessed = new Date().toISOString();
        await this.redis.setex(
            `session:${sessionId}`,
            this.sessionTimeout,
            JSON.stringify(session)
        );

        return session;
    }

    async destroySession(sessionId) {
        await this.redis.del(`session:${sessionId}`);
    }

    // 會話複製
    async replicateSession(sessionId, targetNode) {
        const session = await this.getSession(sessionId);
        if (!session) return;

        // 發送到目標節點
        await axios.post(`${targetNode}/api/sessions/replicate`, {
            sessionId,
            session
        });
    }
}
```

### 10.4.2 分散式系統設計

```javascript
// distributed/coordinator.js
const ZooKeeper = require('node-zookeeper-client');

class DistributedCoordinator {
    constructor() {
        this.client = ZooKeeper.createClient(process.env.ZOOKEEPER_URL);
        this.setupClient();
    }

    setupClient() {
        this.client.on('connected', () => {
            console.log('Connected to ZooKeeper');
            this.registerNode();
        });

        this.client.on('disconnected', () => {
            console.log('Disconnected from ZooKeeper');
        });

        this.client.connect();
    }

    async registerNode() {
        const nodePath = `/services/make-bridge/nodes/${process.env.NODE_ID}`;
        const nodeData = Buffer.from(JSON.stringify({
            id: process.env.NODE_ID,
            host: process.env.NODE_HOST,
            port: process.env.NODE_PORT,
            startTime: new Date().toISOString()
        }));

        await this.createPath(nodePath, nodeData, ZooKeeper.CreateMode.EPHEMERAL);
    }

    async electLeader() {
        const electionPath = '/services/make-bridge/election';
        
        try {
            // 嘗試建立領導節點
            await this.createPath(
                `${electionPath}/leader`,
                Buffer.from(process.env.NODE_ID),
                ZooKeeper.CreateMode.EPHEMERAL
            );
            
            console.log('This node is now the leader');
            return true;
        } catch (error) {
            if (error.code === ZooKeeper.Exception.NODE_EXISTS) {
                console.log('Another node is already the leader');
                return false;
            }
            throw error;
        }
    }

    async distributedLock(resource, callback) {
        const lockPath = `/locks/${resource}`;
        let lockAcquired = false;

        try {
            await this.createPath(
                lockPath,
                Buffer.from(process.env.NODE_ID),
                ZooKeeper.CreateMode.EPHEMERAL
            );
            
            lockAcquired = true;
            return await callback();
        } finally {
            if (lockAcquired) {
                await this.deletePath(lockPath);
            }
        }
    }
}

// distributed/sharding.js
class ShardingManager {
    constructor(shards) {
        this.shards = shards;
        this.hashRing = new ConsistentHash();
        this.initializeHashRing();
    }

    initializeHashRing() {
        this.shards.forEach(shard => {
            // 每個分片加入多個虛擬節點
            for (let i = 0; i < 150; i++) {
                this.hashRing.add(`${shard.id}-${i}`, shard);
            }
        });
    }

    getShard(key) {
        return this.hashRing.get(key);
    }

    async redistribute(newShards) {
        const oldShards = this.shards;
        this.shards = newShards;
        this.initializeHashRing();

        // 資料遷移
        for (const oldShard of oldShards) {
            const data = await this.fetchAllData(oldShard);
            
            for (const item of data) {
                const newShard = this.getShard(item.key);
                if (newShard.id !== oldShard.id) {
                    await this.migrateData(item, oldShard, newShard);
                }
            }
        }
    }
}

class ConsistentHash {
    constructor() {
        this.ring = new Map();
        this.sortedKeys = [];
    }

    add(key, value) {
        const hash = this.hash(key);
        this.ring.set(hash, value);
        this.sortedKeys.push(hash);
        this.sortedKeys.sort((a, b) => a - b);
    }

    get(key) {
        if (this.ring.size === 0) return null;

        const hash = this.hash(key);
        const index = this.binarySearch(hash);
        const targetHash = this.sortedKeys[index];
        
        return this.ring.get(targetHash);
    }

    hash(key) {
        // 使用 MurmurHash3 或類似演算法
        return murmurHash3(key);
    }

    binarySearch(hash) {
        let left = 0;
        let right = this.sortedKeys.length - 1;

        while (left <= right) {
            const mid = Math.floor((left + right) / 2);
            if (this.sortedKeys[mid] === hash) return mid;
            if (this.sortedKeys[mid] < hash) left = mid + 1;
            else right = mid - 1;
        }

        return left % this.sortedKeys.length;
    }
}
```

## 10.5 監控與可觀測性

### 10.5.1 分散式追蹤

```javascript
// monitoring/tracing.js
const opentelemetry = require('@opentelemetry/api');
const { NodeTracerProvider } = require('@opentelemetry/sdk-trace-node');
const { JaegerExporter } = require('@opentelemetry/exporter-jaeger');

class TracingService {
    constructor() {
        this.provider = new NodeTracerProvider();
        this.setupExporter();
        this.tracer = opentelemetry.trace.getTracer('make-bridge', '1.0.0');
    }

    setupExporter() {
        const jaegerExporter = new JaegerExporter({
            endpoint: process.env.JAEGER_ENDPOINT,
            serviceName: 'make-bridge'
        });

        this.provider.addSpanProcessor(
            new opentelemetry.sdk.trace.SimpleSpanProcessor(jaegerExporter)
        );

        this.provider.register();
    }

    startSpan(name, options = {}) {
        return this.tracer.startSpan(name, options);
    }

    // 自動追蹤 HTTP 請求
    traceMiddleware() {
        return (req, res, next) => {
            const span = this.startSpan(`${req.method} ${req.path}`, {
                kind: opentelemetry.SpanKind.SERVER,
                attributes: {
                    'http.method': req.method,
                    'http.url': req.url,
                    'http.target': req.path,
                    'http.host': req.hostname,
                    'http.scheme': req.protocol,
                    'http.user_agent': req.headers['user-agent']
                }
            });

            // 注入追蹤上下文
            req.span = span;

            // 攔截響應
            const originalSend = res.send;
            res.send = function(data) {
                span.setAttributes({
                    'http.status_code': res.statusCode,
                    'http.response_size': Buffer.byteLength(data)
                });

                if (res.statusCode >= 400) {
                    span.setStatus({
                        code: opentelemetry.SpanStatusCode.ERROR,
                        message: `HTTP ${res.statusCode}`
                    });
                }

                span.end();
                originalSend.call(this, data);
            };

            next();
        };
    }

    // 追蹤資料庫操作
    async traceDatabase(operation, query, params) {
        const span = this.startSpan(`db.${operation}`, {
            kind: opentelemetry.SpanKind.CLIENT,
            attributes: {
                'db.system': 'postgresql',
                'db.operation': operation,
                'db.statement': query
            }
        });

        try {
            const result = await this.executeQuery(query, params);
            span.setStatus({ code: opentelemetry.SpanStatusCode.OK });
            return result;
        } catch (error) {
            span.recordException(error);
            span.setStatus({
                code: opentelemetry.SpanStatusCode.ERROR,
                message: error.message
            });
            throw error;
        } finally {
            span.end();
        }
    }
}

// monitoring/metrics.js
const prometheus = require('prom-client');

class MetricsCollector {
    constructor() {
        this.register = new prometheus.Registry();
        this.setupMetrics();
    }

    setupMetrics() {
        // HTTP 請求計數器
        this.httpRequestsTotal = new prometheus.Counter({
            name: 'http_requests_total',
            help: 'Total number of HTTP requests',
            labelNames: ['method', 'route', 'status'],
            registers: [this.register]
        });

        // HTTP 請求持續時間
        this.httpRequestDuration = new prometheus.Histogram({
            name: 'http_request_duration_seconds',
            help: 'Duration of HTTP requests in seconds',
            labelNames: ['method', 'route', 'status'],
            buckets: [0.1, 0.3, 0.5, 0.7, 1, 3, 5, 7, 10],
            registers: [this.register]
        });

        // 活躍場景數量
        this.activeScenariosGauge = new prometheus.Gauge({
            name: 'active_scenarios_total',
            help: 'Total number of active scenarios',
            registers: [this.register]
        });

        // API 呼叫速率
        this.apiCallRate = new prometheus.Counter({
            name: 'api_calls_total',
            help: 'Total number of API calls',
            labelNames: ['endpoint', 'status'],
            registers: [this.register]
        });

        // 系統資源使用
        prometheus.collectDefaultMetrics({ register: this.register });
    }

    metricsMiddleware() {
        return (req, res, next) => {
            const start = Date.now();

            res.on('finish', () => {
                const duration = (Date.now() - start) / 1000;
                const route = req.route?.path || req.path;

                this.httpRequestsTotal.inc({
                    method: req.method,
                    route,
                    status: res.statusCode
                });

                this.httpRequestDuration.observe({
                    method: req.method,
                    route,
                    status: res.statusCode
                }, duration);
            });

            next();
        };
    }

    async getMetrics() {
        return await this.register.metrics();
    }
}
```

### 10.5.2 日誌管理

```javascript
// monitoring/structured-logging.js
const winston = require('winston');
const { ElasticsearchTransport } = require('winston-elasticsearch');

class StructuredLogger {
    constructor() {
        this.logger = this.createLogger();
    }

    createLogger() {
        return winston.createLogger({
            level: process.env.LOG_LEVEL || 'info',
            format: winston.format.combine(
                winston.format.timestamp(),
                winston.format.errors({ stack: true }),
                winston.format.json()
            ),
            defaultMeta: {
                service: 'make-bridge',
                environment: process.env.NODE_ENV,
                nodeId: process.env.NODE_ID
            },
            transports: [
                // 控制台輸出
                new winston.transports.Console({
                    format: winston.format.combine(
                        winston.format.colorize(),
                        winston.format.simple()
                    )
                }),
                // 檔案輸出
                new winston.transports.File({
                    filename: 'logs/error.log',
                    level: 'error',
                    maxsize: 10485760, // 10MB
                    maxFiles: 5
                }),
                new winston.transports.File({
                    filename: 'logs/combined.log',
                    maxsize: 10485760,
                    maxFiles: 5
                }),
                // Elasticsearch
                new ElasticsearchTransport({
                    level: 'info',
                    clientOpts: {
                        node: process.env.ELASTICSEARCH_URL
                    },
                    index: 'make-bridge-logs'
                })
            ]
        });
    }

    // 請求日誌中間件
    requestLogger() {
        return (req, res, next) => {
            const requestId = req.headers['x-request-id'] || crypto.randomUUID();
            req.requestId = requestId;

            // 記錄請求
            this.logger.info('HTTP Request', {
                requestId,
                method: req.method,
                url: req.url,
                headers: req.headers,
                ip: req.ip,
                userAgent: req.headers['user-agent']
            });

            // 記錄響應
            const originalSend = res.send;
            res.send = function(data) {
                const responseTime = Date.now() - req.startTime;

                this.logger.info('HTTP Response', {
                    requestId,
                    statusCode: res.statusCode,
                    responseTime,
                    contentLength: res.get('content-length')
                });

                originalSend.call(this, data);
            }.bind(this);

            req.startTime = Date.now();
            next();
        };
    }

    // 錯誤日誌
    logError(error, context = {}) {
        this.logger.error('Application Error', {
            ...context,
            error: {
                message: error.message,
                stack: error.stack,
                name: error.name
            }
        });
    }

    // 審計日誌
    logAudit(action, userId, details = {}) {
        this.logger.info('Audit Log', {
            type: 'audit',
            action,
            userId,
            timestamp: new Date().toISOString(),
            details
        });
    }
}
```

## 10.6 生產環境部署

### 10.6.1 容器化部署

```dockerfile
# Dockerfile
FROM node:18-alpine AS builder

WORKDIR /app

# 安裝依賴
COPY package*.json ./
RUN npm ci --only=production

# 複製應用程式碼
COPY . .

# 建置階段
FROM node:18-alpine

WORKDIR /app

# 安裝執行時依賴
RUN apk add --no-cache tini

# 從建置階段複製
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/package*.json ./

# 建立非 root 使用者
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nodejs -u 1001
USER nodejs

# 健康檢查
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD node healthcheck.js

# 使用 tini 作為 init 系統
ENTRYPOINT ["/sbin/tini", "--"]

# 啟動應用
CMD ["node", "dist/index.js"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  make-bridge:
    image: make-bridge:latest
    deploy:
      replicas: 3
      update_config:
        parallelism: 1
        delay: 10s
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
    environment:
      - NODE_ENV=production
      - JWT_SECRET=${JWT_SECRET}
      - DATABASE_URL=${DATABASE_URL}
      - REDIS_URL=${REDIS_URL}
    ports:
      - "3000-3002:3000"
    networks:
      - bridge-network
    depends_on:
      - postgres
      - redis

  postgres:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=makebridge
      - POSTGRES_USER=${DB_USER}
      - POSTGRES_PASSWORD=${DB_PASSWORD}
    volumes:
      - postgres-data:/var/lib/postgresql/data
    networks:
      - bridge-network

  redis:
    image: redis:7-alpine
    command: redis-server --appendonly yes
    volumes:
      - redis-data:/data
    networks:
      - bridge-network

  nginx:
    image: nginx:alpine
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    ports:
      - "80:80"
      - "443:443"
    networks:
      - bridge-network
    depends_on:
      - make-bridge

volumes:
  postgres-data:
  redis-data:

networks:
  bridge-network:
    driver: bridge
```

### 10.6.2 Kubernetes 部署

```yaml
# k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: make-bridge
  namespace: production
spec:
  replicas: 3
  selector:
    matchLabels:
      app: make-bridge
  template:
    metadata:
      labels:
        app: make-bridge
    spec:
      containers:
      - name: make-bridge
        image: make-bridge:latest
        ports:
        - containerPort: 3000
        env:
        - name: NODE_ENV
          value: "production"
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: make-bridge-secrets
              key: jwt-secret
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: make-bridge-secrets
              key: database-url
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: make-bridge-service
  namespace: production
spec:
  selector:
    app: make-bridge
  ports:
  - protocol: TCP
    port: 80
    targetPort: 3000
  type: LoadBalancer

---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: make-bridge-hpa
  namespace: production
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: make-bridge
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
```

## 總結

本章涵蓋了 Make Bridge 的企業級架構設計與最佳實踐，包括：

1. **架構模式**：微服務、事件驅動、CQRS
2. **安全性**：完整的認證授權、API 防護、加密機制
3. **效能優化**：多層快取、資料庫優化、非同步處理
4. **擴展性**：水平擴展、分散式系統、負載平衡
5. **監控**：分散式追蹤、指標收集、結構化日誌
6. **部署**：容器化、Kubernetes、生產環境配置

這些實踐經過實際專案驗證，能夠支援大規模的企業應用部署。

## 下一章預告

在第十一章中，我們將提供完整的 API 參考文檔，詳細說明所有可用的 API 端點、參數和回應格式。