# ç¬¬åç« ï¼šæ¶æ§‹è¨­è¨ˆèˆ‡æœ€ä½³å¯¦è¸

## æœ¬ç« æ¦‚è¿°

æœ¬ç« æ·±å…¥æ¢è¨ Make Bridge çš„ä¼æ¥­ç´šæ¶æ§‹è¨­è¨ˆæ¨¡å¼ï¼Œæ¶µè“‹å®‰å…¨æ€§ã€æ“´å±•æ€§ã€æ•ˆèƒ½å„ªåŒ–ç­‰é—œéµé¢å‘ã€‚æˆ‘å€‘å°‡å¾å¯¦éš›æ¡ˆä¾‹å‡ºç™¼ï¼Œæä¾›ç¶“éé©—è­‰çš„æœ€ä½³å¯¦è¸æŒ‡å—ã€‚

> ğŸ¢ **ä¼æ¥­ç´šé–‹ç™¼æç¤º**
> 
> æœ¬ç« å°ˆç‚ºéœ€è¦å»ºç«‹ç©©å®šã€å¯æ“´å±•ç”¢å“ç´šç³»çµ±çš„é–‹ç™¼è€…è€Œè¨­è¨ˆã€‚å¦‚æœæ‚¨æ­£åœ¨å°‹æ‰¾å¿«é€ŸåŸå‹æˆ–å°å‹å°ˆæ¡ˆçš„è§£æ±ºæ–¹æ¡ˆï¼Œå»ºè­°å…ˆåƒè€ƒç¬¬4-6ç« çš„å…§å®¹ã€‚

## 10.1 ä¼æ¥­ç´šæ¶æ§‹æ¨¡å¼

### 10.1.1 å¾®æœå‹™æ¶æ§‹è¨­è¨ˆ

> ğŸ­ **ä¼æ¥­ç´šæ¶æ§‹æ¦‚å¿µ**
> 
> - **å¾®æœå‹™æ¶æ§‹**ï¼šå°‡ä¸€å€‹å¤§å‹ç³»çµ±æ‹†åˆ†æˆå¤šå€‹ç¨ç«‹çš„å°æœå‹™ï¼Œæ¯å€‹æœå‹™è² è²¬ç‰¹å®šåŠŸèƒ½
> - **API é–˜é“ (Gateway)**ï¼šçµ±ä¸€çš„å…¥å£é»ï¼Œè² è²¬è·¯ç”±è«‹æ±‚åˆ°æ­£ç¢ºçš„å¾®æœå‹™
> - **é€Ÿç‡é™åˆ¶ (Rate Limiting)**ï¼šé˜²æ­¢æƒ¡æ„æ”»æ“Šï¼Œé™åˆ¶å–®ä½æ™‚é–“å…§çš„è«‹æ±‚æ•¸é‡
> - **è² è¼‰å‡è¡¡**ï¼šå°‡è«‹æ±‚åˆ†æ•£åˆ°å¤šå€‹ä¼ºæœå™¨ï¼Œæå‡ç³»çµ±æ•´é«”æ•ˆèƒ½

```javascript
// services/bridge-gateway/index.js
const express = require('express');
const httpProxy = require('http-proxy-middleware');
const jwt = require('jsonwebtoken');
const rateLimit = require('express-rate-limit');

class BridgeGateway {
    constructor() {
        this.app = express();
        this.setupMiddleware();
        this.setupRoutes();
    }

    setupMiddleware() {
        // é€Ÿç‡é™åˆ¶
        const limiter = rateLimit({
            windowMs: 15 * 60 * 1000,
            max: 100,
            message: 'Too many requests'
        });

        this.app.use('/api/', limiter);
        this.app.use(express.json());
        this.app.use(this.authMiddleware);
    }

    authMiddleware(req, res, next) {
        const token = req.headers.authorization?.split(' ')[1];
        
        if (!token) {
            return res.status(401).json({ error: 'No token provided' });
        }

        try {
            const decoded = jwt.verify(token, process.env.JWT_SECRET);
            req.user = decoded;
            next();
        } catch (error) {
            return res.status(403).json({ error: 'Invalid token' });
        }
    }

    setupRoutes() {
        // è·¯ç”±åˆ°ä¸åŒçš„å¾®æœå‹™
        this.app.use('/api/bridge', httpProxy({
            target: process.env.BRIDGE_SERVICE_URL,
            changeOrigin: true
        }));

        this.app.use('/api/templates', httpProxy({
            target: process.env.TEMPLATE_SERVICE_URL,
            changeOrigin: true
        }));

        this.app.use('/api/scenarios', httpProxy({
            target: process.env.SCENARIO_SERVICE_URL,
            changeOrigin: true
        }));
    }

    start(port = 3000) {
        this.app.listen(port, () => {
            console.log(`Gateway running on port ${port}`);
        });
    }
}

module.exports = BridgeGateway;
```

### 10.1.2 äº‹ä»¶é©…å‹•æ¶æ§‹

```javascript
// services/event-bus/index.js
const EventEmitter = require('events');
const Redis = require('ioredis');

class DistributedEventBus extends EventEmitter {
    constructor() {
        super();
        this.publisher = new Redis();
        this.subscriber = new Redis();
        this.setupSubscriptions();
    }

    setupSubscriptions() {
        this.subscriber.on('message', (channel, message) => {
            const data = JSON.parse(message);
            this.emit(channel, data);
        });
    }

    async publish(event, data) {
        const message = JSON.stringify({
            event,
            data,
            timestamp: new Date().toISOString(),
            source: process.env.SERVICE_NAME
        });

        await this.publisher.publish(event, message);
        
        // æœ¬åœ°äº‹ä»¶
        this.emit(event, data);
    }

    async subscribe(event, handler) {
        await this.subscriber.subscribe(event);
        this.on(event, handler);
    }
}

// ä½¿ç”¨ç¯„ä¾‹
const eventBus = new DistributedEventBus();

// è¨‚é–±å ´æ™¯å»ºç«‹äº‹ä»¶
eventBus.subscribe('scenario.created', async (data) => {
    console.log('New scenario created:', data);
    // è§¸ç™¼ç›¸é—œè™•ç†
    await updateAnalytics(data);
    await notifyWebhooks(data);
});

// ç™¼å¸ƒäº‹ä»¶
eventBus.publish('scenario.created', {
    scenarioId: 'scn_123',
    templateId: 'tpl_456',
    userId: 'usr_789'
});
```

### 10.1.3 CQRS æ¨¡å¼å¯¦ä½œ

```javascript
// services/cqrs/commands/index.js
class CreateScenarioCommand {
    constructor(data) {
        this.templateId = data.templateId;
        this.userId = data.userId;
        this.config = data.config;
        this.timestamp = new Date();
    }

    validate() {
        if (!this.templateId || !this.userId) {
            throw new Error('Missing required fields');
        }
    }
}

class CommandBus {
    constructor() {
        this.handlers = new Map();
    }

    register(commandType, handler) {
        this.handlers.set(commandType, handler);
    }

    async execute(command) {
        const handler = this.handlers.get(command.constructor);
        if (!handler) {
            throw new Error(`No handler for ${command.constructor.name}`);
        }

        command.validate();
        return await handler.handle(command);
    }
}

// services/cqrs/queries/index.js
class GetScenarioQuery {
    constructor(scenarioId, userId) {
        this.scenarioId = scenarioId;
        this.userId = userId;
    }
}

class QueryBus {
    constructor() {
        this.handlers = new Map();
    }

    register(queryType, handler) {
        this.handlers.set(queryType, handler);
    }

    async execute(query) {
        const handler = this.handlers.get(query.constructor);
        if (!handler) {
            throw new Error(`No handler for ${query.constructor.name}`);
        }

        return await handler.handle(query);
    }
}

// ä½¿ç”¨ç¯„ä¾‹
const commandBus = new CommandBus();
const queryBus = new QueryBus();

// è¨»å†Šè™•ç†å™¨
commandBus.register(CreateScenarioCommand, createScenarioHandler);
queryBus.register(GetScenarioQuery, getScenarioHandler);

// åŸ·è¡Œå‘½ä»¤
const command = new CreateScenarioCommand({
    templateId: 'tpl_123',
    userId: 'usr_456',
    config: { webhookUrl: 'https://api.example.com' }
});

const result = await commandBus.execute(command);
```

## 10.2 å®‰å…¨æ€§æœ€ä½³å¯¦è¸

### 10.2.1 å®Œæ•´çš„å®‰å…¨æ¶æ§‹

```javascript
// security/authentication.js
const crypto = require('crypto');
const jwt = require('jsonwebtoken');

class SecurityManager {
    constructor() {
        this.initializeKeys();
    }

    initializeKeys() {
        // é‡‘é‘°è¼ªæ›æ©Ÿåˆ¶
        this.keys = {
            current: process.env.JWT_SECRET,
            previous: process.env.JWT_SECRET_PREVIOUS,
            rotation: new Date(process.env.KEY_ROTATION_DATE)
        };
    }

    generateSecureToken(userId, permissions = []) {
        const jti = crypto.randomUUID();
        
        const payload = {
            sub: userId,
            jti,
            permissions,
            iss: 'make-bridge',
            aud: 'make-bridge-api',
            iat: Math.floor(Date.now() / 1000),
            nbf: Math.floor(Date.now() / 1000) - 10 // å…è¨±10ç§’æ™‚é˜åå·®
        };

        return jwt.sign(payload, this.keys.current, {
            expiresIn: '2m',
            algorithm: 'HS256',
            keyid: process.env.KEY_ID
        });
    }

    validateToken(token) {
        try {
            // å˜—è©¦ä½¿ç”¨ç•¶å‰é‡‘é‘°
            return jwt.verify(token, this.keys.current, {
                algorithms: ['HS256'],
                issuer: 'make-bridge',
                audience: 'make-bridge-api'
            });
        } catch (error) {
            // å˜—è©¦ä½¿ç”¨å‰ä¸€å€‹é‡‘é‘°ï¼ˆé‡‘é‘°è¼ªæ›æœŸé–“ï¼‰
            if (this.keys.previous) {
                return jwt.verify(token, this.keys.previous, {
                    algorithms: ['HS256'],
                    issuer: 'make-bridge',
                    audience: 'make-bridge-api'
                });
            }
            throw error;
        }
    }

    // é˜²æ­¢ JWT é‡è¤‡ä½¿ç”¨
    async checkJTI(jti) {
        const used = await redis.get(`jti:${jti}`);
        if (used) {
            throw new Error('Token already used');
        }
        
        // æ¨™è¨˜ç‚ºå·²ä½¿ç”¨ï¼Œè¨­å®šéæœŸæ™‚é–“æ¯” JWT ç¨é•·
        await redis.setex(`jti:${jti}`, 150, '1');
    }
}

// security/encryption.js
class EncryptionService {
    constructor() {
        this.algorithm = 'aes-256-gcm';
        this.key = Buffer.from(process.env.ENCRYPTION_KEY, 'hex');
    }

    encrypt(text) {
        const iv = crypto.randomBytes(16);
        const cipher = crypto.createCipheriv(this.algorithm, this.key, iv);
        
        let encrypted = cipher.update(text, 'utf8', 'hex');
        encrypted += cipher.final('hex');
        
        const authTag = cipher.getAuthTag();
        
        return {
            encrypted,
            iv: iv.toString('hex'),
            authTag: authTag.toString('hex')
        };
    }

    decrypt(encryptedData) {
        const decipher = crypto.createDecipheriv(
            this.algorithm,
            this.key,
            Buffer.from(encryptedData.iv, 'hex')
        );
        
        decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'hex'));
        
        let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
        decrypted += decipher.final('utf8');
        
        return decrypted;
    }
}
```

### 10.2.2 API å®‰å…¨é˜²è­·

```javascript
// security/api-protection.js
const helmet = require('helmet');
const cors = require('cors');
const { RateLimiterRedis } = require('rate-limiter-flexible');

class APIProtection {
    constructor(app, redis) {
        this.app = app;
        this.redis = redis;
        this.setupSecurityHeaders();
        this.setupRateLimiting();
        this.setupInputValidation();
    }

    setupSecurityHeaders() {
        // Helmet å®‰å…¨æ¨™é ­
        this.app.use(helmet({
            contentSecurityPolicy: {
                directives: {
                    defaultSrc: ["'self'"],
                    scriptSrc: ["'self'", "'unsafe-inline'", "https://integrations.make.com"],
                    styleSrc: ["'self'", "'unsafe-inline'"],
                    imgSrc: ["'self'", "data:", "https:"],
                    connectSrc: ["'self'", "https://api.make.com"],
                    frameSrc: ["'self'", "https://integrations.make.com"],
                    frameAncestors: ["'self'"]
                }
            },
            hsts: {
                maxAge: 31536000,
                includeSubDomains: true,
                preload: true
            }
        }));

        // CORS è¨­å®š
        const corsOptions = {
            origin: (origin, callback) => {
                const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',') || [];
                if (!origin || allowedOrigins.includes(origin)) {
                    callback(null, true);
                } else {
                    callback(new Error('Not allowed by CORS'));
                }
            },
            credentials: true,
            maxAge: 86400 // 24å°æ™‚
        };

        this.app.use(cors(corsOptions));
    }

    setupRateLimiting() {
        // ä¸åŒç«¯é»çš„é€Ÿç‡é™åˆ¶
        const rateLimiters = {
            general: new RateLimiterRedis({
                storeClient: this.redis,
                keyPrefix: 'rl:general',
                points: 100,
                duration: 900, // 15åˆ†é˜
                blockDuration: 900
            }),
            auth: new RateLimiterRedis({
                storeClient: this.redis,
                keyPrefix: 'rl:auth',
                points: 5,
                duration: 900,
                blockDuration: 3600 // 1å°æ™‚
            }),
            api: new RateLimiterRedis({
                storeClient: this.redis,
                keyPrefix: 'rl:api',
                points: 1000,
                duration: 3600,
                blockDuration: 3600
            })
        };

        // æ‡‰ç”¨é€Ÿç‡é™åˆ¶ä¸­é–“ä»¶
        this.app.use('/auth/*', this.createRateLimitMiddleware(rateLimiters.auth));
        this.app.use('/api/*', this.createRateLimitMiddleware(rateLimiters.api));
        this.app.use('*', this.createRateLimitMiddleware(rateLimiters.general));
    }

    createRateLimitMiddleware(rateLimiter) {
        return async (req, res, next) => {
            try {
                const key = req.ip || req.headers['x-forwarded-for'];
                await rateLimiter.consume(key);
                next();
            } catch (rejRes) {
                res.status(429).json({
                    error: 'Too many requests',
                    retryAfter: Math.round(rejRes.msBeforeNext / 1000) || 60
                });
            }
        };
    }

    setupInputValidation() {
        // SQL æ³¨å…¥é˜²è­·
        this.app.use((req, res, next) => {
            const suspicious = /(\b(union|select|insert|update|delete|drop)\b)/gi;
            const checkValue = (value) => {
                if (typeof value === 'string' && suspicious.test(value)) {
                    return true;
                }
                return false;
            };

            const checkObject = (obj) => {
                for (const key in obj) {
                    if (typeof obj[key] === 'object') {
                        if (checkObject(obj[key])) return true;
                    } else if (checkValue(obj[key])) {
                        return true;
                    }
                }
                return false;
            };

            if (checkObject(req.body) || checkObject(req.query) || checkObject(req.params)) {
                return res.status(400).json({ error: 'Invalid input detected' });
            }

            next();
        });
    }
}
```

## 10.3 æ•ˆèƒ½å„ªåŒ–ç­–ç•¥

### 10.3.1 å¿«å–æ¶æ§‹è¨­è¨ˆ

```javascript
// cache/multi-layer-cache.js
class MultiLayerCache {
    constructor() {
        this.memoryCache = new Map();
        this.redisCache = new Redis();
        this.cacheConfig = {
            memory: {
                maxSize: 1000,
                ttl: 60 // 1åˆ†é˜
            },
            redis: {
                ttl: 3600 // 1å°æ™‚
            }
        };
    }

    async get(key) {
        // L1: è¨˜æ†¶é«”å¿«å–
        const memoryValue = this.getFromMemory(key);
        if (memoryValue) {
            return memoryValue;
        }

        // L2: Redis å¿«å–
        const redisValue = await this.getFromRedis(key);
        if (redisValue) {
            // å›å¡«è¨˜æ†¶é«”å¿«å–
            this.setInMemory(key, redisValue);
            return redisValue;
        }

        return null;
    }

    async set(key, value, options = {}) {
        const serialized = JSON.stringify(value);
        
        // åŒæ™‚å¯«å…¥å…©å±¤å¿«å–
        this.setInMemory(key, value);
        await this.setInRedis(key, serialized, options.ttl);
    }

    getFromMemory(key) {
        const item = this.memoryCache.get(key);
        if (!item) return null;

        if (Date.now() > item.expiry) {
            this.memoryCache.delete(key);
            return null;
        }

        return item.value;
    }

    setInMemory(key, value) {
        // LRU æ·˜æ±°ç­–ç•¥
        if (this.memoryCache.size >= this.cacheConfig.memory.maxSize) {
            const firstKey = this.memoryCache.keys().next().value;
            this.memoryCache.delete(firstKey);
        }

        this.memoryCache.set(key, {
            value,
            expiry: Date.now() + (this.cacheConfig.memory.ttl * 1000)
        });
    }

    async getFromRedis(key) {
        const value = await this.redisCache.get(key);
        return value ? JSON.parse(value) : null;
    }

    async setInRedis(key, value, ttl) {
        const finalTTL = ttl || this.cacheConfig.redis.ttl;
        await this.redisCache.setex(key, finalTTL, value);
    }

    // å¿«å–é ç†±
    async warmup(keys) {
        const promises = keys.map(async (key) => {
            const value = await this.fetchFromSource(key);
            if (value) {
                await this.set(key, value);
            }
        });

        await Promise.all(promises);
    }

    // å¿«å–å¤±æ•ˆç­–ç•¥
    async invalidate(pattern) {
        // æ¸…é™¤è¨˜æ†¶é«”å¿«å–
        for (const [key] of this.memoryCache) {
            if (key.match(pattern)) {
                this.memoryCache.delete(key);
            }
        }

        // æ¸…é™¤ Redis å¿«å–
        const keys = await this.redisCache.keys(pattern);
        if (keys.length > 0) {
            await this.redisCache.del(...keys);
        }
    }
}

// cache/cache-aside-pattern.js
class CacheAsideService {
    constructor(cache, database) {
        this.cache = cache;
        this.database = database;
    }

    async getScenario(scenarioId) {
        const cacheKey = `scenario:${scenarioId}`;
        
        // å˜—è©¦å¾å¿«å–ç²å–
        let scenario = await this.cache.get(cacheKey);
        
        if (!scenario) {
            // å¿«å–æœªå‘½ä¸­ï¼Œå¾è³‡æ–™åº«ç²å–
            scenario = await this.database.findScenario(scenarioId);
            
            if (scenario) {
                // å¯«å…¥å¿«å–
                await this.cache.set(cacheKey, scenario, { ttl: 3600 });
            }
        }
        
        return scenario;
    }

    async updateScenario(scenarioId, data) {
        // æ›´æ–°è³‡æ–™åº«
        const updated = await this.database.updateScenario(scenarioId, data);
        
        // ä½¿å¿«å–å¤±æ•ˆ
        const cacheKey = `scenario:${scenarioId}`;
        await this.cache.invalidate(cacheKey);
        
        // å¯é¸ï¼šç«‹å³é‡æ–°è¼‰å…¥å¿«å–
        await this.cache.set(cacheKey, updated, { ttl: 3600 });
        
        return updated;
    }
}
```

### 10.3.2 è³‡æ–™åº«å„ªåŒ–

```javascript
// database/connection-pool.js
const { Pool } = require('pg');

class DatabaseManager {
    constructor() {
        this.pool = new Pool({
            host: process.env.DB_HOST,
            port: process.env.DB_PORT,
            database: process.env.DB_NAME,
            user: process.env.DB_USER,
            password: process.env.DB_PASSWORD,
            max: 20, // æœ€å¤§é€£ç·šæ•¸
            idleTimeoutMillis: 30000,
            connectionTimeoutMillis: 2000,
        });

        this.setupPoolEvents();
    }

    setupPoolEvents() {
        this.pool.on('error', (err, client) => {
            console.error('Unexpected error on idle client', err);
        });

        this.pool.on('connect', (client) => {
            console.log('New client connected');
        });
    }

    async query(text, params) {
        const start = Date.now();
        const res = await this.pool.query(text, params);
        const duration = Date.now() - start;
        
        // è¨˜éŒ„æ…¢æŸ¥è©¢
        if (duration > 1000) {
            console.log('Slow query detected:', {
                text,
                duration,
                rows: res.rowCount
            });
        }
        
        return res;
    }

    // æ‰¹æ¬¡æ“ä½œå„ªåŒ–
    async batchInsert(table, records) {
        if (records.length === 0) return;

        const columns = Object.keys(records[0]);
        const values = [];
        const placeholders = [];

        records.forEach((record, index) => {
            const rowPlaceholders = columns.map((col, colIndex) => {
                const paramIndex = index * columns.length + colIndex + 1;
                values.push(record[col]);
                return `$${paramIndex}`;
            });
            placeholders.push(`(${rowPlaceholders.join(', ')})`);
        });

        const query = `
            INSERT INTO ${table} (${columns.join(', ')})
            VALUES ${placeholders.join(', ')}
            ON CONFLICT DO NOTHING
            RETURNING *
        `;

        return await this.query(query, values);
    }

    // è®€å¯«åˆ†é›¢
    async getReadReplica() {
        if (!this.readPool) {
            this.readPool = new Pool({
                host: process.env.DB_READ_HOST,
                // ... å…¶ä»–è¨­å®š
            });
        }
        return this.readPool;
    }

    async queryRead(text, params) {
        const pool = await this.getReadReplica();
        return await pool.query(text, params);
    }
}

// database/query-optimizer.js
class QueryOptimizer {
    // æŸ¥è©¢è¨ˆåŠƒå¿«å–
    constructor() {
        this.queryPlanCache = new Map();
    }

    async optimizeQuery(query, params) {
        const queryHash = this.hashQuery(query, params);
        
        // æª¢æŸ¥å¿«å–çš„æŸ¥è©¢è¨ˆåŠƒ
        if (this.queryPlanCache.has(queryHash)) {
            return this.queryPlanCache.get(queryHash);
        }

        // åˆ†ææŸ¥è©¢
        const analysis = await this.analyzeQuery(query);
        
        // å„ªåŒ–å»ºè­°
        const optimized = this.applyOptimizations(query, analysis);
        
        // å¿«å–çµæœ
        this.queryPlanCache.set(queryHash, optimized);
        
        return optimized;
    }

    analyzeQuery(query) {
        // ä½¿ç”¨ EXPLAIN ANALYZE
        return db.query(`EXPLAIN ANALYZE ${query}`);
    }

    applyOptimizations(query, analysis) {
        let optimized = query;

        // åŠ å…¥å¿…è¦çš„ç´¢å¼•æç¤º
        if (analysis.shouldUseIndex) {
            optimized = this.addIndexHint(optimized, analysis.recommendedIndex);
        }

        // å„ªåŒ– JOIN é †åº
        if (analysis.joinOptimization) {
            optimized = this.reorderJoins(optimized, analysis.joinOrder);
        }

        return optimized;
    }
}
```

### 10.3.3 éåŒæ­¥è™•ç†å„ªåŒ–

```javascript
// async/job-queue.js
const Bull = require('bull');

class JobQueueManager {
    constructor() {
        this.queues = new Map();
        this.initializeQueues();
    }

    initializeQueues() {
        // å»ºç«‹ä¸åŒå„ªå…ˆç´šçš„ä½‡åˆ—
        this.createQueue('high-priority', {
            redis: {
                host: process.env.REDIS_HOST,
                port: process.env.REDIS_PORT
            },
            defaultJobOptions: {
                removeOnComplete: true,
                removeOnFail: false,
                attempts: 3,
                backoff: {
                    type: 'exponential',
                    delay: 2000
                }
            }
        });

        this.createQueue('default', {
            redis: {
                host: process.env.REDIS_HOST,
                port: process.env.REDIS_PORT
            }
        });

        this.createQueue('low-priority', {
            redis: {
                host: process.env.REDIS_HOST,
                port: process.env.REDIS_PORT
            },
            defaultJobOptions: {
                delay: 5000 // å»¶é²5ç§’åŸ·è¡Œ
            }
        });
    }

    createQueue(name, options) {
        const queue = new Bull(name, options);
        
        // è¨­å®šä¸¦ç™¼è™•ç†
        queue.process(10, async (job) => {
            return await this.processJob(job);
        });

        // äº‹ä»¶ç›£è½
        queue.on('completed', (job, result) => {
            console.log(`Job ${job.id} completed:`, result);
        });

        queue.on('failed', (job, err) => {
            console.error(`Job ${job.id} failed:`, err);
        });

        this.queues.set(name, queue);
    }

    async addJob(queueName, jobType, data, options = {}) {
        const queue = this.queues.get(queueName);
        if (!queue) {
            throw new Error(`Queue ${queueName} not found`);
        }

        return await queue.add(jobType, {
            type: jobType,
            data,
            timestamp: new Date().toISOString()
        }, options);
    }

    async processJob(job) {
        const { type, data } = job.data;

        switch (type) {
            case 'scenario.execute':
                return await this.executeScenario(data);
            case 'webhook.send':
                return await this.sendWebhook(data);
            case 'report.generate':
                return await this.generateReport(data);
            default:
                throw new Error(`Unknown job type: ${type}`);
        }
    }

    // æ‰¹æ¬¡è™•ç†å„ªåŒ–
    async processBatch(jobs) {
        const batchSize = 50;
        const results = [];

        for (let i = 0; i < jobs.length; i += batchSize) {
            const batch = jobs.slice(i, i + batchSize);
            const batchResults = await Promise.all(
                batch.map(job => this.processJob(job))
            );
            results.push(...batchResults);
        }

        return results;
    }
}

// async/circuit-breaker.js
class CircuitBreaker {
    constructor(options = {}) {
        this.failureThreshold = options.failureThreshold || 5;
        this.resetTimeout = options.resetTimeout || 60000;
        this.state = 'CLOSED';
        this.failures = 0;
        this.nextAttempt = Date.now();
    }

    async call(fn, ...args) {
        if (this.state === 'OPEN') {
            if (Date.now() < this.nextAttempt) {
                throw new Error('Circuit breaker is OPEN');
            }
            this.state = 'HALF_OPEN';
        }

        try {
            const result = await fn(...args);
            this.onSuccess();
            return result;
        } catch (error) {
            this.onFailure();
            throw error;
        }
    }

    onSuccess() {
        this.failures = 0;
        if (this.state === 'HALF_OPEN') {
            this.state = 'CLOSED';
        }
    }

    onFailure() {
        this.failures++;
        if (this.failures >= this.failureThreshold) {
            this.state = 'OPEN';
            this.nextAttempt = Date.now() + this.resetTimeout;
        }
    }
}
```

## 10.4 æ“´å±•æ€§è¨­è¨ˆ

### 10.4.1 æ°´å¹³æ“´å±•æ¶æ§‹

```javascript
// scaling/load-balancer.js
class LoadBalancer {
    constructor() {
        this.servers = [];
        this.currentIndex = 0;
        this.healthChecker = new HealthChecker();
    }

    addServer(server) {
        this.servers.push({
            ...server,
            healthy: true,
            weight: server.weight || 1,
            activeConnections: 0
        });
    }

    // è¼ªè©¢æ¼”ç®—æ³•
    roundRobin() {
        const healthyServers = this.servers.filter(s => s.healthy);
        if (healthyServers.length === 0) {
            throw new Error('No healthy servers available');
        }

        const server = healthyServers[this.currentIndex % healthyServers.length];
        this.currentIndex++;
        
        return server;
    }

    // æœ€å°‘é€£ç·šæ¼”ç®—æ³•
    leastConnections() {
        const healthyServers = this.servers.filter(s => s.healthy);
        if (healthyServers.length === 0) {
            throw new Error('No healthy servers available');
        }

        return healthyServers.reduce((min, server) => 
            server.activeConnections < min.activeConnections ? server : min
        );
    }

    // åŠ æ¬Šè¼ªè©¢æ¼”ç®—æ³•
    weightedRoundRobin() {
        const healthyServers = this.servers.filter(s => s.healthy);
        if (healthyServers.length === 0) {
            throw new Error('No healthy servers available');
        }

        const totalWeight = healthyServers.reduce((sum, s) => sum + s.weight, 0);
        let random = Math.random() * totalWeight;

        for (const server of healthyServers) {
            random -= server.weight;
            if (random <= 0) {
                return server;
            }
        }

        return healthyServers[0];
    }

    async healthCheck() {
        const checks = this.servers.map(async (server) => {
            const isHealthy = await this.healthChecker.check(server.url);
            server.healthy = isHealthy;
        });

        await Promise.all(checks);
    }
}

// scaling/session-manager.js
class DistributedSessionManager {
    constructor(redis) {
        this.redis = redis;
        this.sessionTimeout = 3600; // 1å°æ™‚
    }

    async createSession(userId, data) {
        const sessionId = crypto.randomUUID();
        const sessionData = {
            userId,
            data,
            createdAt: new Date().toISOString(),
            lastAccessed: new Date().toISOString()
        };

        await this.redis.setex(
            `session:${sessionId}`,
            this.sessionTimeout,
            JSON.stringify(sessionData)
        );

        return sessionId;
    }

    async getSession(sessionId) {
        const data = await this.redis.get(`session:${sessionId}`);
        if (!data) return null;

        const session = JSON.parse(data);
        
        // æ›´æ–°æœ€å¾Œå­˜å–æ™‚é–“
        session.lastAccessed = new Date().toISOString();
        await this.redis.setex(
            `session:${sessionId}`,
            this.sessionTimeout,
            JSON.stringify(session)
        );

        return session;
    }

    async destroySession(sessionId) {
        await this.redis.del(`session:${sessionId}`);
    }

    // æœƒè©±è¤‡è£½
    async replicateSession(sessionId, targetNode) {
        const session = await this.getSession(sessionId);
        if (!session) return;

        // ç™¼é€åˆ°ç›®æ¨™ç¯€é»
        await axios.post(`${targetNode}/api/sessions/replicate`, {
            sessionId,
            session
        });
    }
}
```

### 10.4.2 åˆ†æ•£å¼ç³»çµ±è¨­è¨ˆ

```javascript
// distributed/coordinator.js
const ZooKeeper = require('node-zookeeper-client');

class DistributedCoordinator {
    constructor() {
        this.client = ZooKeeper.createClient(process.env.ZOOKEEPER_URL);
        this.setupClient();
    }

    setupClient() {
        this.client.on('connected', () => {
            console.log('Connected to ZooKeeper');
            this.registerNode();
        });

        this.client.on('disconnected', () => {
            console.log('Disconnected from ZooKeeper');
        });

        this.client.connect();
    }

    async registerNode() {
        const nodePath = `/services/make-bridge/nodes/${process.env.NODE_ID}`;
        const nodeData = Buffer.from(JSON.stringify({
            id: process.env.NODE_ID,
            host: process.env.NODE_HOST,
            port: process.env.NODE_PORT,
            startTime: new Date().toISOString()
        }));

        await this.createPath(nodePath, nodeData, ZooKeeper.CreateMode.EPHEMERAL);
    }

    async electLeader() {
        const electionPath = '/services/make-bridge/election';
        
        try {
            // å˜—è©¦å»ºç«‹é ˜å°ç¯€é»
            await this.createPath(
                `${electionPath}/leader`,
                Buffer.from(process.env.NODE_ID),
                ZooKeeper.CreateMode.EPHEMERAL
            );
            
            console.log('This node is now the leader');
            return true;
        } catch (error) {
            if (error.code === ZooKeeper.Exception.NODE_EXISTS) {
                console.log('Another node is already the leader');
                return false;
            }
            throw error;
        }
    }

    async distributedLock(resource, callback) {
        const lockPath = `/locks/${resource}`;
        let lockAcquired = false;

        try {
            await this.createPath(
                lockPath,
                Buffer.from(process.env.NODE_ID),
                ZooKeeper.CreateMode.EPHEMERAL
            );
            
            lockAcquired = true;
            return await callback();
        } finally {
            if (lockAcquired) {
                await this.deletePath(lockPath);
            }
        }
    }
}

// distributed/sharding.js
class ShardingManager {
    constructor(shards) {
        this.shards = shards;
        this.hashRing = new ConsistentHash();
        this.initializeHashRing();
    }

    initializeHashRing() {
        this.shards.forEach(shard => {
            // æ¯å€‹åˆ†ç‰‡åŠ å…¥å¤šå€‹è™›æ“¬ç¯€é»
            for (let i = 0; i < 150; i++) {
                this.hashRing.add(`${shard.id}-${i}`, shard);
            }
        });
    }

    getShard(key) {
        return this.hashRing.get(key);
    }

    async redistribute(newShards) {
        const oldShards = this.shards;
        this.shards = newShards;
        this.initializeHashRing();

        // è³‡æ–™é·ç§»
        for (const oldShard of oldShards) {
            const data = await this.fetchAllData(oldShard);
            
            for (const item of data) {
                const newShard = this.getShard(item.key);
                if (newShard.id !== oldShard.id) {
                    await this.migrateData(item, oldShard, newShard);
                }
            }
        }
    }
}

class ConsistentHash {
    constructor() {
        this.ring = new Map();
        this.sortedKeys = [];
    }

    add(key, value) {
        const hash = this.hash(key);
        this.ring.set(hash, value);
        this.sortedKeys.push(hash);
        this.sortedKeys.sort((a, b) => a - b);
    }

    get(key) {
        if (this.ring.size === 0) return null;

        const hash = this.hash(key);
        const index = this.binarySearch(hash);
        const targetHash = this.sortedKeys[index];
        
        return this.ring.get(targetHash);
    }

    hash(key) {
        // ä½¿ç”¨ MurmurHash3 æˆ–é¡ä¼¼æ¼”ç®—æ³•
        return murmurHash3(key);
    }

    binarySearch(hash) {
        let left = 0;
        let right = this.sortedKeys.length - 1;

        while (left <= right) {
            const mid = Math.floor((left + right) / 2);
            if (this.sortedKeys[mid] === hash) return mid;
            if (this.sortedKeys[mid] < hash) left = mid + 1;
            else right = mid - 1;
        }

        return left % this.sortedKeys.length;
    }
}
```

## 10.5 ç›£æ§èˆ‡å¯è§€æ¸¬æ€§

### 10.5.1 åˆ†æ•£å¼è¿½è¹¤

```javascript
// monitoring/tracing.js
const opentelemetry = require('@opentelemetry/api');
const { NodeTracerProvider } = require('@opentelemetry/sdk-trace-node');
const { JaegerExporter } = require('@opentelemetry/exporter-jaeger');

class TracingService {
    constructor() {
        this.provider = new NodeTracerProvider();
        this.setupExporter();
        this.tracer = opentelemetry.trace.getTracer('make-bridge', '1.0.0');
    }

    setupExporter() {
        const jaegerExporter = new JaegerExporter({
            endpoint: process.env.JAEGER_ENDPOINT,
            serviceName: 'make-bridge'
        });

        this.provider.addSpanProcessor(
            new opentelemetry.sdk.trace.SimpleSpanProcessor(jaegerExporter)
        );

        this.provider.register();
    }

    startSpan(name, options = {}) {
        return this.tracer.startSpan(name, options);
    }

    // è‡ªå‹•è¿½è¹¤ HTTP è«‹æ±‚
    traceMiddleware() {
        return (req, res, next) => {
            const span = this.startSpan(`${req.method} ${req.path}`, {
                kind: opentelemetry.SpanKind.SERVER,
                attributes: {
                    'http.method': req.method,
                    'http.url': req.url,
                    'http.target': req.path,
                    'http.host': req.hostname,
                    'http.scheme': req.protocol,
                    'http.user_agent': req.headers['user-agent']
                }
            });

            // æ³¨å…¥è¿½è¹¤ä¸Šä¸‹æ–‡
            req.span = span;

            // æ””æˆªéŸ¿æ‡‰
            const originalSend = res.send;
            res.send = function(data) {
                span.setAttributes({
                    'http.status_code': res.statusCode,
                    'http.response_size': Buffer.byteLength(data)
                });

                if (res.statusCode >= 400) {
                    span.setStatus({
                        code: opentelemetry.SpanStatusCode.ERROR,
                        message: `HTTP ${res.statusCode}`
                    });
                }

                span.end();
                originalSend.call(this, data);
            };

            next();
        };
    }

    // è¿½è¹¤è³‡æ–™åº«æ“ä½œ
    async traceDatabase(operation, query, params) {
        const span = this.startSpan(`db.${operation}`, {
            kind: opentelemetry.SpanKind.CLIENT,
            attributes: {
                'db.system': 'postgresql',
                'db.operation': operation,
                'db.statement': query
            }
        });

        try {
            const result = await this.executeQuery(query, params);
            span.setStatus({ code: opentelemetry.SpanStatusCode.OK });
            return result;
        } catch (error) {
            span.recordException(error);
            span.setStatus({
                code: opentelemetry.SpanStatusCode.ERROR,
                message: error.message
            });
            throw error;
        } finally {
            span.end();
        }
    }
}

// monitoring/metrics.js
const prometheus = require('prom-client');

class MetricsCollector {
    constructor() {
        this.register = new prometheus.Registry();
        this.setupMetrics();
    }

    setupMetrics() {
        // HTTP è«‹æ±‚è¨ˆæ•¸å™¨
        this.httpRequestsTotal = new prometheus.Counter({
            name: 'http_requests_total',
            help: 'Total number of HTTP requests',
            labelNames: ['method', 'route', 'status'],
            registers: [this.register]
        });

        // HTTP è«‹æ±‚æŒçºŒæ™‚é–“
        this.httpRequestDuration = new prometheus.Histogram({
            name: 'http_request_duration_seconds',
            help: 'Duration of HTTP requests in seconds',
            labelNames: ['method', 'route', 'status'],
            buckets: [0.1, 0.3, 0.5, 0.7, 1, 3, 5, 7, 10],
            registers: [this.register]
        });

        // æ´»èºå ´æ™¯æ•¸é‡
        this.activeScenariosGauge = new prometheus.Gauge({
            name: 'active_scenarios_total',
            help: 'Total number of active scenarios',
            registers: [this.register]
        });

        // API å‘¼å«é€Ÿç‡
        this.apiCallRate = new prometheus.Counter({
            name: 'api_calls_total',
            help: 'Total number of API calls',
            labelNames: ['endpoint', 'status'],
            registers: [this.register]
        });

        // ç³»çµ±è³‡æºä½¿ç”¨
        prometheus.collectDefaultMetrics({ register: this.register });
    }

    metricsMiddleware() {
        return (req, res, next) => {
            const start = Date.now();

            res.on('finish', () => {
                const duration = (Date.now() - start) / 1000;
                const route = req.route?.path || req.path;

                this.httpRequestsTotal.inc({
                    method: req.method,
                    route,
                    status: res.statusCode
                });

                this.httpRequestDuration.observe({
                    method: req.method,
                    route,
                    status: res.statusCode
                }, duration);
            });

            next();
        };
    }

    async getMetrics() {
        return await this.register.metrics();
    }
}
```

### 10.5.2 æ—¥èªŒç®¡ç†

```javascript
// monitoring/structured-logging.js
const winston = require('winston');
const { ElasticsearchTransport } = require('winston-elasticsearch');

class StructuredLogger {
    constructor() {
        this.logger = this.createLogger();
    }

    createLogger() {
        return winston.createLogger({
            level: process.env.LOG_LEVEL || 'info',
            format: winston.format.combine(
                winston.format.timestamp(),
                winston.format.errors({ stack: true }),
                winston.format.json()
            ),
            defaultMeta: {
                service: 'make-bridge',
                environment: process.env.NODE_ENV,
                nodeId: process.env.NODE_ID
            },
            transports: [
                // æ§åˆ¶å°è¼¸å‡º
                new winston.transports.Console({
                    format: winston.format.combine(
                        winston.format.colorize(),
                        winston.format.simple()
                    )
                }),
                // æª”æ¡ˆè¼¸å‡º
                new winston.transports.File({
                    filename: 'logs/error.log',
                    level: 'error',
                    maxsize: 10485760, // 10MB
                    maxFiles: 5
                }),
                new winston.transports.File({
                    filename: 'logs/combined.log',
                    maxsize: 10485760,
                    maxFiles: 5
                }),
                // Elasticsearch
                new ElasticsearchTransport({
                    level: 'info',
                    clientOpts: {
                        node: process.env.ELASTICSEARCH_URL
                    },
                    index: 'make-bridge-logs'
                })
            ]
        });
    }

    // è«‹æ±‚æ—¥èªŒä¸­é–“ä»¶
    requestLogger() {
        return (req, res, next) => {
            const requestId = req.headers['x-request-id'] || crypto.randomUUID();
            req.requestId = requestId;

            // è¨˜éŒ„è«‹æ±‚
            this.logger.info('HTTP Request', {
                requestId,
                method: req.method,
                url: req.url,
                headers: req.headers,
                ip: req.ip,
                userAgent: req.headers['user-agent']
            });

            // è¨˜éŒ„éŸ¿æ‡‰
            const originalSend = res.send;
            res.send = function(data) {
                const responseTime = Date.now() - req.startTime;

                this.logger.info('HTTP Response', {
                    requestId,
                    statusCode: res.statusCode,
                    responseTime,
                    contentLength: res.get('content-length')
                });

                originalSend.call(this, data);
            }.bind(this);

            req.startTime = Date.now();
            next();
        };
    }

    // éŒ¯èª¤æ—¥èªŒ
    logError(error, context = {}) {
        this.logger.error('Application Error', {
            ...context,
            error: {
                message: error.message,
                stack: error.stack,
                name: error.name
            }
        });
    }

    // å¯©è¨ˆæ—¥èªŒ
    logAudit(action, userId, details = {}) {
        this.logger.info('Audit Log', {
            type: 'audit',
            action,
            userId,
            timestamp: new Date().toISOString(),
            details
        });
    }
}
```

## 10.6 ç”Ÿç”¢ç’°å¢ƒéƒ¨ç½²

### 10.6.1 å®¹å™¨åŒ–éƒ¨ç½²

```dockerfile
# Dockerfile
FROM node:18-alpine AS builder

WORKDIR /app

# å®‰è£ä¾è³´
COPY package*.json ./
RUN npm ci --only=production

# è¤‡è£½æ‡‰ç”¨ç¨‹å¼ç¢¼
COPY . .

# å»ºç½®éšæ®µ
FROM node:18-alpine

WORKDIR /app

# å®‰è£åŸ·è¡Œæ™‚ä¾è³´
RUN apk add --no-cache tini

# å¾å»ºç½®éšæ®µè¤‡è£½
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/package*.json ./

# å»ºç«‹é root ä½¿ç”¨è€…
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nodejs -u 1001
USER nodejs

# å¥åº·æª¢æŸ¥
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD node healthcheck.js

# ä½¿ç”¨ tini ä½œç‚º init ç³»çµ±
ENTRYPOINT ["/sbin/tini", "--"]

# å•Ÿå‹•æ‡‰ç”¨
CMD ["node", "dist/index.js"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  make-bridge:
    image: make-bridge:latest
    deploy:
      replicas: 3
      update_config:
        parallelism: 1
        delay: 10s
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
    environment:
      - NODE_ENV=production
      - JWT_SECRET=${JWT_SECRET}
      - DATABASE_URL=${DATABASE_URL}
      - REDIS_URL=${REDIS_URL}
    ports:
      - "3000-3002:3000"
    networks:
      - bridge-network
    depends_on:
      - postgres
      - redis

  postgres:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=makebridge
      - POSTGRES_USER=${DB_USER}
      - POSTGRES_PASSWORD=${DB_PASSWORD}
    volumes:
      - postgres-data:/var/lib/postgresql/data
    networks:
      - bridge-network

  redis:
    image: redis:7-alpine
    command: redis-server --appendonly yes
    volumes:
      - redis-data:/data
    networks:
      - bridge-network

  nginx:
    image: nginx:alpine
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    ports:
      - "80:80"
      - "443:443"
    networks:
      - bridge-network
    depends_on:
      - make-bridge

volumes:
  postgres-data:
  redis-data:

networks:
  bridge-network:
    driver: bridge
```

### 10.6.2 Kubernetes éƒ¨ç½²

```yaml
# k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: make-bridge
  namespace: production
spec:
  replicas: 3
  selector:
    matchLabels:
      app: make-bridge
  template:
    metadata:
      labels:
        app: make-bridge
    spec:
      containers:
      - name: make-bridge
        image: make-bridge:latest
        ports:
        - containerPort: 3000
        env:
        - name: NODE_ENV
          value: "production"
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: make-bridge-secrets
              key: jwt-secret
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: make-bridge-secrets
              key: database-url
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: make-bridge-service
  namespace: production
spec:
  selector:
    app: make-bridge
  ports:
  - protocol: TCP
    port: 80
    targetPort: 3000
  type: LoadBalancer

---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: make-bridge-hpa
  namespace: production
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: make-bridge
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
```

## ç¸½çµ

æœ¬ç« æ¶µè“‹äº† Make Bridge çš„ä¼æ¥­ç´šæ¶æ§‹è¨­è¨ˆèˆ‡æœ€ä½³å¯¦è¸ï¼ŒåŒ…æ‹¬ï¼š

1. **æ¶æ§‹æ¨¡å¼**ï¼šå¾®æœå‹™ã€äº‹ä»¶é©…å‹•ã€CQRS
2. **å®‰å…¨æ€§**ï¼šå®Œæ•´çš„èªè­‰æˆæ¬Šã€API é˜²è­·ã€åŠ å¯†æ©Ÿåˆ¶
3. **æ•ˆèƒ½å„ªåŒ–**ï¼šå¤šå±¤å¿«å–ã€è³‡æ–™åº«å„ªåŒ–ã€éåŒæ­¥è™•ç†
4. **æ“´å±•æ€§**ï¼šæ°´å¹³æ“´å±•ã€åˆ†æ•£å¼ç³»çµ±ã€è² è¼‰å¹³è¡¡
5. **ç›£æ§**ï¼šåˆ†æ•£å¼è¿½è¹¤ã€æŒ‡æ¨™æ”¶é›†ã€çµæ§‹åŒ–æ—¥èªŒ
6. **éƒ¨ç½²**ï¼šå®¹å™¨åŒ–ã€Kubernetesã€ç”Ÿç”¢ç’°å¢ƒé…ç½®

é€™äº›å¯¦è¸ç¶“éå¯¦éš›å°ˆæ¡ˆé©—è­‰ï¼Œèƒ½å¤ æ”¯æ´å¤§è¦æ¨¡çš„ä¼æ¥­æ‡‰ç”¨éƒ¨ç½²ã€‚

## ä¸‹ä¸€ç« é å‘Š

åœ¨ç¬¬åä¸€ç« ä¸­ï¼Œæˆ‘å€‘å°‡æä¾›å®Œæ•´çš„ API åƒè€ƒæ–‡æª”ï¼Œè©³ç´°èªªæ˜æ‰€æœ‰å¯ç”¨çš„ API ç«¯é»ã€åƒæ•¸å’Œå›æ‡‰æ ¼å¼ã€‚